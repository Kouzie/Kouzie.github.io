---
title:  "쿠버네티스 - 개요!"

read_time: false
share: false
author_profile: false
toc: true
toc_sticky: true
# classes: wide

categories:
  - kubernetes
---


# 쿠버네티스

구글에서 스타트한 오픈소스로 구성된 컨테이너 오케스트레이션 툴.  

컨테이너 오케스트레이션 툴은 쿠버네티스 외에도 Amazone ECS, 도커 스웜, 아마치 노마드, 아파치 Mesos 등이 있다.  

이중에서 가장 인기있는 컨테이너 오케스트레이션 툴이 쿠버네티스이다.  

## docker desktop

쿠버네티스 실습용으로 실제 클러스터용 PC 를 여러대 구매하여 구축하면 좋겠지만   
mac, window 등의 도커 설치시 `docker desktop` 으로 설치하면 쿠버네티스를 쉽게 사용 가능하다.  

![kube7](/assets/kube/kube7.png)  

> 별다른 이유가 없다면 `docker desktop` 을 사용하는것을 추천

## minikube 설치

`minikube` 라는 툴로도 가상으로 로컬피시에 환경 구축이 가능하다.  

가상환경은 기본적으로 `docker` 를 사용하도록 설정한다.  

```
$ brew install minikube
$ minikube start --driver=docker
😄  Darwin 10.15.4 위의 minikube v1.9.2
...
🏄  끝났습니다! 이제 kubectl 이 "minikube" 를 사용할 수 있도록 설정되었습니다
$ minikube config set driver docker # docker 를 기본 가상드라이버로 설정  
```

실행된 `minikube` 상태 조회  

```
$ minikube status
m01
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

$ docker ps
CONTAINER ID        IMAGE                                COMMAND                  CREATED             STATUS              PORTS                                                                           NAMES
2f61e951c809        gcr.io/k8s-minikube/kicbase:v0.0.8   "/usr/local/bin/entr…"   13 minutes ago      Up 10 minutes       127.0.0.1:32773->22/tcp, 127.0.0.1:32772->2376/tcp, 127.0.0.1:32771->8443/tcp   minikube

$ minikube stop
$ minikube start
```

`kubectl` 명령을 통해 로컬에 설치된 클러스터를 조작 가능하다.  

```
$ kubectl get node -o=wide
NAME       STATUS   ROLES    AGE     VERSION   INTERNAL-IP   EXTERNAL-IP   OS-IMAGE       KERNEL-VERSION     CONTAINER-RUNTIME
minikube   Ready    master   4m25s   v1.18.0   172.17.0.2    <none>        Ubuntu 19.10   4.19.76-linuxkit   docker://19.3.2
$ kubectl version --output yaml # 버전 확인
```


<!-- 
## 쿠버네티스 설치 - kubeadm

> https://kubernetes.io/ko/docs/setup/production-environment/tools/

대부분의 클라우드 서비스 업체에서 자체 운영 클러스터를 제공하지만
로컬 PC 여러대로 쿠버네티스 구축시에 위의 툴을 사용하여 쉽게 구축 가능함.  

> https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/
`kubeadm` - 쿠버네티스 공식 클러스터 생성/관리 도구  

> https://medium.com/finda-tech/overview-8d169b2a54ff



### 사전 설정  

```
$ sudo modprobe br_netfilter # 커널 모듈 적재 - 

$ sudo swapoff -a # 스왑 비활성 

$ lsmod | grep br_netfilter  # br_netfilter 커널 모듈이 올라가있는지 확인
br_netfilter           28672  0
bridge                176128  1 br_netfilter

$ cat <<EOF | sudo tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF

$ sudo sysctl --system
```

> `br_netfilter` - 브릿지를 통해 전달되는 패킷이 `iptables` 에 제어됨, `Pod` 간 통신시 필요  
> `/etc/sysctl.d/k8s.conf` 파일 역시 브릿지간 패킷 통신을 위한 설정파일  

```
$ curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -
$ cat <<EOF | sudo tee /etc/apt/sources.list.d/kubernetes.list
deb https://apt.kubernetes.io/ kubernetes-xenial main
EOF
```

> `gpg` 설정 및 `apt list` 추가  

```
$ sudo apt-get update && sudo apt-get install -y apt-transport-https curl
$ sudo apt-get install -y kubelet kubeadm kubectl
$ sudo apt-mark hold kubelet kubeadm kubectl
```

> `kubelet` `kubeadm` `kubectl` 설치  


```
$ sudo kubeadm init --pod-network-cidr=172.28.0.0/14
```

> 네트워크 대역 설정 

### kubectl 등록  

```
$ mkdir -p $HOME/.kube
$ sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
$ sudo chown $(id -u):$(id -g) $HOME/.kube/config
```

> `kubectl` 을 통해 컨트롤 하고 싶은 pc 에 위 명령어 삽입 

```
$ sudo kubeadm token list
TOKEN                     TTL         EXPIRES                     USAGES                   DESCRIPTION                                                EXTRA GROUPS
<TOKEN-VALUE>             23h         kube-10-27T14:07:05+09:00   authentication,signing   The default bootstrap token generated by 'kubeadm init'.   system:bootstrappers:kubeadm:default-node-token
```

> `kube master` 에서 토큰과 `hash` 값 확인  

```
$ openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2>/dev/null | openssl dgst -sha256 -hex | sed 's/^.* //'
<SHA-256 HASH-VALUE>
```

### 노드 추가

```
$ sudo swapoff -a
$ sudo kubeadm join 192.168.10.235:6443 --token <TOKEN-VALUE> \
    --discovery-token-ca-cert-hash sha256:<SHA-256 HASH-VALUE>
```
 -->


## k8s cli tool - kubectl 

마스터 컴포넌트 중 하나인 `API Server` 와 통신하기 위해 `kubectl` 명령을 사용한다.   
`kubectl` 과 `API Server`가 어떻게 연결되어 있는지 알아보자.  

```
$ ls ~/.kube
cache      config     http-cache
```

```yaml
clusters:
- cluster:
    certificate-authority: /Users/gojiyong/.minikube/ca.crt
    server: https://127.0.0.1:32768
  name: minikube 
# kubectl 명령 실행시 사용할 클러스터 정보

contexts:
- context:
    cluster: minikube
    user: minikube
  name: minikube
current-context: minikube
kind: Config
preferences: {}
# 클러스터 사용자 정보 context, 

users:
- name: minikube
  user:
    client-certificate: /Users/gojiyong/.minikube/profiles/minikube/client.crt
	client-key: /Users/gojiyong/.minikube/profiles/minikube/client.key
# 엑세스 하는 사용자 정보 - 클러스터 엑세스를 위한 인증 키 등 설정  
```



# 쿠버네티스 아키텍처

![kube1](/assets/kube/kube1.png)  

쿠버네티스는 아키텍처는 전체적으로 `master` 와 `node` 로 구성되며  
내부에서 역할에 맞는 여러 컴포넌트를 가진다.  

## 마스터

쿠버네티스 클러스터 전체를 관리하는 역할   
여러대의 클러스터 노드의 리소스 상황 파악, 컨테이너를 가동시킬 노드를 선택  

`etcd` 라는 분산 `Key-value store` 를 사용해 클러스터 구성정보를 관리  

> `/etc` + `distribute` 의 약어. 
> 레드헷에서 설정파일을 서버간 공유하기 위해 만든 툴을 쿠버네티스에서 승계함.  



## 노드

> https://kubernetes.io/ko/docs/tutorials/kubernetes-basics/explore/explore-intro/

컨테이너가 작동되는 서버, 여러대의 노드를 준비해 클러스터를 구성,  
노드는 클라우드 서비스 회사의 가상 머신 혹은 물리 머신이 노드역할을 한다.  

해당 노드안에서 여러대의 컨테이너(일반적으로 도커)가 동작  


# 쿠버네티스 컴포넌트

> https://kubernetes.io/ko/docs/concepts/overview/components/

마스터와 노드는 내부에서 각종 동작을 하는 컴포넌트(노드, 마스터)들이 존재한다.

## 마스터 컴포넌트

**API Server** - 쿠버의 리소스 정보를 관리하기 위한 Rest API 앤드포인트 서버,  
각 컴포넌트로부터 정보를 받아 `etcd` 에 저장, 컴포넌트간 통신, 노드간 통신을 지원한다.  
그림을 보면 모든 컴포넌트들이 `API Server` 를 통해 통신하는 것을 알 수 있음.  
`kubectl` 명령 또한 `API Server` 를 통해 전파된다.  

**데이터 스토어(etcd)** - 클러스터의 구성을 유지하는 분산 `key-value store`, 노드의 상태정보, 쿠버네티스에서 필요한 모든 설정 정보가 들어가 있으며 `API Server` 가 이를 참조해 각 컴포넌트가 동작할 수 있도록 도와줌,  
중요한 데이터이기에 백업, 별도의 서버들에 분산실행 한다.  

**스케줄러** - 파드를 어느 노드에서 작동시킬지를 제어하는 백앤드 컴포넌트, `API Server` 와 통신하며 클러스터 상태를 확인, 빈공간의 노드에 파드를 할당 및 실행하는 스케줄링을 처리한다.  

**컨트롤러 매니저** - 파드를 관리하는 컨트롤러들이 곳곳에 배치되어 있고 이 컨트롤러 각각을 실행하는 컴포넌트가 컨트롤러 매니저. 클러스터의 상태를 감시, 항상 정상상태를 유지시키는 백앤드 컴포넌트

## 노드 컴포넌트

**kubelet** - 노드 내부에선 `kubelet` 이라는 에이전트가 움직이며 컨테이너(파드)를 실행, 헬스체크 한다.  
노드의 `status` 를 정기적으로 감시하며 이를 `API Server` 로 전송, `etcd` 에 저장되도록 지원.    

**kube-proxy** - 클러스터 안의 별도의 가상 네트워크 설정, 노드로 들어오는 패킷을 적절한 컨테이너(파드)로 라우팅, 로드밸런싱 등의 동작을 관리하는 컴포넌트

# 쿠버네티스 리소스

## 파드(Pod)

> https://kubernetes.io/ko/docs/concepts/workloads/pods/

`k8s` 에선 여러개의 컨테이너를 모아 파드로 관리한다.  

![kube2](/assets/kube/kube2.png){: .shadow}{: width="400"} 

파드 내부에서 웹서버용, 파일서버용, 프록시 서버용 도커 컨테이너 여러개를 모아 관리할 수 있다.  
쿠버에선 이 파드가 앱 디플로이 단위가 되며 파드 단위로 컨테이너 작성, 시작, 정지, 삭제 등의 조작을 진행한다.  

파드는 항상 하나의 노드에 배치되며 파드가 쪼개질 순 없다.  

따라서 파드 내부에서 가상 네트워크 인터페이스 카드(**사설IP**)를 각 컨테이너에게 발급하며 서로 같은 네트워크 안에 있음으로 `localhost` 를 통해 통신 가능하다.  

## 리플리카 셋(Replica Set)

> https://kubernetes.io/ko/docs/concepts/workloads/controllers/replicaset/

**클러스터 안에서 가동되는 파드 수를 관리하는 리소스**

클러스터 안에 지정된 수의 파드를 일정하게 유지하며 장애대응 및 자동 실행하는 역할.  

## 디플로이먼트(Deployment)

> https://kubernetes.io/ko/docs/concepts/workloads/controllers/deployment/

**애플리케이션 배포 버전 단위를 관리하는 리소스**. 

파드안의 컨테이너를 버전업 하고 싶을 때 시스템을 정지시키지 않고 버전업(롤링업데이트), 롤백 기능 등을 제공한다.  

## 데몬 셋(Daemon Set)

> https://kubernetes.io/ko/docs/concepts/workloads/controllers/daemonset/

**특정노드 혹은 모든 노드에 항상 실행되어야할 특정 컨테이너(파드)를 관리하는 리소스**

마스터 노드의 스케줄러에 영향을 받지 않고 지정한 노드에서 컨테이너를 동작시키고 싶을때 사용한다.

예를들어 로그콜렉터, 모니터링 기능을 하는 컨테이너(파드)는 노드당 하나씩 작동시키고 싶은 경우가 있는데 이때 데몬셋을 사용한다.  

> `kube-proxy` 또한 데몬 셋을 사용해 가동된다.  

## 스테이트풀 셋(Stateful Set)

**고정된 상태(Stateful) 을 요구하는 컨테이너(파드)를 관리하는 리소스**

> https://kubernetes.io/ko/docs/concepts/workloads/controllers/statefulset/

컨테이너는 `stateless` 로 실행된다, 어떤 노드에서 어떤 IP 를 가지고 실행될지 모른다는 뜻이다.  
DB와 같은 고정된 상태(Stateful)를 필요로 하는 컨테이너의 경우 **스테이트풀 셋** 를 사용한다.

안정성, 고정성, 지속성 을 보증한다.  

# 매니페스트 파일(Manifest file, 템플릿)

> Manifest: 선언서

클러스터 내부에서 움직이는 컨테이너, 네트워크, 잡 등의 **쿠버네티스 리소스를 매니페스트 파일을 통해 관리한다.**

`yaml`, `json` 형식의 파일로 구성된다.   

k8s 의 모든 리소스는 매니페스트 파일을 통해 이루어지기 때문에  
리소스별 문법을 익혀야 한다.  

```yaml
# webserver.yaml
apiVersion: apps/v1 # api 버전 정보 - 호출할 api 버전 지정, kubectl api-versions 로 사용할 수 있는 버전 확인 가능.
kind: ReplicaSet # 쿠버 리소스 종류 - Pod, ReplicaSet, Service, ConfigMap, Job 등등
metadata: # 해당 오브젝트 이름, 레이블 지정
  name: webserver # 리소스 이름 - kubectl 명령으로 조작할 때 사용하는 이름
spec: # 리소스의 상세 정보, 실행 동작 방식 등을 지정, 아래는 kind = ReplicaSet 에서 사용 가능한 속성들  
  replicas: 10
  selector:
    matchLabels:
      app: webfront
  template:
    metadata:
      labels:
        app: webfront
    spec:
      containers:
      - image: nginx
        name: webfront-container
        ports:
          - containerPort: 80
```

위와 같이 매니페스트 파일을 사용해 쿠버네티스 리소스 생성, 삭제가능  

```
$ kubectl apply -f webserver.yaml
replicaset.apps/webserver created

$ kubectl delete -f webserver.yaml
replicaset.apps "webserver" deleted
```

매니페스트 파일의 정보는 `etcd` 에 저장되고 관리한다.  
`kuberctl` 명령으로 매니페스트 파일 업데이트가 가능하며 업데이트 버전 정보가 추가 기록된다.   

`kubectl explain` 명령어를 통해 리소스별 사용 가능한 내부 속성을 볼 수 있다.  

```
$ kubectl explain pods
KIND:     Pod
VERSION:  v1

DESCRIPTION:
     Pod is a collection of containers that can run on a host. This resource is
     created by clients and scheduled onto hosts.

FIELDS:
   apiVersion	<string>
     APIVersion defines the versioned schema of this representation of an
     ...

$ kubectl explain pods.metadata
KIND:     Pod
VERSION:  v1

RESOURCE: metadata <Object>

DESCRIPTION:
     Standard object's metadata. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata

     ObjectMeta is metadata that all persisted resources must have, which
     includes all objects users must create.

FIELDS:
   annotations	<map[string]string>
     Annotations is an unstructured key value map stored with a resource that
     may be set by external tools to store and retrieve arbitrary metadata. They
     ...
```

데이터 타입과 함께 트리형식으로 출력 가능  

```
$ kubectl explain pods --recursive
...
```

## kind  

> <https://kubernetes.io/ko/docs/concepts/overview/working-with-objects/kubernetes-objects/>

`kind` 속성에는 메니페스트에 설정할 **쿠버네티스 리소스 종류**를 기술한다.  

* 애플리케이션 실행 - `Pod`, `ReplicaSet`, `Deployment`  
* 네트워크 관리 - `Service`, `Ingress`  
* 애플리케이션 설정 정보 관리 - `ConfigMap`, `Secrets`
* 배치잡 관리 - `Job`, `CronJob`  

## metadata.labels

> <https://kubernetes.io/ko/docs/concepts/overview/working-with-objects/labels/>

쿠버에선 수월한 리소스 관리 를 위해 `key-value` 형식의  `label` 를 사용한다.  

```yaml
# Label/label-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod-a
  labels:
    env: test
    app: photo-view
spec:
  containers:
  - image: nginx
	name: photoview-container
---
apiVersion: v1 # --- 를 사용해 하나의 파일에 2개의 리소스 정보 입력 가능
kind: Pod
metadata:
  name: nginx-pod-b
  labels:
    env: test
    app: imagetrain
spec:
  containers:
  - image: nginx
    name: photoview-container
```

```
$ kubectl apply -f Label/label-pod.yaml
pod/nginx-pod-a created
pod/nginx-pod-b created

$ kubectl get pod --show-labels
NAME              READY   STATUS    RESTARTS   AGE   LABELS
nginx-pod-a       1/1     Running   0          24s   app=photo-view,env=test
nginx-pod-b       1/1     Running   0          24s   app=imagetrain,env=test
```

매니페스트 파일 내부 리소스 `label` 을 수정해서 다시 `apply`,  
`imagetrain -> predictoin` 으로 수정

```
$ kubectl apply -f Label/label-pod.yaml
pod/nginx-pod-a unchanged
pod/nginx-pod-b configured

$ kubectl get pod --show-labels
NAME              READY   STATUS    RESTARTS   AGE    LABELS
nginx-pod-a       1/1     Running   0          6m3s   app=photo-view,env=test
nginx-pod-b       1/1     Running   0          6m3s   app=predictoin,env=test
```

`라벨 선택` 속성 `-l` 사용하여 라벨을 통해 생성 리소스 검색 가능  

```
$ kubectl get pod -l app=photo-view,env=test
NAME          READY   STATUS    RESTARTS   AGE
nginx-pod-a   1/1     Running   0          7m13s
```

|연산자|설명|  
|---|---|  
`key=value` | `key` 값이 `value` 일 경우  
`key!=value` | `key` 값이 `value` 아닐 경우  
`'key in (...value)'` | `key` 값이 `value` 에 포함 될경우  
`'key notin (...value)'` | `key` 값이 `value` 에 포함되지 않을 경우  
`key` | `key` 값이 존재할 경우  
`!key` | `key` 값이 존재하지 않을 경우  

> `in`, `notin` 연산은 홀따옴표로 묶어주어야 한다.  
콤마로 `AND` 연산은 사용 가능하지만 `OR` 연산은 사용 불가능하다.  

삭제명령  

```
$ kubectl delete -f Label/label-pod.yaml
pod "nginx-pod-a" deleted
pod "nginx-pod-b" deleted
```
