---
layout: post
title:  "프로세스 1"
date: 2018-11-23
author: kouzie
categories: "OperatingSystem"
tags:  KOCW, 반효경교수님, OS
cover:  "/assets/posts/instacode.png"
published: true

---
# 소개

프로세스의 개념, 프로세스의 상태(Process State), 프로세스 상태도, Process Control Block(PCB), 문맥교환(Context Switch), 프로세스를 스케줄링하기 위한 큐, Ready Queue와 다양한 Device Queue, 스케줄러(Scheduler)에 대해 간단히 설명하는 포스트입니다.

***

## 프로세스 개요

![os_3_1]({{ "/assets/OS/OS_3_1.png" | absolute_url }})
Process는 Program in Execution(실행중인 프로그램). 프로그램이 실행되면 독자적인 주소공간이 생기는데 이를 Virtual Memory라 한다. 자기만의 메모리 공간이 0부터 생기게 된다. 지금 당장 필요한 부분은 메모리(RAM)에 올라가게 되고 당장 필요하지 않은 부분은 Swap area(디스크)에 올라가게 된다.  
램의 메모리 주소는 물리적 개념이고 프로세스의 가상메모리 주소 논리적 개념으로 다른 공간이다. 같은 0번지라 해도 다른 위치의 메모리 공간이다. 따라서 이를 매칭 시키기 위해 Address translation(주소변환) 작업이 필요하다.  

프로세스 각각의 메모리 공간은 크게 3개로 나뉜다, **code, data, stack.**  
**code** 부분은 실행파일의 코드가 올라오는 부분으로 CPU가 실행하는 기계어 코드들이다.  
**data** 부분은 말 그대도 data가 저장되는데 프로그램이 실행되면서 필요한 전역변수, 배열 같은 프로그램 시작부터 끝까지 사용하는 변수들이 위치한다.  
**stack** 은 프로그램의 함수가 사용하는 생성되었다 사라지는 변수들이 저장된다.  

***

## 커널 주소 공간의 내용
![os_3_2]({{ "/assets/OS/OS_3_2.png" | absolute_url }})

운영체제 커널 또한 하나의 프로그램으로 함수구조로 되어있고 구조 또한 프로세스와 다를 것 없다.
**커널 code** 안에는 3가지를 위한 함수들이 선언되어있다. OS는 그림처럼 data 아래 부분의 하드웨어자원도 관리하지만 메모리에 올라와있는 프로세스들도 관리해야한다. 프로세스 별로 하드웨어 자원을 어느 정도 줄지 관리해야하기 때문에 **커널 data** 안에는 모든 하드웨어들을 관리하기 위한 자료구조, 모든 프로세스들을 관리하기 위한 자료구조를 가지고 있다.  
**커널 stack** 에 알아보자. 프로그램들은 실행되다 여러 이벤트가 발생하면 OS를 호출한다(IO같은 시스템콜이 대표적). OS또한 프로그램이기 때문에 함수로 이루어진다. 프로세스A에게 호출당하면 OS는 커널함수를 실행할 것이고 여러 지역 변수들을 만들 것 인데 프로세스마다 별도로 스택을 만들어 그 스택 안에 저장한다.

***

### 프로세스의 문맥(Context)

이번 포스트에서 제일 중요한 프로세스의 문맥이다(Context)  
![os_3_3]({{ "/assets/OS/OS_3_1.png" | absolute_url }})
프로그램이 처음 태어나 쭉 실행되다 사용이 끝나면 중단이 되는데 문맥이란 그 중간 어느 시점을 잘라놓고 봤을 때 이 프로그램이 무엇을 어디까지 실행 했는지 현재 어떤 상태에 있는지 나타내기 위해 사용되는 개념이다.  
즉 시간에 따라 바뀌는 프로세스의 현 상태를 문맥이라한다. 문맥을 설명하기 전에 구성부터 알아보겠다.  
위의 그림처럼 프로세스의 문맥은 3가지 정도로 구성된다.

#### 하드웨어 문맥

* CPU와 관련된 수행 상태를 나타낸다. Program Counter, 각종 레지스터(R1~Rn)

#### 프로세스의 주소공간

* 프로세스의 가상메모리, code, data, stack

#### 프로세스 관련 커널 자료구조

* Process Control Block (PCB), 프로세스의 Kernel Stack
<br>

프로세스는 실행되면 독자적인 주소공간을 만든다고 했다. 프로세스가 CPU를 잡게 되면 PC가 독자적인 주소공간 코드 어느 위치를 가리키고 있고 레지스터에 실행을 위한 값을 넣고 이 값을 ALU를 사용해 연산하고 결과를 또 레지스터에 저장하거나 메모리에 저장하거나 한다.  
이렇게 프로세스는 실행되다 CPU를 뺏기거나 넘겨줄 것이고 이 프로세스가 어느 시점까지 실행됬지를 규명하는 것이 문맥이다.  
즉 PC가 어디를 가리키고 있는가, CPU가 코드의 어느 부분까지 실행 했는가, 프로세스 stack, data영역에 어떤 내용을 담고 있는가, 만약 함수 호출이 있었다면 스택에 과거 무엇을 호출했는지 쌓여있을 것이다, 또 data부분에 있는 변수가 변했을 거다.  
그 과정에서 레지스터는 무슨 값을 가지고 있는지, 이런 실행에 필요한 모든 요소가 문맥이 되겠다.
<br>
커널도 주소공간에 Data영역과 Stack영역이 있는데 프로세스가 하나 수행될 때 마다 프로세스 제어블록(PCB)과 스택을 각각 공간에 저장한다(프로세스 관리용).  

**Process Control Block**: 커널의 프로세스 관리용 자료구조로 이 친구한테 CPU를 얼마나 할당할지, 메모리를 얼마나 줄지, 나쁜 짓을 하는 건 아닌지 관리하는 역할을 가진다. 즉 운영체제가 이 프로세스를 어떻게 평가하고 있는지, 이것도 문맥에 포함된다.  
**Kernel Stack**: 프로세스가 사용자 함수나 라이브러리 함수를 호출하고 종료하면 stack에 있던 복귀 주소 값을 사용한다. 프로세스는 원활한 주소 이동을 위해 stack을 사용한다. OS도 똑같다. 프로세스의 시스템 콜을 통해 커널이 CPU제어권을 갖게 된다면 PC(레지스터)는 커널 주소공간의 code영역의 어느 부분을 가리킬 것이다. 이 code영역은 여러 프로세스가 공유하며 프로세스들이 원활하게 커널코드를 실행하기 위해 각 프로세스마다 어느 커널 코드까지 실행했는지를 별도로 스택을 만들어 저장해두고 있다. 즉 프로세스도 커널코드를 사용할 일이 있고 어디까지 실행되었는지 OS가 저장해둔다.  

프로세스 혼자 알아서 실행된다면 알 필요 없지만 현대에는 Time Sharing, Multitasking과 같은 서비스를 요구하기 때문에 CPU를 놓쳤다 다시 잡게 될 때 어디까지 실행했는지 문맥을 저장해 놓지 않으면 처음부터 다시? 실행해야 하는 불상사가 일어날 수도 있다.

***

### 프로세스 상태(Process state)
![os_3_4]({{ "/assets/OS/OS_3_4.png" | absolute_url }})
문맥설명에 앞서 프로세스 상태부터 알아보고 가겠다. 프로세스는 3가지 상태 그리고 추가로 2가지 상태 총 5가지 상태로 나뉜다. 

**Running** - CPU를 잡고 Instruction을 수행중인 상태  
**Ready** – CPU를 기다리는 상태(여러 조건들을 모두 만족하고) => CPU만 주면 다 가능한 상태  
**Blocked(wait, sleep)** – CPU를 주어도 당장 진행 못하는 준비되지 못한 상태 (요청한 I/O작업이 아직 다 수행 안 되었다던가, 공유데이터를 이미 다른 프로세스가 쓰고 있다던가 등) 즉 프로세스 자신이 요청한 Event가 만족되지 않아 CPU를 줘도 진행할수 없어 기다리는 상태  
위 3가지가 주된 상태, 경우에 따라서 밑에 이 2개의 상태가 더 있긴 한데 매우 짧은 순간에 이 상태에 머물러 있는다.
**New** – 프로세스가 생성중인 상태  
**Terminated** – 프로세스가 수행(Execution)이 끝난 상태(약간 정리가 필요한)  

![os_3_5]({{ "/assets/OS/OS_3_5.png" | absolute_url }})
running에서 다른 상태로 가는 화살표가 3개이다. 프로세스가 종료될 때 **terminated상태** 로, Timer interrupt 로 인해 **ready상태**, 프로세스가 Disk의 Data가 필요하게 되었을 경우 IO event로 인해 **wating상태**.  
이 순간 Disk I/O Queue의 맨 뒤로가 기다리게 된다. 디스크 컨트롤러의 지휘 하에 차례대로 수행하고 완료되면 CPU에 인터럽트를 걸고, CPU는 제어권을 커널로 넘기고 커널은 I/O를 요청했던 프로세스 상태를 바꾸고 프로세스 A가 요청했던 데이터도 디스크 로컬버퍼에서 메모리로 넘겨주는 등 CPU를 얻을 수 있는 자격을 갖추게 한다.  
그림에는 각 장치마다 큐를 만들어 놨지만 사실 커널 Data안에 있는 자료구조일 뿐이다.

***

### PCB
프로세스 상태를 저장하는 PCB 자세히 알아보자 (커널의 data 공간에 프로세스마다 있다)!
![os_3_6]({{ "/assets/OS/OS_3_6.png" | absolute_url }})
사진과 같이 크게 4가지로 구분하였다.  
1. OS가 관리상 사용하는 정보
  1-1 Process state(ready, running, waiting, new, terminated)
  1-2 Process ID, Priority(그림엔 없지만 우선순위 정보)
  그림에서야 큐를 사용해 먼저 온 순서대로 처리한 것 같지만 사실 우선순위를 따져 새치기? 같은걸 허용한다.
  1-3 Pointer(다음PCB를 가리키는 포인터, 밑의 프로세스 스케줄링에 나옴)
  <br>
2. CPU 수행관련 하드웨어 값
  Program Counter(어디까지 실행했는지 알기 위해 문맥을 위해 저장함)
  Register(문맥 저장용으로 실제 CPU의 레지스터가 가졌던 값을 커널의 data공간 PCB에도 저장함)
  <br>
3. 메모리 관련
  Code, Data, Stack 메모리 위치정보(물리메모리에 있는 실제 위치)
  <br>
4. 파일관련
   Open File Descripter(사용하고 있는 파일들이 어떤 건지))

***

### 문맥교환(Context Switch)
![os_3_7]({{ "/assets/OS/OS_3_7.png" | absolute_url }})
CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정이 문맥교환이다.  
CPU가 다른 프로세스에게 넘어갈 때 운영체제는 아래 내용을 수행 한다.
1. CPU를 내어주는 프로세스A의 상태를 프로세스A의 PCB에 저장.
2. CPU를 새롭게 얻는 프로세스B의 상태를 PCB에서 CPU로 읽어옴.

프로세스는 CPU를 짧은 시간으로 얻었다, 뺐기다를 반복한다. CPU를 다시 얻어 시작할 때 처음부터가 아닌 저장해 놨던 문맥을 통해 실행했던 곳부터 시작하는 메커니즘이 있다. 즉 문맥교환은 사용자 프로세스 에서 사용자 프로세스로 넘어가는 과정이다.  

프로세스A가 인터럽트나 시스템콜이나 어떤 이유에서든지 CPU를 빼앗기게 된다면 CPU에 있는 내용을 그냥 지워버리는 게 아니라 다음 번의 실행을 위해 PC, 레지스터 값, Memory Map(메모리 위치정보)을 프로세스의 PCB에 저장해 놓는다. 그리고 이번에 CPU를 얻게 된 프로세스도 커널이 제어를 넘겨줄 때 CPU레지스터에 PCB에 있던 값을 복원시킨다.  

그렇다면 System Call, Interrupt 발생시 무조건 문맥교환이 발생할까?  
![os_3_8]({{ "/assets/OS/OS_3_8.png" | absolute_url }})
**(1)상황** 은 문맥교환이 아니다. 1번째 그림은 하드웨어 인터럽트나 시스템콜이 발생한 경우이다. 사용자가 키보드를 쳤다던가 SW적으로 문제가 생겼다던가, 인터럽트 코드가 끝나면 다시 프로세스A에게 CPU제어권이 돌아간다.  
하지만 **(2)상황** 처럼 타이머 인터럽트, 또는 오래 걸리는 작업(System Call)을 요청해 커널이 처리 이후 다른 프로세스에게 제어권이 넘어간다면 이건 문맥교환이라 할 수 있다.  

사실 1번의 경우에도 문맥교환은 아니지만 사용자의 코드에서 커널 코드로 넘어가는 것이기 때문에 약간의 문맥 일부를 PCB에 저장해야 한다. 하지만 2번 경우에 비해 오버헤드(소모)가 훨씬 적다. 예를 들어 2번 경우에는 Cash Memory까지 싹 비워줘야 하는(Cache Memory Flush) 반면 1번 경우는 그러지 않아도 된다.

***

### 프로세스를 스케줄링하기 위한 큐

운영체제는 프로세스들을 다 큐에 넣고 관리한다. 큐의 종류를 알아보겠다.  
![os_3_9]({{ "/assets/OS/OS_3_9.png" | absolute_url }})
**Job Queue** – 현재 시스템 내에 있는 모든 프로세스의 집합  
**Ready Queue** – 현재 메모리 내에 있으면서 CPU를 잡아 실행되길 기다리는 프로세스의 집합  
**Device Queue** – I/O Device의 처리를 기다리는 프로세스의 집합(각종 디스크, 테이프).
**Ready Queue** 에는 당장 CPU를 쓸 수 있는 PCB 7, PCB 2가 있다. disk, terminal 작업을 기다리는 큐도 PCB들이 linked 되어있다.  
그림을 보면 알겠지만 실제 프로세스를 줄 세우는게 아니라 PCB(커널에 저장된)를 줄 세워 순서를 정한다. 전에 PCB그림에 Pointer변수가 있던 걸 봤는데 가리키는건 자기 뒤에 오는 PCB주소이다.  

**스케줄링은 다른 방식으로 표현한 그림**
![os_3_10]({{ "/assets/OS/OS_3_10.png" | absolute_url }})
4가지 이벤트(I/O, timer, fork, interrupt)가 들어오면 cpu제어권을 다른 프로세스에게 넘겨주고 ready큐에 들어가서 순환되는 그림이다.

***

### 스케줄러(Scheduler)

스케줄러는 시간정하고 순서정하는 것이다. OS에서 스케줄링을 하는 코드이다.

#### Short-Term Scheduler (단기 스케줄러 = CPU Scheduler)
평소 우리가 알던 스케줄러, 타이머 인터럽트가 일어나면 어느 프로세스에게 CPU를 줄지.  
- 어떤 프로세스를 다음번에 Running시킬지 결정  
- 프로세스에게 CPU를 주는 문제  
- 충분히 빨라야 함(Millisecond단위)  


<br>
#### Long-Term Scheduler (장기 스케줄러 = 메모리 스케줄러 =Job Scheduler)
- 시작 프로세스 중(New상태) 어떤 것들을 Ready Queue(메모리)로 보낼지 결정 (5page 그림참조)
- 프로세스에Memory를 주는 문제  
- Degree Of Multiprogramming을 제어(메모리에 올라가있는 프로세스 수, 메모리에 올라와있는 프로세스의 수를 제어)  
현대 대부분 OS는 Time Sharing System인데 보통 장기 스케줄러가 없다. 바로 메모리로 진입해서 바로 Ready상태로 시작하고 new 상태는 없다. 장기 스케줄러는 구시대 기술이다.
그래도 Degree Of Multiprogramming(프로세스 수 제어)는 요즘 컴퓨터에도 필요하다.
이를 중기스케줄러를 통해 프로세스 수를 제어한다. 메모리에 올라와있는 프로세스 수는 너무 많아도 적어도 안 된다. 메모리에 프로그램이 적으면 CPU가 노는 상황이, 많으면 메모리 부족으로 당장 쓸 것 도 메모리에 못 올라오는 상황이 발생한다.  
<br>

#### Medium-Term Scheduler(중기 스케줄러 = Swapper)
- 만약 메모리에 너무 많은 프로세스가 올라가 있으면 일부를 골라 메모리에서 디스크로 쫓아냄  
- Degree Of Multiprogramming을 제어  
- 프로세스에게서 Memory를 뺏는 문제  
어떻게 보면 중기스케줄러는 뺏기만 하니 나쁜 놈? 하지만 효율은 좋다고 볼 수 있다.
그런데 메모리를 통째로 빼앗긴 프로세스는 무슨 상태일까? Running? Ready? Blocked?
바로 Suspended상태가 된다(Block은 자진 납부상태로 Event를 스스로 기다림). Suspended는 외부적인 이유로 프로세스 수행이 정지된 상태(중기스케줄러가 메모리를 뺏거나 사용자가 강제 정지), Suspended 프로세스는 통째로 디스크에 Swap Out된다.
Blocked는 자신이 요청한 Event가 만족되면 Ready상태로 바뀌며 실적적으로 I/O에서 일중이고 실행중인 프로세스이다.
Suspended는 정지된 상태, 중기 스케줄러 혹은 사용자가 Resume해줘야 실행상태로 바뀐다.
<br>

#### Suspended가 추가된 프로세스 상태도
![os_3_11]({{ "/assets/OS/OS_3_10.png" | absolute_url }})
다시 말하지만 Blocked 상태는 정지상태(Inactive)가 아니다. CPU를 사용 못할 뿐이지 I/O작업은 계속 수행중이다. 아래를 보면 Suspended 상태가 2가지다. Blocked 상태에서 Suspended되었냐 Ready상태에서 Suspended되었냐 차이이다.  
Suspended 상태가 다시 active모드가 되려면  중기스케줄러나 사용자가 메모리를 뺏어서 Inactive가 되었듯이 외부에서 다시 메모리를 주어야 한다.
Suspended Blocked에서 Suspended Ready로 가는 화살표(WakeUp)이 있는데 이는 프로세스가 I/O작업 도중에 중지 된 상태, 즉 Blocked상태에서 Suspended Blocked상태로 된 후 I/O작업을 끝마쳤을 때 Suspended Blocked에서 Suspended Ready로 바뀐 것이다. Suspended상태에서도 I/O작업은 할 수 있다.  
만약 프로세스가 User Mode에서 실행중이다 커널코드가 필요해서 OS에게 CPU제어권을 넘기면 이 프로세스의 상태는 Running일까 Blocked일까? 헷갈릴 수 있은데 Running이다. 위 그림에도 이러한 점 때문에 Running상태를 2가지로 나뉘어 표현하였다. 즉 커널모드에서 Running이라 보면 된다.  
또 하나 예를 들어보자. 만약 프로세스A가 CPU를 잡고 실행중인데 Disk Controller에서 Interrupt가 들어왔다. 그럼 CPU제어권은 OS에게 넘어갈 것인데 프로세스A의 상태는 무슨 상태 일까? 이것도 Running이다. 프로세스A와 상관없는 일로 CPU제어권이 넘어갔고 인터럽트 수행 후 제어권은 다시 프로세스A에게 넘어올 것이기 때문에 Running으로 간주한다.  
그리고 Running(monitor mode)에 제자리 화살표가 있는데 이는 인터럽트 도중에 또 인터럽트가 들어왔을 때를 의미한다.u