---
title:  "python 기본문법!"

read_time: false
share: false
author_profile: false
# # classes: wide

categories:
  - python
  - fast api

toc: true
toc_sticky: true

---

## 자료형  

파이썬의 특이한 자료형에 대해 알아본다.  

### 문자열 


```py
a = 'python'
# 문자열 연산
a * 2 # pythonpython
"=" * 50 # ==================================================
'hi' + 3 # TypeError: can only concatenate str (not "int") to str > 오히려 될것 같은건 안됨 

# 문자열 인덱스
a[3] # 'h'
a[-2] # 'o' 뒤에서 2번째

# 문자열 슬라이스
a[0:3] # 'pyt' 
a[:3] # 'pyt' default start 0
a[3:] # 'hon' defatlt end EOL
a[1:-1] # 'ytho'

# 문자열 포멧팅  
"hello %s" % "wolrd" # 'hello wolrd'
"hello %02d" % 3 # 'hello 03'
"hello {0}".format("world") # 'hello world'
"my name is {name} and {age} age".format(name="kouzie", age=20) # 'my name is kouzie and 20 age'

```

### 리스트

```py
# 리스트 연산
a = [1,2,3]
b = [4,5,6]
a+b # [1, 2, 3, 4, 5, 6]
a*2 # [1, 2, 3, 1, 2, 3]
a.extend(a) # [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]

# 요소 추가
a = [1,2,3]
a.append(4) # [1, 2, 3, 4]
a.insert(0,5) # [5, 1, 2, 3, 4] (index, value)

# 요소 삭제
b = [4,5,6,7]
b.remove(5) # [4, 6, 7] (index)
del b[2:] # [4, 6]
c = b.pop() # c=6 b=[4]

# 요소 정렬
a = [2,3,1,4]
a.sort() # [1, 2, 3, 4]
b = ['b','c','a','d']
b.sort() # ['a', 'b', 'c', 'd']
b.reverse() # ['d', 'c', 'b', 'a']

# 요소 탐색
b = ['a', 'b', 'c', 'd', 'c']
b.index('c') # 2, first index
b.count('c') # 2, 개수
```

### 딕셔너리

```py
# 추가
a = {"hi": "hello"}
a["who"] = "me" # {'hi': 'hello', 'who': 'me'}

# 삭제
del a['hi'] # {'who': 'me'}
a.clear() # { } 초기화

# 조회
a = {'hi': 'hello', 'who': 'me'}
a.keys() # dict_keys(['hi', 'who'])
a.values() #dict_values(['hello', 'me'])
a.items() # dict_items([('hi', 'hello'), ('who', 'me')])
list(a.keys()) # ['hi', 'who'] # 리스트로 변환
list(a.values()) # ['hello', 'me'] 
list(a.items()) # [('hi', 'hello'), ('who', 'me')] # 튜플에 대한 리스트
items = a.items()[0][0] # 'hi'
```

### tuple, set

`list` 와 비슷한 형태의 자료형이지만

`tuple` 은 초기화 이후 요소의 변경이 불가능 `()` 기호를 사용해 생성한다.  
`set` 은 순서없고 중복 불가능한 집합 자료형, `{}` 기호를 사용해 생성한다.  

```py
t = (1,2,3)
s = {1,2,3}

# list to tuple, set
t = tuple([1,2,3])
s = set([1,2,3])

# set 연산
s1 = {1,2,3,4}
s2 = {3,4,5,6}
s1 & s2 # {3, 4} 교집합
s1 | s2 # {1, 2, 3, 4, 5, 6} 합집합
s1 - s2 # {1, 2} 차집합

# set 요소 추가
s1 = {1,2,3,4}
s1.add(5) # {1, 2, 3, 4, 5}
s1.update([6,7,8]) # {1, 2, 3, 4, 5, 6, 7, 8}

# set 요소 삭제
s1.remove(3) # (index)
s1.pop()
```

### bool

![1](/assets/python/python1.png)

## 제어문


### if & 조건문

```py
x = True
y = False
if x:
  print("hi")
elif y:
  print("hello")
else:
  print("world")
```

`bool` 자료형 끼리는 `and`, `or`, `not`

```py
x and y # False
x or y # True
not y # True
```

리스트, 튜플을 검사할 땐 `in`, `not in`

```py
1 in [1,2,3] True
1 not in [2,3,4] True
```

### while 

```py
while x:
  if y:
    break
  if z:
    continue
```

> 파이썬에는 do while 이 없음  

### for

```py
test_list = ['one', 'two', 'three']
for i in test_list:
  print(i)
# one
# two
# three

for (k, v) in a.items():
  print("key:%s, value:%s" % (k, v))
# key:hi, value:hello
# key:who, value:me

# List comprehension 한줄처리, 
#[(표현식) for (항목1) in (리스트) if (조건문)]
# 최좌측의 요소가 배열안으로 들어감
[i for i in range(0,10)]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[i*2 for i in range(0,9) if i%2==0]
[0, 4, 8, 12, 16]
```

`in` 연산자를 통해 요소를 꺼내 반복문 실행  


## 함수

```py
def add(a=1, b=1):
  return a + b

def add_all(*args):
  result = 0
  for i in args:
    result += i
  return result


add() # 2
add(b=2,a=5) # 7
add_all(1,2,3,4)  # 10

```

python 은 별도의 반환값, 매개변수의 인자값 등을 명시하지 안하도 된다.  

### lamdba

```
lambda [arg1, arg2, ...] : 표현식 
```

```py
add = lambda a, b: a+b
add(1,2) # 3
```

## 클래스  

클래스 정의 구문은 아래와 같다.  

```py
class Calculator:
  def __init__(self):
    self.result = 0

  def add(self, num1, num2): 
    self.result = self.result + num1 + num2
    return self.result

c1 = Calculator()
c1.add(1, 2) # 3 
c1.add(3, 4) # 10
c1.result # 10
Calculator.add(c1, 5, 6) # 21
```

`default` 에 숫자를 중첩해서 저장 후 반환  
`self` 키워드를 사용하고 싶다면 항상 클래스 함수 첫 인자로 지정  

`self` 를 생략하려면 인스턴스에서 메서드를 호출  
클래스를 통해 메서드를 직접 호출면 지정해야함  


**클래스변수**, **생성자**, **메서드오러바라이딩** 방식은 아래와 같다.  

> 클래스변수는 모든 인스턴스, 클래스 가 공유하는 전역변수

```py
class Car:
  # 클래스변수
  brand = 'hyundai'

  # 셍성자
  def __init__(self, name):
    self.name = name

  def print_name(self):
    print(self.name)

print(Car.brand) # hyundai
c1 = Car('sonata')
c1.print_name()
# c2 = Car()
# TypeError: Car.__init__() missing 1 required positional argument: 'name'

class Truck(Car):
  def __init__(self, name, size):
    super().__init__(name)
    self.size = size

  # 메서드오버라이딩
  def print_name(self):
    print("truck name:", self.name)

  def print_size(self):
    print(self.size)

Truck.brand = 'kia'
print(Truck.brand) # kia
t1 = Truck('bongo', 10)
t1.print_name() # truck name: bongo
t1.print_size() # 10
# c2 = Car() 
```

## 모듈

모든 `.py` 확장자의 파일은 모듈로서 동작 가능  

`mod1.py` 파일을 정의하고
 

```py
# mod1.py
def add(a=1, b=1):
  return a + b

def add_all(*args):
  result = 0
  for i in args:
    result += i
  return result

if __name__ == "__main__":
  print("hello world")

```

> 커맨드창에서 바로 `mod1.py` 를 실행하면 `__name__` 전역변수가 `__main__` 으로 처리되어 조건문 내부 코드가 실행됨   

타 파일에서 `import`, `from` 을 통해 파일 내부에 함수, 클래스 정의를 땡겨올 수 있다. 

```py
# test.py
import mod1
from mod1 import add_all

print(mod1.add(1,2)) # 3
print(add_all(1,2,3)) # 6
```

> 가져오고 싶은 함수, 클래스를 콤마(`,`) 로 이어 모두 가져오거나  아스타리스크(`*`)를 통해 전부 가져올 수 있다.  

### 모듈 경로  

모듈이 같은레벨 경로에 있으면 `.py` 파일명만 써도 `import` 가능하지만 하위 디렉토리에 저장되어 있다면 `디렉토리명.파일명` 형식으로 경로를 지정해줘야 한다.  

**내장함수**  
별다른 경로 설정없이 사용할 수 있는 함수는 이미 `sys` 경로에 지정되어 있기에 바로 쓸 수 있는것  
아래 `sys` 모듈을 통해 경로를 확인 가능  

```py
import sys
sys.path 
# ['', 'C:\\Windows\\SYSTEM32\\python37.zip', 'c:\\Python37\\DLLs', 'c:\\Python37\\lib', 'c:\\Python37', 'c:\\Python37\\lib\\site-packages']
```

해당 `sys.path` 에 디렉토리경로를 지정하면 직접 작성한 모듈도 바로 `import` 가능하다.  

### 패키지  

디렉토리 만들고 내부에 `__init__.py` 파일 만들고  
내부에 모듈로서 동작할 각종 `.py` 파일을 만들면 그게 패키지다.  

패키지를 `import` 함으로 내부에 정의된 많은 `.py` 파일의 함수들은 사용 가능하다.  

아래와 같이 game 디렉토리가 구성되어 있을 때  

```
$ tree game
.
├── __init__.py
├── graphic
│   ├── __init__.py
│   └── render.py
└── sound
    ├── __init__.py
    └── echo.py
```

```py
# game/sound/echo.py
def echo_test1():
    print('echo1')

def echo_test2():
    print('echo2')

def echo_test3():
    print('echo3')

```

다양한 방식으로 정의된 함수, 클래스를 가져올 수 있다.  

- 패키지 import  
- 모듈 import  
- 모듈 내부의 함수 import  

```py
# test.py
import game.sound.echo
from game.sound import echo
from game.sound.echo import echo_test3

game.sound.echo.echo_test1()
echo.echo_test2()
echo_test3()
```

**`__init__.py`**
해당 디렉토리가 패키지에 포함되는 것음 의미  
`__all__` 변수를 지정함으로 아스타리스크(`*`) 을 통해 `import` 할 모듈을 직접 지정 할 수 있다.  


```py
# __init__.py
__all__ = ['echo']
```

`from game.sound import *` 형식으로 모듈을 가져오도록 지정할 때 `__init__.py` 의 `__all__` 변수에 `echo` 모듈이 지정되어 있음으로 사용 가능하다.  

한 뿌리의 패키지에 포함되어 있다면 **relative 경로** (`..`) 를 통해 `depth` 를 이동하거나 
한 뿌리의 패키지라면 상위 디렉토리의 이름을 지정하여 패키지의 `depth` 이동이 가능하다.  

