---
title:  "Spring - 스프링 트랜잭션!"

read_time: false
share: false
author_profile: false
classes: wide

categories:
  - Spring

tags:
  - Spring
  - java

toc: true

---

## 스프링 트랜잭션

**논리적인 하나의 작업단위가 트랜잭션**이다.  

예를 들어 `계좌 이체`라는 하나의 논리적인 작업은 총 2가지 행위로 이루어진다.  
송금하는 쪽에서 출금 행위, 수신받는 쪽에선 입금 행위가 일어난다.  

이 계좌이체라는 논리적 작업에서 출금만 성공하고 입금은 실패한다면 돈이 사라지는 일이 발생한다.  
즉 계좌이체는 하나라도 실패하면 모든 행위가 실패하던가, 성공해야만 하는 하나의 작업단위(트랜잭션)이다.

DB와 연동과정에서 생기는 트랜잭션 처리는 대부분 비슷한 패턴을 가진다.

커넥션 객체를 열어 각종 sql쿼리를 수행하고 만들어진 `Resultset`, `PreparedStatement` 등의 DB관련 객체를 `close`했다.  
이 일련의 과정을 `try,catch` 문으로 둘려있고 만약 이 `try` 블록에서 예외가 발생한다면 `catch`문에서 `rollback`하는 과정을 거친다.  

이러한 과정이 계속 반복되기 때문에 스프링에서 이를 생략할 수 있는 트랜잭션 템플릿 클래스 등을 제공한다.  

`TransactionManager`클래스가 기본적으로 필요


### JDBC 기반 트랜잭션 관리자 - `DataSourceTransactionManager`

지금까지 스프링에서 DB연동은 스프링에서 제공하는 JDBC템플릿 클래스를 이용해 해왔다.   

JDBC템플릿 클래스를 이용해 DB연동시, **트랜잭션 처리할 때 사용하는 템플릿 클래스**는 `DataSourceTransactionManager`.  

![image8]({{ "/assets/Spring/image8.png" | absolute_url }}){: .shadow}  

이 외에도 DB연동 방식에 따라 다양한 트랜잭션 템플릿 클래스를 제공한다.  

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:context="http://www.springframework.org/schema/context"
xsi:schemaLocation="
http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context-3.0.xsd">


   <bean id="dataSource" class="org.apache.tomcat.dbcp.dbcp2.BasicDataSource">
     <property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"></property>
     <property name="url" value="jdbc:oracle:thin:@172.17.107.68:1521:xe"></property>
     <property name="username" value="scott"></property>
     <property name="password" value="tiger"></property>
   </bean>		
 
   <bean id="jdbcTemplate" class="org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate">
     <constructor-arg ref="dataSource"></constructor-arg>  
   </bean>
   
   <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
   	<property name="dataSource" ref="dataSource"/>
   </bean>
</beans>
```
`DataSourceTransactionManager` 빈 객체를 생성하고 사용하기 위해선 `DataSource` 객체를 의존설정 해야 한다.  


> `BasicDataSource`: 지금까지 `DriverManagerDataSource`를 통해 `dataSource` 빈 객체를 생성했는데 사실 `DriverManagerDataSource`은 커넥션 풀이 아니라 테스트 용도로 `Connection`객체를 만들어 주는 것이기 때문에 성능이 않좋다. `BasicDataSource`는 커넥션 풀


### DataSourceTransactionManager


위에서 빈 객체로 생성한 `transactionManager`를 사용해 실제 트랜잭션에서 예외가 발생하면 롤백이 되는지 알아보자.  
```xml
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
  <property name="dataSource" ref="dataSource"/>
</bean>
```

```java
public class NoticeDao implements NoticeDao{
  ...
  @Autowired
  private DataSourceTransactionManager transactionMenager;
  public void setTransactionMenager(DataSourceTransactionManager transactionMenager) {
    this.transactionMenager = transactionMenager;
  }
  ...
}
```

강제로 예외를 발생시키기 위해 멤버 테이블에 다음 제약조건을 추가하자.  

```sql
ALTER TABLE member
ADD CONSTRAINT ch_member_point CHECK (Point < 3);
--포인트가 3 이상 넘어가면 오류 발생
```
만약 member의 포인트 칼럼이 3이상으로 넘어가면 예외를 발생시킨다  

그리고 글쓰기 할 때 마다 `newlec`이란 이름의 사용자 Point를 1씩 증가시키자.  

이제 insert메서드를 다음과 같이 변경시켜 공지사항을 INSERT하고 UPDATE를 통해 `newlec`사용자 Point를 증가시키자.  

`transactionMenager` 빈 객체를 생성할 때 DB연결 객체인 `DataSource`를 사용했기 때문에 autocommit되지 않는상태이다.  

```java	 
@Override
public int insertAndPointUpOfMember(Notice notice, String id) throws ClassNotFoundException, SQLException {
  //게시글 작성
  StringBuffer sql = new StringBuffer();
  sql.append(" INSERT INTO NOTICES(SEQ, TITLE, CONTENT, WRITER, REGDATE, HIT, FILESRC) VALUES( ");
  sql.append(" (SELECT NVL(MAX(TO_NUMBER(SEQ)), 0) + 1 FROM NOTICES) ");
  sql.append(" :title, :content, 'newlec', SYSDATE, 0, :filesrc) ");
  //포인트증가
  String sqlPoint = "UPDATE member SET point = point + 1 WHERE id = :id";
  TransactionDefinition def = new DefaultTransactionDefinition();
  TransactionStatus status = this.transactionMenager.getTransaction(def);
  try {
    SqlParameterSource paramSource = new BeanPropertySqlParameterSource(notice);
    this.jdbcTemplate.update(sql, paramSource);
    
    MapSqlParameterSource paramMap = new MapSqlParameterSource();
    paramMap.addValue("id", id);
    this.jdbcTemplate.update(sqlPoint, paramMap);
    //commit
    this.transactionMenager.commit(status);
  }
  catch (DataAccessException e) { //DataAccessException가 발생
    //rollback
    this.transactionMenager.rollback(status);
    throw e;
  }
  return 0;	
}
```

그리고 글쓰기를 통해 `newlec`사용자의 `Point`를 증가시켜가면 오류가 발생하면서 `UPDATE`쿼리가 실패하고 `INSERT`되었던 `notice`테이블의 데이터도 `rollback`된다.  

`TransactionMenager` 객체의 `commit()`, `rollback()` 메서드를 사용해 트랜잭션 처리를 하는데 `try, catch` 블록도 생략되지 않고 오히려 `TransactionDefinition`, `TransactionStatus` 등의 객체가 별도로 필요하기 때문에 더 복잡하다...


`TransactionMenager`는 트랜잭션 템플릿 클래스를 만들기 위한 DI용으로 사용되는 객체로 실제 트랜잭션 처리할 때 잘 사용하지 않는다.  

그럼 `TransactionTemplate`사용해서 트랜잭션 처리를 해보자.


먼저 `Dispatcher` 설정 xml파일에 `TransactionTemplate` 빈 객체를 생성하는 코드를 추가  

```xml
<!-- dispatcher-servlet.xml -->
...
<bean id="transactionTemplate" class="org.springframework.transaction.support.TransactionTemplate">
  <property name="transactionManager" ref="transactionManager"/>
</bean>
...
```
`transactionTemplate` 빈 객체를 만들기 위해 `transactionManager` 빈 객체가 주입되어야 한다.  
(결국 `transactionTemplate`도 내부적으론 `transactionManager`을 사용함)

그리고 `@Autowired` 어노테이션을 사용해 `TransactionTemplate`객체를 자동으로 주입!  
```java
public class NoticeDao implements NoticeDao{
  ...
  // @Autowired
  // private DataSourceTransactionManager transactionMenager;
  // public void setTransactionMenager(DataSourceTransactionManager transactionMenager) {
  //   this.transactionMenager = transactionMenager;
  // }
  @Autowired
	private TransactionTemplate transactionTemplate;
	public void setTransactionTemplate(TransactionTemplate transactionTemplate) {
		this.transactionTemplate = transactionTemplate;
	}
  ...
}
```

그리고 `transactionTemplate`객체의 `excute()`메서드 안에서 반환값이 없다면 `TransactionCallbackWithoutResult`, 반환값이 있다면 `TransactionCallback`을 사용해 쿼리를 수행한다.  

```java
@Override
public int insertAndPointUpOfMember(Notice notice, String id) throws ClassNotFoundException, SQLException {
  StringBuffer sql = new StringBuffer();
  sql.append(" INSERT INTO NOTICES(SEQ, TITLE, CONTENT, WRITER, REGDATE, HIT, FILESRC) VALUES( ");
  sql.append(" (SELECT NVL(MAX(TO_NUMBER(SEQ)), 0) + 1 FROM NOTICES) ");
  sql.append(" :title, :content, 'newlec', SYSDATE, 0, :filesrc) ");
  //포인트증가
  String sqlPoint = "UPDATE member SET point = point + 1 WHERE id = :id";
  this.transactionTemplate.execute(new TransactionCallbackWithoutResult() {
    
    @Override
    protected void doInTransactionWithoutResult(TransactionStatus status) {
      SqlParameterSource paramSource = new BeanPropertySqlParameterSource(notice);
      jdbcTemplate.update(sql, paramSource);

      MapSqlParameterSource paramMap = new MapSqlParameterSource();
      paramMap.addValue("id", id);
      jdbcTemplate.update(sqlPoint, paramMap);
    }
  });
  return 0;	
}
```

코드를 보면 `TransactionCallbackWithoutResult`의 익명 인스턴스를 사용해 `doInTransactionWithoutResult()` 메서드를 오버라이딩 한다.  

`TransactionCallback`의 경우 `doInTransaction()` 메서드를 오버라이딩 하면 된다.  
```java
public Object someServiceMethod() {
  return transactionTemplate.execute(new TransactionCallback() {

    public Object doInTransaction(TransactionStatus status) {
      updateOperation1();
      return resultOfUpdateOperation2();
    }
  });
}
```
확실히 `TransactionTemplate`을 사용하니 `transactionManager`만 사용할 때 보단 훨씬 간결해졌다.  

### tx 네임스페이스를 이용한 트랜잭션 설정 - 선언적 트랜잭션 처리

사실 `TransactionTemplate`도 잘 사용안하고 **xml에 트랜잭션 설정을 통해 트랜잭션 처리**한다.  

먼저 xml로 설정을 살펴보자.  

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context"
  xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop"
  xsi:schemaLocation="
http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context-3.0.xsd
http://www.springframework.org/schema/tx
http://www.springframework.org/schema/tx/spring-tx.xsd
http://www.springframework.org/schema/aop
http://www.springframework.org/schema/aop/spring-aop.xsd">

  <context:component-scan base-package="controllers, newlecture.dao" />

  <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"/>
  </bean>

  <tx:advice id="txAdvice" transaction-manager="transactionManager">
    <tx:attributes>
      <tx:method name="insert*" propagation="REQUIRED" />
    </tx:attributes>
  </tx:advice>

  <aop:config>
    <aop:pointcut expression="execution( * newlecture.dao..*.*(..) )" id="firstTransactionMethod" />
    <aop:advisor advice-ref="txAdvice" pointcut-ref="firstTransactionMethod" />
  </aop:config>
</beans>
```

새로 등장한 `tx`네임스페이스, 그리고 `aop`네임스페이스를 사용해 트랜잭션 설정이 가능하다.  
(`tx`네임스페이스를 위해 `beans`태그에 설정추가 필요)  

`tx:advice`와 `aop:config` 태그를 보면 알겠지만 `tx`네임스페이스를 사용해 트랜잭션 처리가 된 `proxy`객체를 만들어 처리하는 구조이다.   
> https://kouzie.github.io/spring/Spring-DI-자동-연결,-스프링-AOP-개요,-스프링-생명주기/#spring-aop

`<tx:method name="insert*" propagation="REQUIRED" />` 태그를 보면 `name`에 해당하는 메소드들을 모두 트랜잭션 처리한다.  
> `propagation="REQUIRED"`는 밑의 전파, 격리에서 설명.  

요약하면 트랜잭션 처리하는 공통기능을 `execution( * newlecture.dao..*.*(..) )`을 통해 찾은 클래스들의 `insert*` 메서드들에 추가한다는 뜻이다.  

`tx`네임스페이스를 통해 트랜잭션 설정과 `aop:config`을 통해 AOP설정까지 끝내면 트랜잭션 처리 끝이다.  

```java
@Override
public int insertAndPointUpOfMember(Notice notice, String id) throws ClassNotFoundException, SQLException {
  StringBuffer sql = new StringBuffer();
  sql.append(" INSERT INTO NOTICES(SEQ, TITLE, CONTENT, WRITER, REGDATE, HIT, FILESRC) VALUES( ");
  sql.append(" (SELECT NVL(MAX(TO_NUMBER(SEQ)), 0) + 1 FROM NOTICES) ");
  sql.append(" :title, :content, 'newlec', SYSDATE, 0, :filesrc) ");
  //포인트증가
  String sqlPoint = "UPDATE member SET point = point + 1 WHERE id = :id";
  SqlParameterSource paramSource = new BeanPropertySqlParameterSource(notice);
  this.jdbcTemplate.update(sql, paramSource);
  MapSqlParameterSource paramMap = new MapSqlParameterSource();
  paramMap.addValue("id", id);
  this.jdbcTemplate.update(sqlPoint, paramMap);
  return 0;	
}
```
아무런 트랜잭션 설정(`TransactionTemplate`)이 보이지 않지만 xml에 설정한 `<tx:advice>`태그와 `<aop:config>`태그 설정에 포함된다면 자동으로 트랜잭션 처리 된거다.  

`TransactionTemplate`로 일일이 메서드 돌아다니며 `execute()` 메서드와 `TransactionCallback`같은 익명 클래스를 만들지 않아도 되서 훨씬 편하다.  

### @Transactional 어노테이션을 이용한 트랜잭션 설정 - 선언적 트랜잭션 처리2

xml로 설정 가능하지만 `@Transactional`을 사용해 똑같은 역할을 할 수 있다.  

```java
@Override
@Transactional
public int insertAndPointUpOfMember(Notice notice, String id) throws ClassNotFoundException, SQLException {
  StringBuffer sql = new StringBuffer();
  sql.append(" INSERT INTO NOTICES(SEQ, TITLE, CONTENT, WRITER, REGDATE, HIT, FILESRC) VALUES( ");
  sql.append(" (SELECT NVL(MAX(TO_NUMBER(SEQ)), 0) + 1 FROM NOTICES) ");
  sql.append(" :title, :content, 'newlec', SYSDATE, 0, :filesrc) ");
  String sqlPoint = "UPDATE member SET point = point + 1 WHERE id = :id";

  SqlParameterSource paramSource = new BeanPropertySqlParameterSource(notice);
  this.jdbcTemplate.update(sql, paramSource);
  MapSqlParameterSource paramMap = new MapSqlParameterSource();
  paramMap.addValue("id", id);
  this.jdbcTemplate.update(sqlPoint, paramMap);
  return 0;
}
```

`@Transactional`어노테이션을 하나 추가하기만 하면 된다.  


## 트랜잭션 전파

전파방식이란 **특정 A프랜잭션이 처리되는 과정 안에서 또다른 트랜잭션 B가 처리되는 경우** 를 뜻한다.  

즉 트랜잭션 설정된 메서드 안에서 또다른 트랜잭션 설정된 메서드가 실행될 때. 

```java
@Transactional
public int insert(...) { 
  ...
  dao.insert(...);
  ...
}
@Transactional
public int pointUp(...) { 
  ...
  dao.pointUp(...);
  ...
}

@Override
@Transactional
public void insertAndPointUpOfMember(...) {
  insert(...);
  pointUp(...);
}
```
`insertAndPointUpOfMember()`메서드 안의 `insert()`메서드는 성공하고 `pointUp()`메서드는 실패할 경우 `insert()`가 실행한 결과까지 rollback할건지 전파방식을 통해 결정할 수 있다.  


지금까지는 전파 방식 없이 default값인 `REQUIRED` 값을 사용해 왔다.  
`@Transactional` = `@Transactional(propagation=Propagation.REQUIRED)`   

전파방식에 어떤 것 들이 있는지 알아보자.  

**전파방식** | **의미**
|---|---|
`REQUIRED` | 트랜잭션 상황에서 실행되어야 한다. 진행 중인 트랜잭션이 있다면 이 트랜잭션에서 실행된다. 없는 경우에는 트랜잭션이 새로 시작된다.
`MANDATORY` | 호출 전에 반드시 진행 중인 트랜잭션이 존재해야 한다. 진행 중인 트랜잭션이 존재하지 않을 경우 예외 발생
`REQUIRED_NEW` | 자신만의 트랜잭션 상황에서 실행되어야 한다. 이미 진행 중인 트랜잭션이 있으면 그 트랜잭션은 해당 메소드가 반환되기 전에 잠시 중단된다.
`SUPPORTS` | 진행 중인 트랜잭션이 없더라도 실행 가능하고, 트랜잭션이 있는 경우에는 이 트랜잭션 상황에서 실행된다.
`NOT_SUPPORTED` | 트랜잭션이 없는 상황에서 실행 만약 진행 중인 트랜잭션이 있다면 해당 메소드가 반환되기 전까지 잠시 중단한다.
`NEVER` | 트랜잭션 진행 상황에서 실행 될 수 없다. 만약 이미 진행 중인 트랜잭션이 존재하면 예외 발생
`NESTED` | 이미 진행 중인 트랜잭션이 존재하면 중첩된 트랜잭션에서 실행되어야 함을 나타낸다. 중첩된 트랜잭션은 본 트랜잭션과 독립적으로 커밋되거나 롤백될 수 있다. 만약 본 트랜잭션이 없는 상황이라면 이는 PROPAGATION_REQUIRED와 동일하게 작동한다. 그러나 이 전파방식은 벤더 의존적이며, 지원이 안되는 경우도 많다.  


`@Transactional`의 경우 `REQUIRED`이 기본값이다.  

먼저 `REQUIRED` 속성이 어떤 역할을 하는지 알아보자.  

> 아까 설정했던 point값이 3이 상이라면 예외발생한 상태...  
```sql
ALTER TABLE member
ADD CONSTRAINT ch_member_point CHECK (Point < 3);
--포인트가 3 이상 넘어가면 오류 발생
```

```java
@Transactional(propagation=Propagation.REQUIRED)
public int insert(Notice notice, String id) throws ClassNotFoundException, SQLException { 
  StringBuffer sql = new StringBuffer();
  sql.append(" INSERT INTO NOTICES(SEQ, TITLE, CONTENT, WRITER, REGDATE, HIT, FILESRC) VALUES( ");
  sql.append(" (SELECT NVL(MAX(TO_NUMBER(SEQ)), 0) + 1 FROM NOTICES) ");
  sql.append(" :title, :content, 'newlec', SYSDATE, 0, :filesrc) ");
  //포인트증가
  String sqlPoint = "UPDATE member SET point = point + 1 WHERE id = :id";
  SqlParameterSource paramSource = new BeanPropertySqlParameterSource(notice);
  this.jdbcTemplate.update(sql, paramSource);

  MapSqlParameterSource paramMap = new MapSqlParameterSource();
  paramMap.addValue("id", "newrec");
  this.jdbcTemplate.update(sqlPoint, paramMap);
  return 0;
}

@Override
public int insertAndPointUpOfMember(Notice notice, String id) throws ClassNotFoundException, SQLException {
  insert(notice, id);
  insert(notice, id);
  return 0;
}
```

`insert()`메서드엔 트랜잭션과 `REQUIRED`설정이 적용된 상태이고  
`insertAndPointUpOfMember()`메서드엔 어떤 트랜잭션도 설정되어 있지 않다.  

REQUIRED의 경우 기존 메서드(`insertAndPointUpOfMember`)에 트랜잭션이 있다면 해당 트랜잭션을 사용하지만
기존 메서드에 트랜잭션이 없다면 **각각 새로운 트랜잭션**을 생성한다.  

즉 `insert` 하나당 하나의 트랜잭션이 생성된다.  

따라서 각각의 insert는 하나의 트랜잭션으로 인정되서 하나는 들어가고 하나는 안들어간다.  

하지만 위의 경우 다 들어가 지는데  

이유는 **하나의 클래스 안에서 또 다른 메소드를 호출**하는 구조일 때는 AOP방식으로 프록시 객체가 생기지 않는다.  

따라서 다른 클래스에서 트랜잭션이 걸린 메서드를 호출해야 하는데 
위의 메서드를 호출하는 서비스 클래스를 정의해 서비스 클래스에서 트랜잭션 처리를 하자.  

```java
@Service
public class NLMemberShipService implements MemberShipService {
	
	@Autowired
	private NoticeDao noticeDao;
	public void setNoticeDao(NoticeDao noticeDao) {
		this.noticeDao = noticeDao;
	}
	
	@Override
	public int insertAndPointUpOfMember(Notice notice, String id) throws ClassNotFoundException, SQLException{
		noticeDao.insert(notice);
		notice.setTitle(notice.getTitle()+"-2");
		noticeDao.insert(notice);
		return 0;
	}
}
```

```java
@Repository
public class NLNoticeDao implements NoticeDao{

	@Autowired
	private NamedParameterJdbcTemplate jdbcTemplate; 
	public void setJdbcTemplate(NamedParameterJdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate; 
	}
  ...
  ...
	@Override
	@Transactional(propagation=Propagation.REQUIRED)
	public int insert(Notice notice) throws ClassNotFoundException, SQLException {
		//게시글 작성
		StringBuffer sql = new StringBuffer();
    sql.append(" INSERT INTO NOTICES(SEQ, TITLE, CONTENT, WRITER, REGDATE, HIT, FILESRC) VALUES( ");
    sql.append(" (SELECT NVL(MAX(TO_NUMBER(SEQ)), 0) + 1 FROM NOTICES) ");
    sql.append(" :title, :content, 'newlec', SYSDATE, 0, :filesrc) ");
    //포인트증가
    String sqlPoint = "UPDATE member SET point = point + 1 WHERE id = :id";
		SqlParameterSource paramSource = new BeanPropertySqlParameterSource(notice);
		this.jdbcTemplate.update(sql, paramSource);

		MapSqlParameterSource paramMap = new MapSqlParameterSource();
		paramMap.addValue("id", "newrec");
		this.jdbcTemplate.update(sqlPoint, paramMap);
		return 0;
	}
}
```

이제 하나는 들어가지고 제목 뒤에 `-2`가 붙은 공지사항은 `INSERT`되지 않는다.  

만약 `insertAndPointUpOfMember` 위에도 	`@Transactional(propagation=Propagation.REQUIRED)` 를 설정하면

기존 메서드가 하나의 트랜잭션으로 잡혀 두 번째 `insert()`메서드가 실패하면 첫 번째 `insert()`메서드도 `rollback`된다.  

만약 이상황에서 `insert()` 2개를 각각의 트랜잭션으로 설정하고 싶다면 `REQUIRED_NEW`설정을 사용.

> `<tx:method>` 태그에서도 트랜잭션 전파설정이 가능하다. `propagation` 속성을 사용.  
`<tx:method name="insert*" propagation="REQUIRED" />`  



## 트랜잭션 격리


트랜잭션 처리 과정에서 두개 이상의 트랜젝션이 동시에 같은 공유 자원을 접근하게 된다면 어떻게 처리해야 할까?

테스트를 위해 아래 메서드를 정의

1. `hitup()` - 조회수 1 증가 메서드  
2. `gethit()` - 조회수를 읽어오는 함수  

### Dirty Read

`hitup()` 메서드를 통해 조회수 증가, 기존에 조회수가 10 이었다면 11 로 변경될 것이다.  
`commit`, `rollback`하지 않은 상태에서 `gethit()`메서드가 호출되면 11을 읽어간다.  

그런데 만약 `commit`되기전 어떤 과정에서 오류가 발생되어 `rollback`된다면 조회수는 10으로 돌아가고 `gethit()` 메서드가 읽어간 11 이란 정보는 잘못된 정보가 된다.  

이렇게 잘못된 정보를 읽는 것 을 `Dirty read` 라 한다.  

커밋이 되야지만 읽어갈 수 있도록 설정하면 `Dirty Read` 가 발생하지 않는다.  


### Nonrepeatable Read

하나의 트랜잭션이 시작될때 `gethit()` 메서드 호출 한번
트랜잭션 끝나기 전 gethit 메서드 호출 한번 한다 생각해보자.  

gethit가 호출되는 사이에 hitup 메서드를 통해 조회수를 증가시키면 첫번째 읽은 조회수와 두번째 읽은 조회수가 다르게 출력된다.  

이렇게 처음 읽어드린 값과 후에 읽어드린 값이 다른 상황을 `Nonrepeatable Read` 이라한다.  


### Phantom Read

여러개의 레코드를 한번에 읽어오는 과정을 반복할 때  

만약 DB에 게시글이 5개 있을 때 

이 게시글을 트랜잭션 처음 시작시 읽어오고 끝날때 또 한번 읽을 때  

그 사이에서 게시글 하나를 삭제할 경우 처음엔 5개, 끝나기 전에 4개가 읽힌다.  

이런 상황을 `Phantom Read` 라 한다.  

### 격리 레벨

**Isolation Level**|**Dirty Read**|**Nonrepeatable Read**|**Phantom Read**
:-----:|:-----:|:-----:|:-----:
레벨0 `Read Uncommited`|발생|발생|발생
레벨1 `Read Committed`|X|발생|발생
레벨2 `Repeatable Read`|X|X|발생
레벨3 `Serializable`|X|X|X

|격리레벨|설명|
|---|---|
`READ_UNCOMMITED` | 다른 트랜잭션에서 커밋하지 않은 데이타를 읽을 수 있다.
`READ_COMMITTED` | 다른 트랜잭션에 의해 커밋된 데이터를 읽을 수 있다.
`REPEATABLE_READ` | 처음에 읽어온 데이타와 두 번째 읽어온 데이타가 동일한 값을 갖는다.
`SERIALIZABLE` | 동일한 데이터에 대해서 동시에 두개 이상의 트랜잭션이 수행될 수 없다.

위의 레벨들 말고 `DEFAULT` 격리레벨이 있는데 오라클(DBMS)에 설정된 격리수준을 사용한다는 뜻   

> 오라클에서 제공하는 격리 레벨 수준은 `Read Committed`, `Serializable`이 있다. default를 사용할 경우 2개의 격리수준만 사용 가능  

```java
public ModelAndView noticeDetail(@RequestParam("seq") String seq ) 
throws ClassNotFoundException, SQLException{
  new Thread(new Runnable() {
    @Override
    public void run() {
      try {
        Thread.sleep(500); //조회수 증가를 먼저 start시키려고
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
      noticeDao.gethit(seq);
    }
  }, "getHit Thread").start();
  new Thread(new Runnable() {
    @Override
    public void run() {
      noticeDao.hitup(seq);
    }
  }, "hitup Thread").start();
  Notice notice = this.noticeDao.getNotice(seq);
  ModelAndView mv= new ModelAndView("noticeDetail.jsp");
  mv.addObject("notice", notice);
  return mv;
}
```
gethit은 바로실행되고 hitup은 1초후에 실행된다. 그리고 0.5초 기다렸다 실행된다.  
조회수가 올라가고 0.5초후에 gethit되고 또 0.5초후에 롤백됨으로 더티 리드가 발생함  

`gethit()`메서드에서 `<tx:method>`의 `isolation`속성을 어떻게 설정할지  
`@Transactional(isolation=...)`어노테이션에서 `isolation`속성을 어떻게 설정할지에 따라 위의 트랜잭션 격리레벨을 지정할 수 있다.  
