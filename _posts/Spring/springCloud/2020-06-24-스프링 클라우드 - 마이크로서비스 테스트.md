---
title:  "spring cloud - 마이크로서비스 테스트!"

read_time: false
share: false
author_profile: false
# classes: wide

categories:
  - spring

tags:
  - eureka
  - spring-cloud

toc: true
toc_sticky: true

---

# 테스트 전략  

마이크로 서비스에서의 테스트 자동화는 모놀리식보다 더욱 중요하다.  
하나의 서비스에서 문제가 발생하면 연관된 다른 서비스들에도 연쇄적인 문제가 발생함으로 테스트 과정을 필수이다.  

모놀리식의 경우 DB와 함께 단위테스트, 통합테스트를 통해 이루어지지만  
마이크로서비스에선 아래와 같은 테스트 전략이 사용된다.  

- 단위 테스트  
가장 작은 메서드 단위서부터 여러 메서드와 구성요소를 호출하는 단위까지.  
서비스 내부에서 요구사항을 만족하는지 확인하는 용도로 사용된다.  

- 통합 테스트  
서비스 내에서 호출하는 외부 서비스까지 포함하여 테스트, Mock 을 통해 외부와 통신, 상호작용하는 것을 테스트한다.  
마이크로 서비스에선 다른 서비스에서 데이터(캐시 포함) 를 가져오기 위한 목적으로 사용된다.  


- 엔드투엔드 데스트  
서비스가 외부세계의 요구사항을 만족하는지 검증, 연관된 모든 서비스를 테스트해야하기에 정밀한 테스트 시나리오를 구상해야 한다.  


- 컨트랙트 테스트  
직역하면 계약 테스트이다. 서비스간의 API, 혹은 메세지 규정이 개발자가 예상한대로 정의되어 있는지 검증하는 테스트이다.  
통합테스트와 비슷하게 서비스간 상호작용을 요구하지만 다른 마이크로 서비스를 블랙박스로 취급하고 응답형식만 검증한다.  


- 컴포넌트 테스트  
단위테스트 완료후 외부세계와 단전될 상태에서 마이크로 서비스 전체를 테스트한다.  
격리된 상태에서 테스트를 위해 가상의 `mock`, `stub` 이 필요하다.  
실제 외부세계와 연동은 통합 테스트에서 이루어진다.   

## 테스트 순서

1. 단위 테스트  
2. 컴포넌트 테스트  
3. 통합 테스트  
4. 컨트랙트 테스트  
5. 엔드투엔드 테스트  
6. 부하 테스트  
7. 한계 테스트  


# 테스트 구성  

> https://stackoverflow.com/questions/41985262/spring-boot-test-overriding-bootstrap-properties

`spring-cloud` 환경에서 테스트시에 쓸때없는 `discovery`, `cloud-config` 등의 설정을 제외시켜야 할 수 있다.  

`application.properties` 보다 `bootstrap.properties` 설정이 먼저 로드되기 때문에 `spring-cloud` 관련 설정을 제거하고 싶다면 `bootstrap.properties` 에 지정해야 한다.  

`bootstrap.properties` 은 실제 운영에서 필요한 설정이 들어가기에 `spring-cloud` 관련 설정을 제거하기엔 어려움이 있다.  

2가지 방법중 하나를 택하는것이 효율적이다.  

- `bootstrap-test.properties` 파일을 `test/resources` 에 생성해 `@ActiveProfiles("test")` 사용   
- `@TestPropertySource(locations = "classpath:application-test.properties")` 를 사용해 수동으로 설정 지정   

여러가지 `Profiles` 를 조합해 설정할수 있는 첫번째 방법이 좀더 효율적인 것 같다.  

## 테스트 어노테이션  

### @SpringBootTest

### @WebMvcTest 

내부에 `@AutoConfigureCache`, `@AutoConfigureWebMvc`, `@AutoConfigureMockMvc` 등의 어노테이션을 포함하고 있음  

`Controller`, `ControllerAdvice`, `JsonComponent`, `Converter`, `GenericConverter`, `Filter`,  `HandlerInterceptor`, `WebMvcConfigurer`, `HandlerMethodArgumentResolver` 등의 빈만 등록


## 단위 테스트  

단순히 내부에서 사용되는 API 를 테스트 

```java
//@SpringBootTest
@WebMvcTest(AccountController.class)
@ActiveProfiles("test")
// @Controller, @ControllerAdvice, @JsonComponent, Converter, GenericConverter,
// Filter, HandlerInterceptor, WebMvcConfigurer, HandlerMethodArgumentResolver 등의 빈만 등록
public class AccountControllerTest {
    ObjectMapper mapper = new ObjectMapper();

    @Autowired
    MockMvc mvc;

    // 가상 빈, 메서드 호출 족족 Mock proxy 클래스가 호출을 인터셉트하여 가상의 데이터를 반환한다.
    @MockBean
    AccountService accountService;

    @Test
    public void testAdd() throws Exception {
        Account account = new Account("1234567890", 5000, 1);
        when(accountService.save(any(Account.class))) // when: 특정 메서드가 호출되면 해당 데이터 반환
                .thenReturn(Account.builder()
                        .id(1l)
                        .number("1234567890")
                        .balance(5000)
                        .customerId(1l).build());
        mvc
                .perform(post("/")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsString(account)))
                .andExpect(status().isOk());
    }

    @Test
    public void testWithdraw() throws Exception {
        Account account = Account.builder()
                .id(1l)
                .number("1234567890")
                .balance(5000)
                .customerId(1l)
                .build();
        when(accountService.findById(1l)).thenReturn(account);
        // thenAnswer 는 input, output 을 모두 관리한다. getArgument 로 매개 변수를 받고 상호작용하여 반환값을 설정 가능하다.
        when(accountService.save(any(Account.class))).thenAnswer(new Answer<Account>() {
            @Override
            public Account answer(InvocationOnMock invocationOnMock) throws Throwable {
                Account a = invocationOnMock.getArgument(0, Account.class); // 0번째 매개 변수
                return a;
            }
        });
        mvc.perform(put("/withdraw/1/1000"))
                .andExpect(status().isOk())
                .andExpect(content().contentType(MediaType.APPLICATION_JSON))
                .andExpect(jsonPath("$.balance", is(4000)))
                .andDo(print());
    }
}
```

`feign client` 또한 `Mock` 으로 처리 가능하기에 단위테스트가 가능하다.  

```java
@WebMvcTest(OrderController.class)
public class OrderControllerTest {
    @Autowired
    MockMvc mvc;
    @MockBean
    OrderService orderService;
    // feign client 
    @MockBean
    AccountClient accountClient;

    @Test
    public void testAccept() throws Exception {
        Order order = Order.builder()
                .id(1l)
                .status(OrderStatus.DONE)
                .price(2000)
                .customerId(1l)
                .accountId(1l)
                .productIds(null)
                .build();
        when(orderService.findById(1l)).thenReturn(order);
        when(accountClient.withdraw(order.getAccountId(), order.getPrice())).thenReturn(Account.builder()
                .id(1l)
                .number("123")
                .balance(0)
                .build());
        when(orderService.add(Mockito.any(Order.class))).thenAnswer(new Answer<Order>() {
            @Override
            public Order answer(InvocationOnMock invocation) throws Throwable {
                Order o = invocation.getArgument(0, Order.class);
                return o;
            }
        });
        mvc.perform(put("/1"))
                .andExpect(status().isOk())
                .andExpect(content().contentType(MediaType.APPLICATION_JSON_UTF8))
                .andExpect(jsonPath("$.status", is("DONE")));

    }
}
```

컨트롤러에서 사용되는 의존성 객체들이 많아질수록 `Mock` 객체 지정을 일일이 해주어야 한다.  

항상 `feign client` 나 `ribbon` 등의 클라이언트를 사용할땐 웬만하면 `Service` 객체로 감싸서 처리하는것이 테스트할때 편하다.  
아니면 사용되는 `http request` 에 따른 `hoverfly` 룰을 지정해주어야 한다.  

## 컴포넌트 테스트  

메모리 기반의 테스트용 데이터 저장소(`h2`, `embed mongo`) 를 사용해 테스트한다.  
따라서 `Mock` 을 사용하지 않고 실제 데이터 저장을 사용하며 `http` 응답만 `hoverfly` 를 통해 시뮬레이션 한다.  

```java
@Slf4j
@ExtendWith(HoverflyExtension.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles("test")
public class OrderComponentTest {

    @Autowired
    ObjectMapper objectMapper;

    @Autowired
    TestRestTemplate testRestTemplate;

    @Autowired
    OrderRepository orderRepository;

    @BeforeEach
    public void init(Hoverfly hoverfly) throws JsonProcessingException {
        Account account = Account.builder()
            .id(1l)
            .number("1234567890")
            .balance(5000)
            .build();

        Customer customer = Customer.builder()
            .id(1l)
            .name("test1")
            .type(CustomerType.REGULAR)
            .accounts(Collections.singletonList(account))
            .build();

        Product product = Product.builder()
            .id(1l)
            .name("Test1")
            .price(1000)
            .build();

        String accountString = objectMapper.writeValueAsString(account);
        String customerString = objectMapper.writeValueAsString(customer);
        String productListString = objectMapper.writeValueAsString(Collections.singletonList(product));

        hoverfly.simulate(dsl(
                service("account-service:8080")
                    .put(startsWith("/withdraw/"))
                    .willReturn(success(accountString, "application/json")),
                service("customer-service:8081")
                    .get("/withAccounts/1")
                    .willReturn(success(customerString, "application/json")),
                service("product-service:8083")
                    .post(any()).anyBody()
                    .willReturn(success(productListString, "application/json"))
        ));
    }

    @Test
    public void testPrepare() throws JsonProcessingException {
        Order order = Order.builder()
            .status(OrderStatus.NEW)
            .accountId(1l)
            .customerId(1l)
            .productIds(Collections.singletonList(1l))
            .build();

        order = testRestTemplate.postForObject("/", order, Order.class);
        Assertions.assertNotNull(order);
        Assertions.assertEquals(OrderStatus.ACCEPTED, order.getStatus());
        Assertions.assertEquals(940, order.getPrice());
        log.info("order: {}", objectMapper.writeValueAsString(order));
    }
}
```

## 통합 테스트

지금까지 내부 혹은 내부에서 연동하는 외부 모듈을 가상화하여 테스트를 완료하였다.  

실제 외부 구성요소와 연동되는 모듈을 테스트해보자.  


`maven-surefire-plugin`: 단위 테스트를 실행하도록 설계되었으며 테스트 중 하나라도 실패하면 빌드가 즉시 실패합니다.

`maven-failsafe-plugin`: 통합 테스트를 실행하도록 설계되었으며 실제로 테스트를 실행하여 테스트에 실패한 경우 빌드에 실패합니다.

2개의 플러그인 모두 테스트환경에서 test 결과를 기반으로 빌드 진행여부를 결정한다.  

### maven surefire plugin

> https://www.baeldung.com/maven-surefire-plugin
> https://www.baeldung.com/maven-ignore-test-results

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-surefire-plugin</artifactId>
    <version>3.0.0-M3</version>
    <configuration>
        <excludedGroups>IntegrationTest</excludedGroups>
    </configuration>
</plugin>
```

`@Tag("IntegrationTest")` 어노테이션이 사용된 테스트는 테스트 과정에 포함되지 않게된다.  

> 흔히 사용되는 `skipTest` 설정도 `surefire` 플러그인을 사용한다.  
`mvn package -Dmaven.test.skip=true`

### maven failsafe plugin

> https://www.baeldung.com/maven-failsafe-plugin

`failsafe` 플러그인이 수행하는 `goal`은 2가지,  

- `integration-test` : 통합테스트 실행
- `verify` : 통합테스트가 통과되었는지 확인

통합테스트로 테스트를 실행할 경우 연결 해제 등의 안전한 종료가 이루어진다.(추론)

```xml
<plugins>
    <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-surefire-plugin</artifactId>
        <version>3.0.0-M3</version>
        <configuration>
            <excludedGroups>integrationTest</excludedGroups>
        </configuration>
    </plugin>
    <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-failsafe-plugin</artifactId>
        <version>3.0.0-M3</version>
        <configuration>
            <groups>integrationTest</groups>
        </configuration>
        <executions>
            <execution>
                <goals>
                    <goal>integration-test</goal>
                </goals>
                <configuration>
                    <includes>
                        <include>**/*.class</include>
                    </includes>
                </configuration>
            </execution>
        </executions>
    </plugin>
</plugins>
```

`@Tag("integrationTest")` 의 단위 테스트실행(`surefire`)은 하지 않도록한 후 통합테스트(`failsafe`)만 실행한다.  
또한 `goals` 에 `integration-test` 만 수행하고 `verify` 는 실행하지 않기 때문에 테스트 결과가 `failed` 이여도 `build` 에는 문제가 없다.  

통합 테스트의 경우 다른 마이크로 서비스를 실제 호출하는 것이기 때문에 타 서비스에 영향을 끼칠 수 있다.  
신중한 테스트 시나리오 설정이 필요  

## 컨트랙트 테스트

컨트랙트의 주요 개념은 호출자와 피호출자의 계약을 정의하는 것.  

계약 생성은 주로 호출자(컨슈머)가 하기때문에 컨슈머 주도 테스트라고도 한다.   
> 컨트랙트 테스트 = 컨슈머 주도 테스트  

`customer-service -> account-service` 해당 과정을 컨트랙트 테스트로 구성해보자.  
`customer` 는 `feign` 을 사용해 `account` 를 호출한다.  

## Pact

![msa-test2](/assets/2020/msa-test2.png){: .shadow}  

위 그림처럼 `consumer(customer-service)` 가 `request`와 해당하는 `response` 샘플을 미리 등록해두고  
`provider(account-service)` 가 해당 데이터를 반환함으로 테스트가 성공하는 구조이다.  

`consumer` 에서 모든 등록과정이 이루어지기 때문에 세밀한 데이터 설정이 중요하다.  

###  Pact broker 설치  

아래 2개 `docker` 컨테이너 설치  

```
$ docker run -d --name postgres -p  5432:5432 \
-e POSTGRES_USER=oauth -e POSTGRES_PASSWORD=oauth123 -e POSTGRES_DB=oauth postgres

$ docker run -d --name pact-broker --link postgres:postgres -p 9292:9292 \
-e PACT_BROKER_DATABASE_USERNAME=oauth \
-e PACT_BROKER_DATABASE_PASSWORD=oauth123 \
-e PACT_BROKER_DATABASE_HOST=postgres \
-e PACT_BROKER_DATABASE_NAME=oauth pactfoundation/pact-broker
```

> https://docs.pact.io/pact_broker/

### Pact Consumer  

> https://github.com/SrinivasanTarget/ContractTestingBoilerplate
> https://docs.pact.io/implementation_guides/jvm/consumer/junit5/

`customer-service` 가 `account-service` 에 있는 리소스를 요청할 것이기 때문에 `customer-service` 가 `consumer` 이다.  

```xml
<dependency>
    <groupId>au.com.dius</groupId>
    <artifactId>pact-jvm-consumer-junit5</artifactId>
    <version>4.0.10</version>
    <scope>test</scope>
</dependency>

<plugin>
    <groupId>au.com.dius</groupId>
    <artifactId>pact-jvm-provider-maven</artifactId>
    <version>4.0.0</version>
    <configuration>
        <pactBrokerUrl>http://localhost:9292</pactBrokerUrl>
        <pactDirectory>target/pacts</pactDirectory>
    </configuration>
</plugin>
```

위와 같이 `dependency`, `plugin` 설치  

`hoverfly` 처럼 `PactDslWithProvider` 를 사용하면 가상의 `response` 데이터를 적용할 수 있다.  

```java

@Slf4j
@ExtendWith(PactConsumerTestExt.class)
@ExtendWith(SpringExtension.class)
@ActiveProfiles("contact")
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)
@PactTestFor(providerName = "customerServiceProvider", port = "9080")
public class CustomerConsumerContractTest {

    @Autowired
    ObjectMapper objectMapper;
    @Autowired
    private AccountClient accountClient;

    @Pact(consumer = "accountClientPact")
    public RequestResponsePact callAccountClient(PactDslWithProvider builder) throws JsonProcessingException {
        log.info("callAccountClient invoked");
        List<Account> accountList = new ArrayList<>();
        ObjectMapper objectMapper = new ObjectMapper();
        accountList.add(Account.builder()
                .id(1l)
                .number("123")
                .balance(5000)
                .customerId(1l)
                .build());
        accountList.add(Account.builder()
                .id(2l)
                .number("124")
                .balance(5000)
                .customerId(1l)
                .build());
        accountList.add(Account.builder()
                .id(3l)
                .number("125")
                .balance(5000)
                .customerId(1l)
                .build());

        return builder
                .given("list-of-3-accounts")
                .uponReceiving("test-account-service")
                .path("/customer/1")
                .method("GET")
                .willRespondWith()
                .status(200)
                .body(objectMapper.writeValueAsString(accountList), ContentType.APPLICATION_JSON)
                .toPact();
    }

    @Test
    @PactTestFor(pactMethod = "callAccountClient")
    public void verifyAccountsPact(MockServer mockServer) throws IOException {
        // hysytrix 가 설정되어 있다면 timeoutInMilliseconds 기본 1초를 늘리는것을 확인, pact 가 빠르지 않다.
        List<Account> accounts = accountClient.findCustomerAccounts(1l);
        log.info(objectMapper.writeValueAsString(accounts));
        Assertions.assertEquals(3, accounts.size());
    }
}
```

`@PactTestFor` 를 통해 `9080` 포트로 데이터 요청할 것이라는 것, 각종 `provider`,`consumer 명을 작성.  
`PactDslWithProvider` 를 통해 캡처할 `path`, 반환할 `body` 등을 작성.  

`accountClient.findCustomerAccounts` 내부에선 `ribbon` 클라이언트를 통해 `account-service/customer/1` `url` 을 `request` 한다.  

> 간단히 `eureka`, `cloud-config`, `zipkin` 등을 `disable` 한다.  
```conf
server.port=8081
spring.profiles=contact
spring.datasource.url=jdbc:h2:mem:account-${INSTANCE:0};DATABASE_TO_UPPER=false;DB_CLOSE_DELAY=-1
#Disable discovery
spring.cloud.discovery.enabled=false
#Disable cloud config and config discovery
spring.cloud.config.discovery.enabled=false
spring.cloud.config.enabled=false
# test 에서 사용할 수 있도록 미리 리본 클라이언트 등록
account-service.ribbon.listOfServers=127.0.0.1:9080
spring.zipkin.enabled=false
```

테스트를 실행하거나  `mvn install` 명령을 진행하면 `target/pacts` 캡처된 내용의 `json` 파일이 작성된다.  

작성된 내용을 `mvn pact:publish` 를 통해 `docker` 로 설치된 `pact broker` 로 배포하면 된다.  

![msa-test1](/assets/2020/msa-test1.png){: .shadow}  

### Pact Provider  

`consumer` 가 `pact` 를 생성, 브로커에 전달했다면 `provider` 에서 검증 테스트를 진행한다.  

```xml
<dependency>
    <groupId>au.com.dius</groupId>
    <artifactId>pact-jvm-provider-junit5</artifactId>
    <version>4.0.10</version>
    <scope>test</scope>
</dependency>

<plugin>
    <groupId>au.com.dius</groupId>
    <artifactId>pact-jvm-provider-maven</artifactId>
    <version>4.0.0</version>
    <configuration>
        <pactBrokerUrl>http://localhost:9292</pactBrokerUrl>
        <pactDirectory>target/pacts</pactDirectory>
    </configuration>
</plugin>
```

`consumer` 와 마찬가지로 `dependency`, `plugin` 설정, `artifactId` 만 `consumer` 에서 `provider` 로 변경됐다.  

```java
@Provider("customerServiceProvider")
@PactBroker(host = "127.0.0.1", port = "9292")
@ActiveProfiles("contract")
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)
public class AccountProviderContractTest {

    @MockBean
    private AccountRepository accountRepository;

    @TestTemplate
    @ExtendWith(PactVerificationInvocationContextProvider.class)
    void pactVerificationTestTemplate(@NotNull PactVerificationContext context) {
        context.verifyInteraction();
    }

    @BeforeEach
    void before(PactVerificationContext context) {
        context.setTarget(new HttpTestTarget("localhost", 9080));
    }

    @State("list-of-3-accounts")
    public void toDefaultState() {
        List<Account> accountList = new ArrayList<>();
        accountList.add(Account.builder()
                .id(1l)
                .number("123")
                .balance(5000)
                .customerId(1l)
                .build());
        accountList.add(Account.builder()
                .id(2l)
                .number("124")
                .balance(5000)
                .customerId(1l)
                .build());
        accountList.add(Account.builder()
                .id(3l)
                .number("125")
                .balance(5000)
                .customerId(1l)
                .build());
        when(accountRepository.findAllByCustomerId(1l)).thenReturn(accountList);
    }
}
```

`@Provider`, `@State` 명을 `consumer` 에서 등록했던것과 동일하게 설정.  
`@TestTemplate` 을 실행하면 `customer/1` url 로 `request` 하고 `MockBean` 을 통해 `accountRepository` 에 설정해둔대로 `consumer` 가 저장해둔 `accountList` 와 동일한 데이터가 반환된다.  

데이터가 일치한다면 테스트가 통과된다.  

## spring cloud contract  

`Pact` 와 조금 다르게 동작하는 컨트랙트 브로커,  
`Pact` 에선 `consumer` 가 `contract` 를 등록하지만 `spring cloud contract` 에선 `provider` 가 등록한다.  

![msa-test3](/assets/2020/msa-test3.png){: .shadow}  

또한 `contract` 저장소로 `maven` 리포지토리를 사용하며 주로 `spring cloud contract`로 로컬에 생성된 `jar` 파일을 이용한다.  

설정이 상당히 복잡한데 아래 샘플 코드를 참고하면 좋다.  

> https://github.com/spring-cloud-samples/spring-cloud-contract-samples

### provider 

`contract` 등록자인 `provider` 먼저 구현  
`account-service` 에 구현한다.  

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-contract-verifier</artifactId>
    <scope>test</scope>
</dependency>

<plugin>
    <!--컨트랙트 테스트를 실행 및 파일 생성 ,-->
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-maven-plugin</artifactId>
    <extensions>true</extensions>
    <configuration>
        <packageWithBaseClasses>com.sample.spring.cloud.account</packageWithBaseClasses>
        <testFramework>JUNIT5</testFramework>
    </configuration>
</plugin>
```

위 `dependency` 와 `plugin` 추가,  
`build` 시에 `target` 디렉토리에 `packageWithBaseClasses`속성에 설정한 패키지명으로 테스트 조건이 작성되어 있는 `java` 파일이 생성된다.  

조건은 `groovy` 파일로 작성한다.  

`resource.contracts.accountService` 디렉토리에 아래와 같은 `groovy` 파일 생성  
디렉토리 경로의 `accountService` 는 클래스명의 `prefix` 로 동작하며 `accountServiceBase` 라는 클래스를 찾는다.(`packageWithBaseClasses` 에 설정한 패키지에서)

```groovy
org.springframework.cloud.contract.spec.Contract.make {
    request {
        method 'GET'
        url '/customer/1'
    }
    response {
        status 200
        body([
                [
                        id        : $(regex('[0-9]{5}')),
                        number    : '123',
                        balance   : 5000,
                        customerId: fromRequest().path(1)
                ], [
                        id        : $(regex('[0-9]{5}')),
                        number    : '124',
                        balance   : 5000,
                        customerId: fromRequest().path(1)
                ], [
                        id        : $(regex('[0-9]{5}')),
                        number    : '125',
                        balance   : 5000,
                        customerId: fromRequest().path(1)
                ]
        ])
        headers {
            contentType(applicationJson())
        }
    }
}
```

해당 파일을 기반으로 아래의 `java` 파일이 `target/generated-test-sources` 에 생성된다.  

위에서 설정한 `accountService` 패키지 명 뒤에 `Base` 를가 붙은 `AccountServiceBase`클래스를 상속한 것을 볼 수 있다.  
또한 생성된 java 클래스명은 뒤에 `Test` 가 붙은 `AccountServiceTest` 이다.  

```java
@SuppressWarnings("rawtypes")
public class AccountServiceTest extends AccountServiceBase {
	@Test
	public void validate_customerContract() throws Exception {
		// given:
			MockMvcRequestSpecification request = given();

		// when:
			ResponseOptions response = given().spec(request)
					.get("/customer/1");

		// then:
			assertThat(response.statusCode()).isEqualTo(200);
			assertThat(response.header("Content-Type")).matches("application/json.*");

		// and:
			DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
			assertThatJson(parsedJson).array().contains("['id']").matches("[0-9]{2}");
			...
            ...
	}
}
```

테스트 메서드의 `body` 는 `/customer/1` url 로 `request` 요청이 `response` 가 조건에 부합한지 체크한다.  

아까부터 계속 나온 `AccountServiceBase`는 해당 조건에 맞는 `response` 가 갈 수 있도록 설정해주어야 한다.  

`@BeforeEach` 어노테이션을 통해 자동 생성된 `AccountServiceTest` 의 테스트 메서드가 `@MockBean` 에서 생성된 데이터를 사용할 수 있도록 설정한다.  

```java
@SpringBootTest
@ActiveProfiles("contract")
public abstract class AccountServiceBase {

    @Autowired
    private WebApplicationContext context;

    @MockBean
    private AccountRepository accountRepository;

    @BeforeEach
    public void setup() {
        RestAssuredMockMvc.webAppContextSetup(context);
        List<Account> accountList = new ArrayList<>();
        accountList.add(Account.builder()
                .id(12345l)
                .number("123")
                .balance(5000)
                .customerId(1l)
                .build());
        accountList.add(Account.builder()
                .id(22345l)
                .number("124")
                .balance(5000)
                .customerId(1l)
                .build());
        accountList.add(Account.builder()
                .id(32345l)
                .number("125")
                .balance(5000)
                .customerId(1l)
                .build());
        when(accountRepository.findAllByCustomerId(1l)).thenReturn(accountList);
    }
}
```

`maven clean install` 을 통해 `plugin`을 실행하고 자동생성된 테스트 메서드 `AccountServiceTest` 가 통과하면 `xxx-stubs.jar` 파일이 생성된다.  

해당 `jar` 파일을 통해 `consumer` 의 `contract` 테스트가 이루어진다.  


### consumer


`consumer` 용 `dependency` 추가  

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-contract-stub-runner</artifactId>
    <scope>test</scope>
</dependency>
```

```java
@Slf4j
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)
@ActiveProfiles("contract")
// 생성된 jar 파일을 가져올 수 있도록 group, artifact 등 설정
// groupId:artifactId:versioncode:stub-qualifier:port
@AutoConfigureStubRunner(ids = "com.sample.spring.cloud:account:+:stubs:9080",
    stubsMode = StubRunnerProperties.StubsMode.LOCAL)
public class AccountContractTest {

    @Autowired
    private AccountClient accountClient;
    @Autowired
    private ObjectMapper objectMapper;

    @Test
    public void verifyAccounts() throws JsonProcessingException {
        List<Account> accounts = accountClient.findCustomerAccounts(1l);
        log.info("accounts:" + objectMapper.writeValueAsString(accounts));
        Assertions.assertEquals(3, accounts.size());
    }
}
```

약간의 설정이 필요하다.  

```conf
server.port=8081
spring.profiles=contract
spring.datasource.url=jdbc:h2:mem:account-${INSTANCE:0};DATABASE_TO_UPPER=false;DB_CLOSE_DELAY=-1
#Disable discovery
spring.cloud.discovery.enabled=false
#Disable cloud config and config discovery
spring.cloud.config.discovery.enabled=false
spring.cloud.config.enabled=false
# test 에서 사용할 수 있도록 미리 리본 클라이언트 등록
account-service.ribbon.listOfServers=account-service:9080
spring.zipkin.enabled=false
logging.level.root=info
# AutoConfigureStubRunner 에서 account-service 용 프록시 객체 생성 
stubrunner.ids-to-service-ids.account=account-service
```

### 시나리오  

