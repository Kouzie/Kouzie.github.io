---
title:  "쿠버네티스 - 디플로이먼트, 컨피그맵, 시크릿!"

read_time: false
share: false
author_profile: false
classes: wide

categories:
  - docker
  - kubernetes

tags: kubernetes

toc: true

---

# 디플로이먼트

> Deployment: 전개, 배치  
> https://kubernetes.io/ko/docs/concepts/workloads/controllers/deployment/


쿠버네티스에선 어플리케이션의 유연한 `CI/CD(지속적인 통합/배포)` 를 위해 `Deployment` 를 제공한다.  

`Deployment`는 리플리카셋의 상위개념이다.  
똑같이 여러개의 파드를 생성하고 관리한다.  
여기서 업데이트 관련 기능을 추가 제공해준다 생각하면 된다.  

## 용어설명  

**Recreate**  
오래된 파드를 정지시키고 새로운 파드를 다시 작성하는 방식.
가장 심플하고 빠르지만 서버가 모두 내려가 버리기에 다운타임이 발생한다.  

**Rolling update**  
애플리케이션 버전업이 모두 한꺼번에 업데이트 되는것이 아닌  
순서대로 조금씩 업데이트하는 방법  

똑같은 애플리케이션이 여러 개 병렬로 움직이는 경우 가능하다.  

**blue/green Deployment**   
버전이 다른 두 애플리케이션을 동시에 가동하고 네트워크 설정을 사용해 별도의 공간에서 동작시킨다.  
업데이트 버전의 애플리케이션 테스트 완료 후 서비스는 전환시켜 업데이트 완료.    

블루(구버전), 그린(신버전) 을 전환하는 뜻에서 유래됨.  

그린의 애플리케이션에서 장애 발생시 블루로 바로 복구 가능한 장점이 있다.  

**Roll out, Roll back**   
롤아웃(`roll-out`) 간단히 번역하면 신제품 또는 정책출시 또는 릴리즈라 할 수 있다.

`Deployment`는 컨테이너 이미지 버전업 등 업데이트가 있을 때 사로운 사양의 리플리카셋(매니페스트) 를 작성하고  
그에 해당하는 새로운 파드로 이를 대체해 롤아웃을 수행한다.  

## 매니페스트 

```yaml
# 기본항목
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
# 디플로이먼트 스팩
spec:
  replicas: 10
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 50%
      maxSurge: 50%
  selector:
    matchLabels:
      app: nginx-pod # 템플릿 검색조건
  # 파드 템플릿
  template:
    metadata:
      labels:
        app: nginx-pod
    spec:
      containers:
        - name: nginx
          image: nginx:1.14 # 컨테이너 이미지
          ports:
            - containerPort: 80
```


`Deployment`의 매니페스트 또한 `spec` 속성이 좀 다를뿐 나머지는 비슷하다.  

|필드|설명|
|---|---|
`replicas` | 클러스터 안에서 가동시킬 파드의 수  
`selector` | 어떤 파드를 가동시킬지에 대한 셀렉터, 파드에 적용된 라벨을 사용한다.  
`template` | 클러스터 내부 파드 수가 리플리카수보다 작을때 새로 작성할 파드의 템플릿  
`strategy` | 업데이트 방식 결정 가능, `RollingUpdate`, `Recreate` 가 있으며 기본값은 `RollingUpdate`  
`maxUnavailable` | 롤링 업데이트중 항상 사용가능한 파드의 총수, 위의 경우 신버전, 구버전 합쳐서 리플리카수의 50%의 파드가 항상 동작중이어야 한다. 기본값은 25%  
`maxSurge` | 파드를 작성할 수 있는 최대 개수, 100%로 설정시 신버전의 파드수가 리플리카수만큼 실행되어 한번에 20개의 파드가 동작하게 된다. 기본값은 25%. 리소스 상황에 따라 특이사항이 발생할 수 있음으로 `maxSurge` 는 작성하는 것을 권장한다.  
`readinessProbe` | 실행한 파드가 정상인지 확인하는 속성 파드의 `livenessProbe` 와 비슷하다. 



- `livenessProbe`: 컨테이너가 동작 중인지 여부를 나타낸다. 만약 활성 프로브(liveness probe)에 실패한다면, kubelet은 컨테이너를 죽이고, 해당 컨테이너는 재시작 정책의 대상이 된다. 만약 컨테이너가 활성 프로브를 제공하지 않는 경우, 기본 상태는 Success이다.  

- `readinessProbe`: 컨테이너가 요청을 처리할 준비가 되었는지 여부를 나타낸다. 만약 준비성 프로브(readiness probe)가 실패한다면, 엔드포인트 컨트롤러는 파드에 연관된 모든 서비스들의 엔드포인트에서 파드의 IP주소를 제거한다. 준비성 프로브의 초기 지연 이전의 기본 상태는 Failure이다. 만약 컨테이너가 준비성 프로브를 지원하지 않는다면, 기본 상태는 Success이다.  

> `Pod livenessProbe`: https://kouzie.github.io/docker/kubernetes/쿠버네티스-파드/#파드-감시


## 디플로이먼트 CRUD

### 디플로이먼트 생성  

위의 `Deployment` 매니페스트를 생성후 리플리카셋과 파드가 생성되는지 확인  

리플리카수를 3으로 설정후 생성한다.  

```
$ kubectl apply -f Deployment/nginx-deployment.yaml
deployment.apps/nginx-deployment created

$ kubectl get deploy
NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   3/3     3            3           24s

$ kubectl get replicaset,pod
NAME                                          DESIRED   CURRENT   READY   AGE
replicaset.apps/nginx-deployment-5bff7844cb   3         3         3       5m11s

NAME                                    READY   STATUS    RESTARTS   AGE
pod/nginx-deployment-5bff7844cb-6n2xh   1/1     Running   0          5m11s
pod/nginx-deployment-5bff7844cb-9jmvt   1/1     Running   0          5m11s
pod/nginx-deployment-5bff7844cb-kc7ph   1/1     Running   0          5m11s
```

리소스의 네이밍 규칙이 있다.  

`Deployment` - `nginx-deployment`  
`ReplicaSet` - `nginx-deployment-5bff7844cb`  
`Pod` - `nginx-deployment-5bff7844cb-kc7ph`  

뒤에 특정 해시값이 라벨로도 붙어있으며 이를 사용해 `Deployment`가 리소스를 관리한다.  

### 디플로이먼트 상세정보  

```
$ kubectl describe deploy nginx-deployment
Name:                   nginx-deployment
Namespace:              default
...
...
OldReplicaSets:  <none>
NewReplicaSet:   nginx-deployment-5bff7844cb (3/3 replicas created)
```


### 디플로이먼트 업데이트(롤 아웃)

기존의 `nginx:1.14` 버전의 이미지를 `nginx:1.15` 로 변경해보자.  
```
$ kubectl apply -f Deployment/nginx-deployment.yaml
deployment.apps/nginx-deployment configured

$ kubectl describe deploy nginx-deployment
Name:                   nginx-deployment
Namespace:              default
...
...
OldReplicaSets:  <none>
NewReplicaSet:   nginx-deployment-f75fb748c (3/3 replicas created)
Events:
  Type    Reason             Age   From                   Message
  ----    ------             ----  ----                   -------
  Normal  ScalingReplicaSet  28m   deployment-controller  Scaled up replica set nginx-deployment-5bff7844cb to 3
  Normal  ScalingReplicaSet  18s   deployment-controller  Scaled up replica set nginx-deployment-f75fb748c to 1
  Normal  ScalingReplicaSet  4s    deployment-controller  Scaled down replica set nginx-deployment-5bff7844cb to 2
  Normal  ScalingReplicaSet  4s    deployment-controller  Scaled up replica set nginx-deployment-f75fb748c to 2
  Normal  ScalingReplicaSet  3s    deployment-controller  Scaled down replica set nginx-deployment-5bff7844cb to 1
  Normal  ScalingReplicaSet  3s    deployment-controller  Scaled up replica set nginx-deployment-f75fb748c to 3
  Normal  ScalingReplicaSet  2s    deployment-controller  Scaled down replica set nginx-deployment-5bff7844cb to 0
```

`nginx-deployment-5bff7844cb` 이름의 리플리카셋의 파드를 하나씩 줄이며  
`nginx-deployment-f75fb748c` 이름의 새로운 리플리카셋의 파드를 하나씩 생성한다.  


디플로이먼트는 내부에서 리플리카셋 이력을 갖고 있다.  

```
$ kubectl get replicaset --output=wide
NAME                          DESIRED   CURRENT   READY   AGE   CONTAINERS   IMAGES       SELECTOR
nginx-deployment-5bff7844cb   0         0         0       44m   nginx        nginx:1.14   app=nginx-pod,pod-template-hash=5bff7844cb
nginx-deployment-f75fb748c    3         3         3       16m   nginx        nginx:1.15   app=nginx-pod,pod-template-hash=f75fb748c
```

삭제는 다른 리소스와 같이 `delete` 명령을 사용  

```
$ kubectl delete -f Deployment/nginx-deployment.yaml
```

## 디플로이먼트 롤백  

디플로이먼트를 업데이트하고 문제가 생기면 다시 이전버전으로 돌릴 수 있는 기능(롤백) 을 사용해보자.  

먼저 아래와 같은 디플로이먼트를 생성 후 실제 서비스까지 동작하는지 확인  

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rollout-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: photo-view
  template:
    metadata:
      labels:
        app: photo-view
    spec:
      containers:
        - image: ai1.beyless.com:5005/photo-view:v1.0
          name: photoview-container
          ports:
            - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: rollout
spec:
  type: LoadBalancer
  ports:
    - port: 80
      targetPort: 80
      protocol: TCP
  selector:
    app: photo-view
```

```
$ kubectl apply -f Deployment/rollout-depoyment.yaml
deployment.apps/rollout-deployment created
service/rollout created

$ kubectl get pod
NAME                                 READY   STATUS    RESTARTS   AGE
rollout-deployment-d8bf6cb58-2p5wz   1/1     Running   0          48s
rollout-deployment-d8bf6cb58-56mrf   1/1     Running   0          48s
rollout-deployment-d8bf6cb58-bscp8   1/1     Running   0          48s
```

`minikube` 의 경우 `service`의 외부노출 IP를 사용 불가능 함으로 `$ kubectl get services` 명령을 사용해도 `<pending>` 으로밖에 나오지 않는다.  

아래 `minikube service` 명령을 사용해 해당 서비스를 노출시킨다.  

```
$ minikube service rollout
🏃  Starting tunnel for service rollout.
|-----------|---------|-------------|------------------------|
| NAMESPACE |  NAME   | TARGET PORT |          URL           |
|-----------|---------|-------------|------------------------|
| default   | rollout |             | http://127.0.0.1:51768 |
|-----------|---------|-------------|------------------------|
🎉  Opening service default/rollout in default browser...
❗  Because you are using docker driver on Mac, the terminal needs to be open to run it.
```

현재 사용중인 이미지 `photo-view:v1.0` 를 `photo-view:v2.0` 으로 업데이트  

```
$ kubectl apply -f Deployment/rollout-depoyment.yaml
deployment.apps/rollout-deployment configured
service/rollout unchanged

$ kubectl describe deploy rollout-deployment
Name:                   rollout-deployment
Namespace:              default
...
Annotations:            deployment.kubernetes.io/revision: 2
...
Events:
  Type    Reason             Age   From                   Message
  ----    ------             ----  ----                   -------
  Normal  ScalingReplicaSet  41s   deployment-controller  Scaled up replica set rollout-deployment-d8bf6cb58 to 3
  Normal  ScalingReplicaSet  27s   deployment-controller  Scaled up replica set rollout-deployment-6b5ddcb6b7 to 1
```

`describe` 명령으로 출력된 `Annotations` 속성으로 `revision` 값 확인  
해당 디플로이먼트가 몇번 업데이트 되었는지 확이 가능하다.  

`d8bf6cb58 -> 6b5ddcb6b7` 해시의 변경값이다.  

이제 `photo-view:v2.0` 으로 업데이트된 디플로이먼트를 다시 예전버전으로 롤 백해보자.  

첫번째 방법으로 탬플릿 이미지를 `photo-view:v1.0` 로 다시 적용해보자.  

```
kubectl apply -f Deployment/rollout-depoyment.yaml
deployment.apps/rollout-deployment configured
service/rollout unchanged

$ kubectl describe deploy rollout-deployment
...
Annotations:            deployment.kubernetes.io/revision: 3
...

$ kubectl get pod
NAME                                 READY   STATUS    RESTARTS   AGE
rollout-deployment-d8bf6cb58-9nwh5   1/1     Running   0          33s
rollout-deployment-d8bf6cb58-t2f4l   1/1     Running   0          34s
rollout-deployment-d8bf6cb58-tgg57   1/1     Running   0          31s
```

`revision`값은 3이 되었고 해시값은 다시 `d8bf6cb58` 로 돌아갔다.  

디플로이먼트, 리플리카셋, 파드 모두 매니페스트 이력을 가지고 롤아웃/롤백을 진행하고 있기 때문  

이 외에도 현재 사용중인 매니페스트 수정하거나 `kubectl rollout` 명령을 사용해 롤백이 가능하다.  

```
$ kubectl edit deploy rollout-deployment
$ kubectl rollout undo deployment rollout-deployment --to-revision=2 
```

구성관리가 유지되지 않음으로 매니페스트 파일의 갱신(선언적 관리)으로 롤아웃/롤백 하는것을 권장한다.  

## 디플로이먼트 이력 history

```
$ kubectl rollout history deploy rollout-deployment --revision=3
deployment.apps/rollout-deployment with revision #3
Pod Template:
  Labels:	app=photo-view
	pod-template-hash=d8bf6cb58
  Containers:
   photoview-container:
    Image:	ai1.beyless.com:5005/photo-view:v1.0
    Port:	80/TCP
    Host Port:	0/TCP
    Environment:	<none>
    Mounts:	<none>
  Volumes:	<none>

$ kubectl rollout history deploy rollout-deployment --revision=4
deployment.apps/rollout-deployment with revision #4
Pod Template:
  Labels:	app=photo-view
	pod-template-hash=6b5ddcb6b7
  Containers:
   photoview-container:
    Image:	ai1.beyless.com:5005/photo-view:v2.0
    Port:	80/TCP
    Host Port:	0/TCP
    Environment:	<none>
    Mounts:	<none>
  Volumes:	<none>
```

## 블루/그린 디플로이먼트  

서로 다른 2개의 `Deployment`를 각각 생성한다.  

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: blue-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: photo-view
  template:
    metadata:
      labels:
        app: photo-view
        ver: v1.0
    spec:
      containers:
        - image: ai1.beyless.com:5005/photo-view:v1.0
          name: photoview-container
          ports:
            - containerPort: 80
```

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: green-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: photo-view
  template:
    metadata:
      labels:
        app: photo-view
        ver: v2.0
    spec:
      containers:
        - image: ai1.beyless.com:5005/photo-view:v2.0
          name: photoview-container
          ports:
            - containerPort: 80
```



```
$ kubectl apply -f Deployment/blue-deployment.yaml
deployment.apps/blue-deployment created

$ kubectl apply -f Deployment/green-deployment.yaml
deployment.apps/green-deployment created

$ kubectl get pod
NAME                                 READY   STATUS        RESTARTS   AGE
blue-deployment-58d5d4869b-kmn88     1/1     Running       0          19s
blue-deployment-58d5d4869b-vlx2c     1/1     Running       0          19s
blue-deployment-58d5d4869b-w4729     1/1     Running       0          19s
green-deployment-5466fc4568-7hxqp    1/1     Running       0          15s
green-deployment-5466fc4568-mvs2w    1/1     Running       0          15s
green-deployment-5466fc4568-t8hp2    1/1     Running       0          15s
```

그리고 이 `Deployment` 의 `ReplicaSet` 의 `Pod` 에 접근하는 서비스를 작성하고 실행한다.  

```yaml
apiVersion: v1
kind: Service
metadata:
  name: webserver
spec:
  type: LoadBalancer
  ports:
    - port: 80
      targetPort: 80
      protocol: TCP
  selector:
    app: photo-view
    ver: v1.0
```

```
$ kubectl apply -f Deployment/service.yaml
service/webserver created

$ minikube service webserver
🏃  Starting tunnel for service webserver.
|-----------|-----------|-------------|------------------------|
| NAMESPACE |   NAME    | TARGET PORT |          URL           |
|-----------|-----------|-------------|------------------------|
| default   | webserver |             | http://127.0.0.1:53405 |
|-----------|-----------|-------------|------------------------|
🎉  Opening service default/webserver in default browser...
❗  Because you are using docker driver on Mac, the terminal needs to be open to run it.
```

이제 `service.yml` 매니페스트 파일만 수정해서 `blue`, `green` `Deployment` 에 접근할 수 있도록 설정하면 된다.  


# ConfigMap

애플리케이션 설정정보 관리를 위한 쿠버네티스 리소스  

주로 외부 API 키값, 환경변수 등을 별도로 관리하기 위한 리소스이다.  

## ConfigMap 생성방법

아래 2가지 방법을 주로 사용해 컨피그맵을 생성한다.  


### 1. 매니페스트 파일로 만들기 

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
    name: project-config
data:
    project.id: "hello-kubernetes"
    project.name: "world-kubernetes"
```



```
$ kubectl apply -f ConfigMap/configmap.yaml
configmap/project-config created

$ kubectl get configmap
NAME             DATA   AGE
project-config   1      41s

$ kubectl describe configmap project-config
Name:         project-config
Namespace:    default
Labels:       <none>
Annotations:
Data
====
project.id:
----
hello-kubernetes
project.name:
----
world-kubernetes
Events:  <none>
```

### 2. 어플리케이션 config파일 로 만들기


```
$ cat ConfigMap/config/ui.ini
; app에서 사용하는 config 파일
[UI]
color.top = blue
text.size = 10
```

다음과 같은 `ini` 파일이 있을때 이를 사용해 쿠버네티스 ₩ 리소스를 생성하자.  

```
$ kubectl create configmap app-config --from-file=ConfigMap/config/
configmap/app-config created

$ kubectl describe configmap app-config
Name:         app-config
Namespace:    default
Labels:       <none>
Annotations:  <none>

Data
====
ui.ini:
----
; app에서 사용하는 config 파일
[UI]
color.top = blue
text.size = 10

Events:  <none>
```

`file name`을 키값으로 `file content`가 `value` 로 들어갔다.   

## ConfigMap 전달  

컨피그맵을 전달하는 방법은 여러가지다.  


1. `containers.env` 속성으로 전달  
3. `volumes` 으로 전달  



```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: configmap-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: config-view
  template:
    metadata:
      labels:
        app: config-view
    spec:
      containers:
        - image: ai1.beyless.com:5005/photo-view:v3.0
          name: photoview-container
          imagePullPolicy: Always
          ports:
            - containerPort: 80
          env:
            - name: PROJECT_ID
              valueFrom:
                configMapKeyRef:
                  name: project-config
                  key: project.id
          volumeMounts:
            - name: config-volume
              mountPath: /etc/config
      volumes:
        - name: config-volume
          configMap:
            name: app-config
```

`spec` 속성의 `containers.env` 속성을 보면 `project-config` 컨피그맵의 `project.id` 키에 해당하는 `value` 를 `PROJECT_ID` 환경변수로 할당한다.  

`spec` 속성의 `volumes` 속성을 보면 경우 `app-config` 컨피그맵의 정보를 `config-volume` 볼륨에 마운트한다.  

위에서 생성한 파드에 접근할 수 있는 `Service` 리소스를 생성  

```yaml
apiVersion: v1
kind: Service
metadata:
  name: webserver
spec:
  type: LoadBalancer
  ports:
    - port: 80
      targetPort: 80
      protocol: TCP
  selector:
    app: config-view
```

# Secret

비밀번호, 키와 같은 기밀데이터를 다룰때 사용하는 쿠버네티스 리소스  
`Secret` 의 구조는 `ConfigMap` 과 매우 비슷하다.  
단 `etcd` 안에서 암호화된 상태로 관리되는 차이가 있음.  

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: api-key
type: Opaque
data:
  id: ZGJ1c2Vy
  key: YUJjRDEyMw==
```

`data` 의 필드들은 `base64` 로 인코딩된 데이터로 `mac` 의 경우 아래 `base64` 명령어로 인코딩/디코딩 가능하다.  


```
$ echo 'ZGJ1c2Vy' | base64 --decode
dbuser%

$ echo 'YUJjRDEyMw==' | base64 --decode
aBcD123%
```

|설정|설명|
|---|---|
`Opaque` | 일반적인 기밀정보
`kubernetes.io/tls` | `TLS` 정보
`kubernetes.io/dockerconfigjson` | `Docker Registry` 정보
`kubernetes.io/service-account-token` | `Service Account` 정보


> `TLS`: 전송 계층 보안(Transport Layer Security)    
`TLS`는 가장 최신 기술로 더 강력한 버전의 SSL입니다. 그러나 SSL이 더 일반적으로 사용되는 용어이기에, 여전히 보안 인증서는 SSL이라 불립니다.

## Secret 생성, 마운트

컨피그맵과 마찬가지로 `Secret` 도 환경변수, 파일 형태로 마운트 가능하다.  

두개의 시크릿 생성,  
하나는 위의 `yaml` 에서 정의한 `key-value` 형식의 데이터가 들어가 있는 시크릿이고  
하나는 `--from-file` 옵션으로 해당 `Secrets/key/` 위치에 있는 `apl.crt` 파일을 대상으로 시크릿 생성한다.  

```
$ kubectl apply -f Secrets/secrets.yaml

$ kubectl create secret generic apl-auth --from-file=Secrets/key/
secret/apl-auth created
```

생성한 시크릿은 컨피그맵과 마찬가지로 `containers.env`, `volumes` 속성으로 마운트 가능하다.  

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: secret-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: photo-view
  template:
    metadata:
      labels:
        app: photo-view
    spec:
      containers:
        - image: ai1.beyless.com:5005/photo-view:v1.0
          name: photoview-container
          imagePullPolicy: Always
          ports:
            - containerPort: 80
          env:
            - name: SECRET_ID
              valueFrom:
                secretKeyRef:
                  name: api-key
                  key: id
            - name: SECRET_KEY
              valueFrom:
                secretKeyRef:
                  name: api-key
                  key: key
          volumeMounts:
            - name: secrets-volume
              mountPath: /etc/secrets
              readOnly: true
      volumes:
        - name: secrets-volume
          secret:
            secretName: apl-auth
```

실제 생성된 pod 에 접속해 생성된 환경변수로 파일 확인  

```
$ kubectl apply -f Secrets/deployment.yaml
deployment.apps/secret-deployment created

$ kubectl get pods
NAME                                 READY   STATUS    RESTARTS   AGE
secret-deployment-65dd57cfb7-cq2jh   1/1     Running   0          5s
secret-deployment-65dd57cfb7-kcpmv   1/1     Running   0          5s
secret-deployment-65dd57cfb7-v9gql   1/1     Running   0          5s

$ kubectl exec -it secret-deployment-65dd57cfb7-cq2jh -- /bin/bash

root@~# env | grep SECRET*
SECRET_KEY=aBcD123
SECRET_ID=dbuser

root@~# ls /etc/secrets/
apl.crt

root@~# cat /etc/mtab | grep /etc/secrets
tmpfs /etc/secrets tmpfs ro,relatime 0 0
```

> `tmpfs`: 메모리 기반 파일 시스템















