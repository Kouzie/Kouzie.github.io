---
title:  "java IO, NIO!"
read_time: false
share: false
toc: true
toc_sticky: true
author_profile: false

# classes: wide

categories:
  - Java
tags:
  - Java
  - 문법
---

# Java NIO  

`IO`|`NIO`
|---|---|
스트림방식 Non-buffer | 버퍼방식
동기방식 | 동기/비동기 모두 지원
블로킹 방식 | 블록킹/논블록킹 모두 지원

`IO`는 스트림(`Stream`)이라는 **단방향 통로**를 생성해서 외부 데이터와 통신, 연결 클라이언트 수가 적고 대용량, 순차처리에 적합  

`NIO`는 채널(`Channel`)이라는 **양방향 통로**를 생성해서 외부 데이터와 통신, 연결 클라이언트 수가 많고 소규모 빠른 대응에 적합    

![javaio1](/assets/java/java/javaio1.png)  
> https://www.slideshare.net/kslisenko/networking-in-java-with-nio-and-netty-76583794


`자바 NIO (New IO)` 는 기존의 `자바 IO API` 를 대체하기 위해 `java 1.4` 부터 도입

`자바 NIO` 는 다음과 같은 핵심 컴포넌트로 구성되어있습니다.  

* `Selectors`  
* `Channels`  
* `Buffers`  


# 멀티플렉싱 기반의 다중 접속 서버

**입출력 다중화** : 하나의 프로세스 혹은 스레드에서 입력과 출력을 모두 다룰 수 있는 기술을 말합니다. 커널에서는 하나의 스레드가 여러 개의 소켓을 핸들링 할 수 있는 `select`, `poll`, `epoll`과 같은 시스템 콜을 제공하고 있습니다.  

한개의 프로세스 혹은 스레드에서 한개의 클라이언트에 대한 입출력만 처리할 수 있었던 이유는 입출력 함수가 `봉쇄-block` 되었기 때문에, 입출력 데이터가 준비될때까지 무한정 봉쇄되어 여러 클라이언트의 입출력을 처리할 수 없었기 때문입니다.  

그러나 **I/O 멀티플렉싱** 기법을 사용하면 입출력 다중화 에서도 입출력 함수는 여전히 봉쇄로 작동하지만  
입출력 함수를 호출하기전에 어떤 파일에서 입출력이 준비가 되었는지 확인할 수가 있습니다.  

> 봉쇄 (block) : 애플리케이션에서 I/O 작업을 하는 경우 시스템콜이 발생하며 스레드는 데이터 준비가 완료될 때까지 대기합니다. 애플리케이션은 **유저모드-유저버퍼** 에만 접근이 가능하기 때문입니다.  

`listen(), connect(), accept(), recv(), send(), read(), write(), recvfrom(), sento(), close()` - 시스템 콜이 발생할 수 있는함수들
커널 내의 버퍼에 복사된 데이터를 애플리케이션에서 사용하기 위해서는 **커널 버퍼 -> 유저버퍼** 로 복사 후 이용해야 합니다. 
유저버퍼로 복사완료될때 까지 스레드가 봉쇄됩니다.  


## I/O Multiplexing Model

![javaio3](/assets/java/java/javaio3.png)  

`select` 함수를 호출해, 여러개의 소켓들 중 `recvfrom` 이 가능한 소켓이 생길 때까지 대기합니다.  

`select` 의 결과로 `recvfrom`을 호출할 수 있는 소켓의 목록이 반환되면, 해당 소켓들에 대해 `recvfrom`을 호출합니다


## Selectors

![javaio4](/assets/java/java/javaio4.png)  

`자바 NIO` 에는 `selectors` 개념을 포함하고 있습니다.  

`selector` 는 여러개의 채널에서 **이벤트(연결이 생성됨, 데이터가 도착함)** 를 모니터링할 수 있는 객체입니다.  
그래서 하나의 스레드에서 여러 채널에 대해 모니터링이 가능합니다.  

셀렉터에 하나 이상의 채널을 등록한 후에는 `select()` 메소드를 호출할 수 있습니다.  
`select()` 메소드는 `accept, connect, read, write` **이벤트에 대해 준비(ready) 되어 있는 채널을 반환**합니다.  

`select()` - 등록한 이벤트에 대해 하나 이상의 채널이 준비 될 때까지 **봉쇄(block)**됩니다. 몇개의 채널이 준비되었는지 준비된 **채널의 수**를 반환합니다. (마지막으로 `select()`를 호출한 이후 준비된 채널 수 입니다.)  

`select(long timeout)` - 최대 `timeout(ms)` 동안만 봉쇄한다는 점을 제외하면 `select()`와 동일합니다.  

`selectNow()` - select와 달리 봉쇄하지 않습니다. 준비된 채널이 있으면 즉시 반환됩니다.  

`selectedKeys()` - `select()` 메서드를 통해 하나 이상의 준비된 채널이 발생하면, `selectedKeys()` 메서드를 사용해 준비된 채널의 집합을 반환 받습니다.  

```java
while (selector.select() > 0) {
    Iterator<SelectionKey> keyIterator = selector.selectedKeys().iterator();
    while (keyIterator.hasNext()) {
        SelectionKey key = keyIterator.next();
        //키 셋에서 제거.
        keyIterator.remove();
        if (!key.isValid()) continue;
        if (key.isAcceptable()) accept(selector, key); // connection was accepted by a ServerSocketChannel
        else if (key.isConnectable()) System.out.println(""); // connection was established with a remote server
        else if (key.isReadable()) receive(selector, key); // channel is ready for reading
        else if (key.isWritable()) send(selector, key); // channel is ready for writing
    }
}
```

### SelectionKey   

필드로 가지고 있는 구성요소에 대해 알아보자.

#### The interest set - 채널이 확인하고자 하는 이벤트 집합

**이벤트 종류**  
* `SelectionKey.OP_CONNECT`  
* `SelectionKey.OP_ACCEPT`  
* `SelectionKey.OP_READ`  
* `SelectionKey.OP_WRITE`  

```java
int interestSet = selectionKey.interestOps();
boolean isInterestedInAccept  = interestSet & SelectionKey.OP_ACCEPT;
boolean isInterestedInConnect = interestSet & SelectionKey.OP_CONNECT;
boolean isInterestedInRead    = interestSet & SelectionKey.OP_READ;
boolean isInterestedInWrite   = interestSet & SelectionKey.OP_WRITE;
```

#### The ready set - 채널에서 준비되어 처리(handle) 가능한 이벤트의 집합

```java
int readySet = SelectionKey.readyOps();

// 혹은
selectionKey.isAcceptable();
selectionKey.isConnectable();
selectionKey.isReadable();
selectionKey.isWritable();
```

#### The Channel, The Selector

`SelectionKey` 로 `Channel, Selector` 에 접근 가능

```java
Channel  channel  = selectionKey.channel();
Selector selector = selectionKey.selector();
```

#### An attached object (optional)

`SelectionKey`에 객체를 첨부(`attach`)
가 정보나 채널에서 사용하는 버퍼와 같은 객체들을 쉽게 첨부할 수 있음.  

```java
SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);
selectionKey.attach(theObject);
Object attachedObj = selectionKey.attachment();
```

## Channels

`자바 NIO` 의 모든 IO는 `Channel` 로 시작, 

>기존 `자바 IO` 는 `stream`으로 통신함

1. 채널을 통해서는 양방향 (읽고 쓰기) 가능, 스트림은 단방향.  
2. 채널은 비동기적(`asynchronously`)으로 읽고 쓰기 가능.  
3. 채널은 항상 버퍼에서 부터 읽거나 버퍼로 씁니다.  

### Channels 종류  

1. `FileChannel` - 파일에 데이터를 읽고 쓴다.  
2. `DatagramChannel` - UDP를 이용해 네트워크를 통해 데이터를 읽고 쓴다.  
3. `SocketChannel` - TCP를 이용해 네트워크를 통해 데이터를 읽고 쓴다.  
4. `ServerSocketChanel` - 들어오는 TCP 연결을 수신(listening)할 수 있다. 들어오는 연결마다 SocketChannel이 만들어진다.  

## Buffers

자바 NIO에 기본적으로 구현되어 있는 버퍼 목록입니다.

* `Buffers`  
* `ByteBuffer`  
* `MappedByteBuffer`  
* `CharBuffer`  
* `ShortBuffer`  
* `IntBuffer`  
* `LongBuffer`  
* `FloatBuffer`  
* `DoubleBuffer`  

1. 버퍼에 데이터 쓰기 - 쓰기모드  
2. `buffer.flip()` 호출 - 읽기모드로 전환  
3. 버퍼에서 데이터 읽기 - 읽기모드  
4. `buffer.clear()` 혹은 `buffer.compact()` 호출  

> (`clear()` 메서드는 버퍼 전체를 지우고, `compact()` 메서드는 이미 읽은 데이터만 지웁니다.)


## 출처

> https://jongmin92.github.io/2019/02/28/Java/java-with-non-blocking-io/
> https://12bme.tistory.com/231