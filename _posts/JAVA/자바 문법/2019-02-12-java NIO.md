---
title:  "java IO, NIO!"
read_time: false
share: false
toc: true
toc_sticky: true
author_profile: false

# classes: wide

categories:
  - Java
tags:
  - Java
  - 문법
---

# Java NIO  

`IO`|`NIO`
|---|---|
스트림방식 Non-buffer | 버퍼방식
동기방식 | 동기/비동기 모두 지원
블로킹 방식 | 블록킹/논블록킹 모두 지원

`IO`는 스트림(`Stream`)이라는 **단방향 통로**를 생성해서 외부 데이터와 통신, 연결 클라이언트 수가 적고 대용량, 순차처리에 적합  

`NIO`는 채널(`Channel`)이라는 **양방향 통로**를 생성해서 외부 데이터와 통신, 연결 클라이언트 수가 많고 소규모 빠른 대응에 적합    

`자바 NIO (New IO)` 는 기존의 `자바 IO API` 를 대체하기 위해 `java 1.4` 부터 도입

`자바 NIO` 는 다음과 같은 핵심 컴포넌트로 구성되어있습니다.  

* `Selectors`  
* `Channels`  
* `Buffers`  


![javaio1](/assets/java/java/javaio1.png)  
> https://www.slideshare.net/kslisenko/networking-in-java-with-nio-and-netty-76583794

## Non Blokcing and Multiplexing IO 모델

기존의 `Blocking` 모델의 경우 `listen(), connect(), accept(), recv(), send(), read(), write(), recvfrom(), sento(), close()` 등의 함수는 `커널 I/O 버퍼 -> 유저 I/O 버퍼`로 복사 후 이용해야 하기에 복사완료될때 까지 스레드가 봉쇄, 시스템 콜이 발생할 수 있다. 

![javaio5](/assets/java/java/javaio5.png)  

> block(봉쇄) : 애플리케이션에서 I/O 작업을 하는 경우 시스템콜이 발생하며 스레드는 데이터 준비가 완료될 때까지 대기합니다. `유저 I/O 버퍼` 에만 접근이 가능하기 때문입니다.  

입출력 데이터가 준비될때까지 무한정 `block(봉쇄)`되어 여러 클라이언트의 입출력을 처리하려면 스레드를 여러개 만들어야 한다.  

반대로 `Non-Blocking`은 I/O작업을 진행하는 동안 유저 프로세스의 작업을 중단시키지 않는다.  

![javaio6](/assets/java/java/javaio6.png)  

어플리케이션은 반복문을 돌면서 지속적으로 `recvfrom` 함수를 호출해 `커널 I/O 버퍼`에 데이터가 준비되었는지 묻는다.  

데이터가 준비 되었다면 `유저 I/O 버퍼`에 데이터를 복사해주고 성공 반환값을 전달하고  

데이터가 준비되지 않았다면 준비중을 뜻하는 `EWOULDBLOCK` 을 반환한다.  

하지만 이렇게 되면 실제 수신되는 데이터가 없음에도 무한루프를 돌며 버퍼에 데이터 여부를 계속 확인하게 되는데  

이를 방지하기 위해  `I/O Multiplexing` 을 사용한다.  

![javaio7](/assets/java/java/javaio7.png)  

커널에서는 하나의 스레드가 여러 개의 소켓을 핸들링 할 수 있는 `select`, `poll`, `epoll`과 같은 시스템 콜을 제공하고 있으며

`select` 함수를 호출해, 여러개의 소켓들 중 `recvfrom` 이 가능한 소켓이 생길 때까지 `block` 시킨다. 

`select` 의 결과로 `recvfrom`을 호출할 수 있는 **소켓의 목록**이 반환되면, 해당 소켓들에 대해 `recvfrom`을 호출한다.  

`block` 이 발생하긴 하지만 `cpu` 점유율을 높혀 다른 스레드의 스케줄링을 위협하진 않는다.  

## Selectors

![javaio4](/assets/java/java/javaio4.png)  

`자바 NIO` 에는 `selectors` 개념을 포함하고 있습니다.  

`selector` 는 여러개의 채널에서 **이벤트(연결이 생성됨, 데이터가 도착함)** 를 모니터링할 수 있는 객체입니다.  
그래서 하나의 스레드에서 여러 채널에 대해 모니터링이 가능합니다.  

셀렉터에 하나 이상의 채널을 등록한 후에는 `select()` 메소드를 호출할 수 있습니다.  
`select()` 메소드는 `accept, connect, read, write` **이벤트에 대해 준비(ready) 되어 있는 채널을 반환**합니다.  

`select()` - 등록한 이벤트에 대해 하나 이상의 채널이 준비 될 때까지 **봉쇄(block)**됩니다. 몇개의 채널이 준비되었는지 준비된 **채널의 수**를 반환합니다. (마지막으로 `select()`를 호출한 이후 준비된 채널 수 입니다.)  

`select(long timeout)` - 최대 `timeout(ms)` 동안만 봉쇄한다는 점을 제외하면 `select()`와 동일합니다.  

`selectNow()` - select와 달리 봉쇄하지 않습니다. 준비된 채널이 있으면 즉시 반환됩니다.  

`selectedKeys()` - `select()` 메서드를 통해 하나 이상의 준비된 채널이 발생하면, `selectedKeys()` 메서드를 사용해 준비된 채널의 집합을 반환 받습니다.  

```java
while (selector.select() > 0) {
    Iterator<SelectionKey> keyIterator = selector.selectedKeys().iterator();
    while (keyIterator.hasNext()) {
        SelectionKey key = keyIterator.next();
        //키 셋에서 제거.
        keyIterator.remove();
        if (!key.isValid()) continue;
        if (key.isAcceptable()) accept(selector, key); // connection was accepted by a ServerSocketChannel
        else if (key.isConnectable()) System.out.println(""); // connection was established with a remote server
        else if (key.isReadable()) receive(selector, key); // channel is ready for reading
        else if (key.isWritable()) send(selector, key); // channel is ready for writing
    }
}
```

### SelectionKey   

필드로 가지고 있는 구성요소에 대해 알아보자.

#### The interest set - 채널이 확인하고자 하는 이벤트 집합

**이벤트 종류**  
* `SelectionKey.OP_CONNECT`  
* `SelectionKey.OP_ACCEPT`  
* `SelectionKey.OP_READ`  
* `SelectionKey.OP_WRITE`  

```java
int interestSet = selectionKey.interestOps();
boolean isInterestedInAccept  = interestSet & SelectionKey.OP_ACCEPT;
boolean isInterestedInConnect = interestSet & SelectionKey.OP_CONNECT;
boolean isInterestedInRead    = interestSet & SelectionKey.OP_READ;
boolean isInterestedInWrite   = interestSet & SelectionKey.OP_WRITE;
```

#### The ready set - 채널에서 준비되어 처리(handle) 가능한 이벤트의 집합

```java
int readySet = SelectionKey.readyOps();

// 혹은
selectionKey.isAcceptable();
selectionKey.isConnectable();
selectionKey.isReadable();
selectionKey.isWritable();
```

#### The Channel, The Selector

`SelectionKey` 로 `Channel, Selector` 에 접근 가능

```java
Channel  channel  = selectionKey.channel();
Selector selector = selectionKey.selector();
```

#### An attached object (optional)

`SelectionKey`에 객체를 첨부(`attach`)
가 정보나 채널에서 사용하는 버퍼와 같은 객체들을 쉽게 첨부할 수 있음.  

```java
// 3번째 매개변수로 넣거나 아래 attach 메서드 사용
SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject); 
// selectionKey.attach(theObject);
Object attachedObj = selectionKey.attachment();
```

생성된 채널을 selector 에 등록하기 위해 `channel.register` 메서드 호출  

## Channels

`자바 NIO` 의 모든 IO는 `Channel` 로 시작, 

>기존 `자바 IO` 는 `stream`으로 통신함

1. 채널을 통해서는 양방향 (읽고 쓰기) 가능, 스트림은 단방향.  
2. 채널은 비동기적(`asynchronously`)으로 읽고 쓰기 가능.  
3. 채널은 항상 버퍼에서 부터 읽거나 버퍼로 씁니다.  

### Channels 종류  

1. `FileChannel` - 파일에 데이터를 읽고 쓴다.  
2. `DatagramChannel` - UDP를 이용해 네트워크를 통해 데이터를 읽고 쓴다.  
3. `SocketChannel` - TCP를 이용해 네트워크를 통해 데이터를 읽고 쓴다.  
4. `ServerSocketChanel` - 들어오는 TCP 연결을 수신(listening)할 수 있다. 들어오는 연결마다 SocketChannel이 만들어진다.  

## Buffers

자바 NIO에 기본적으로 구현되어 있는 버퍼 목록입니다.

* `Buffers`  
* `ByteBuffer`  
* `MappedByteBuffer`  
* `CharBuffer`  
* `ShortBuffer`  
* `IntBuffer`  
* `LongBuffer`  
* `FloatBuffer`  
* `DoubleBuffer`  

1. 버퍼에 데이터 쓰기 - 쓰기모드  
2. `buffer.flip()` 호출 - 읽기모드로 전환  
3. 버퍼에서 데이터 읽기 - 읽기모드  
4. `buffer.clear()` 혹은 `buffer.compact()` 호출  

> (`clear()` 메서드는 버퍼 전체를 지우고, `compact()` 메서드는 이미 읽은 데이터만 지웁니다.)


## 출처

> https://jongmin92.github.io/2019/02/28/Java/java-with-non-blocking-io/
> https://12bme.tistory.com/231