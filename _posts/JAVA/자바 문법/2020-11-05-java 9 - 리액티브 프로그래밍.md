---
title:  "java 9 - 리액티브 프로그래밍!"
read_time: false
share: false
toc: true
toc_sticky: true
author_profile: false

# classes: wide
categories:
  - Java
tags:
  - Java
  - 문법
---

# 리액티브 프로그래밍  

`java9` 에 추가된 `java.util.concurrent.Flow` 패키지를 사용해 리액티브 프로그래밍이 가능하다.  

> https://grokonez.com/java/java-9-flow-api-reactive-streams 그림으로 설명이 잘되어있음.

`CompletableFuture` 를 사용해 특정 연산일 끝났음을 알리고(발행) 이후에 동작할 연산을 미리 정의(구독) 하는 모델은 간단하지만  

어플리케이션이 커질수록 자바의 객체지향을 사용한 옵저버 패턴으로 변경해야 쉬운 유지보수가 가능하다.  

또한 `RxJava, Akka, Reactor, Vert.x` 등의 서드파티 라이브러리들이 `java9 Flow` 패키지를 사용해 리액티브 프로그래밍을 위한 라이브러리를 개발해 두었다.  


`Publisher`, `Subscriber`, `Subscription`, `Processor` 클래스들로 쉽게 구현할 수 있다.   

![image17](/assets/java/java/image17.png){: .shadow}  

```java
package java.util.concurrent;

public static interface Publisher<T> {
    public void subscribe(Subscriber<? super T> subscriber);
}
```
발행자(`Publisher`) 는 `subscribe()` 메서드로 구독자를 등록할 수 있다.  

```java
public static interface Subscriber<T> {
    public void onSubscribe(Subscription subscription);
    public void onNext(T item);
    public void onError(Throwable throwable);
    public void onComplete();
}
```
`Publisher` 가 발행하는 이벤트에 대한 콜백 메서드 4개  

* `onSubscribe` - 구독시작 콜백  
* `onNext` - 메세지 발행 콜백  
* `onError` - 에러 발행 콜백  
* `onComplete` - 완료 콜백  


```java
public static interface Processor<T,R> extends Subscriber<T>, Publisher<R> {
}
```
`Processor` 는 발행/구독자 상속으로 두가지 역할을 모두 수행한다.  

발행자와 구독자 사이에 껴서 데이터를 재가공 하는 역할이 가능하다.   

## 역압력   

발행자가 구독자에게 데이터를 밀어넣는(`onNext`) 것을 압력이라 한다.  
압력이 무한히 많아지면 시스템에 부담이 가도록 요청했을 때만 압력이 쏟아지도록 하는 것, 압력을 `pull` 하는 것을 역압력이라 한다.  

`Subscription`(신청자) 인터페이스의 `request` 메서드를 사용해 역압력 구현이 가능하다.  

```java
public static interface Subscription {
    public void request(long n);
    public void cancel();
}
```

* `request` - `Publisher` 에게 주어진 개수의 이벤트 처리 준비가 완료됨을 알림  
* `cancel` - 구독 취소

신청자를 통해 `Subscriber` 가 이벤트를 처리할 수 있도록 설정해야 한다.  

아래의 `TempSubscription` 처럼 
`Subscriber` 에서 `onSubscribe(Subscription subscription)` 형식으로 필드에 `Subscription`(신청자) 을 저장해두고  
신청자를 동해 
구독자에게 특정 데이터를 전달하거나 특정 코드(`request`, `cancel`)를 전달할 수 있다.  

![image18](/assets/java/java/image18.png){: .shadow}  

1. 신청자(`Subscription`)가 설정된 공급자(`Publisher`)와 구독자(`Subscriber`) 생
성 및 `subscribe` 메서드로 구독자 등록  
2. 구독과 동시에 구독자의 `onSubscribe` 호출, 구독자에게 신청자 등록  
3. 공급자는 이제 신청자를 통해 공급자에게 이벤트 신청을 할 수 있음  

구독자가 신청자의 `request` 메서드를 통해 몇개 데이터를 처리할지 결정하고 신청자는 공급자로부터 데이터를 가져와 구독자에게 전달한다.  

구독자가 데이터를 땡겨오기에 시스템 압력조절이 가능하다.   

## 발행자 구독자 모델   

```java
public static void main(String[] args) {
    Publisher<TempInfo> newYorkTempPub = new Publisher<TempInfo>() { // 발행자 생성
        @Override
        public void subscribe(Flow.Subscriber<? super TempInfo> subscriber) {
            // 구독자에게 TempSubscription 을 전송
            subscriber.onSubscribe(new TempSubscription(subscriber, "New York"));
        }
    };

    TempSubscriber tempSubscriber = new TempSubscriber();
    newYorkTempPub.subscribe(tempSubscriber);
}
```

발행자를 구독하는 순간 아래와 같은 `onSubscribe()` 메서드가 호출된다.  

```java
public class TempSubscriber implements Subscriber<TempInfo> {

    private Subscription subscription;

    @Override
    public void onSubscribe(Subscription subscription) {
        // 구독 이벤트 실행
        this.subscription = subscription;
        subscription.request(1);
    }
    @Override
    public void onError(Throwable t) {
        System.err.println(t.getMessage()); // 에러 출력
    }
    @Override
    public void onNext(TempInfo tempInfo) {
        System.out.println(tempInfo);
        subscription.request(1);
    }
    @Override
    public void onComplete() {
        System.out.println("Done!");
    }
}
```

`subscription` 의 `request()` 메서드가 호출되고 위에서 생성한  
`new TempSubscription(subscriber, "New York")` 의 `request` 구현 메서드가 호출된다.
구현된 `request` 는 아래와 같다.  

```java
@RequiredArgsConstructor
public class TempSubscription implements Subscription {

    private static final ExecutorService executor = Executors.newSingleThreadExecutor();
    private final Subscriber<? super TempInfo> subscriber;
    private final String town;

    @Override
    public void request(long n) {
        executor.submit(() -> {
            for (long i = 0L; i < n; i++) {
                System.out.println("N:" + n);
                try {
                    subscriber.onNext(TempInfo.fetch(town));
                } catch (Exception e) {
                    subscriber.onError(e);
                    // executor.shutdown();
                    break;
                }
            }
        });
    }
    ...
}
```

`onNext` 를 통해 구독자에게 데이터(메세지)를 발행하고  
예외가 발생하면 `onError` 를 통해 구독자에게 에러를 발행한다.  

위의 `onNext` 내부를 보면 메세지 수신 이벤트를 실행하고 다시 `request` 메서드를 호출함으로 재귀 루프가 형성된다.  

반면 onError 의 경우 에러 출력만 하고 이후의 처리가 없다.  

`TempInfo` 는 아래 참고  

```java
@Getter
@AllArgsConstructor
public class TempInfo {
    private final String town;
    private final int temp;
    public static TempInfo fetch(String town) {
        if (rndBound(10) == 0) { // 10 분의 1 확률로 에러 발생
            throw new RuntimeException("Error!");
        return new TempInfo(town, rndBound(100));
    }
    @Override
    public String toString() { return town + " : " + temp; }
}
```

순서는 간략히 아래와 같다.  

1. `Publisher` 정의  
2. `TempSubscriber` 생성 및 `Publisher` 구독  
3. 구독과 동시에 구독 이벤트 콜백으로 전달한 `TempSubscription` 의 코드(`request`) 실행  
4. `request` 내부에서 `onNext`, `onNext` 내부에서 `request` 를 번갈아가면 무한 재귀 호출  
5. `request` 에러 발생시 `onError` 호출 후 재귀 종료  

맨위의 `main` 을 실행시키면 아래와 같이 실행되다 1/10 확율로 에러가 발생하여 프로그램이 정지된다.

```
N:1
New York : 24
N:1
New York : 1
N:1
New York : 8
N:1
Error!
```

`TempSubscriber` 의 `onNext` 메서드 `TempSubscription` 의 `request` 를 호출하면서 역압력형식으로 구성된다.  
만약 구독자가 많은 시스템 부담을 느낀다면 request 호출을 제거하면 된다.  

# RxJava

## 개요  

넷플릭스에서 리액티브 프로그래밍을 위해 개발한 라이브러리로 `java 9` 이 업데이트 되기 전에 개발되었다.  
`RxJava 2.0` 부터 `Flow` 패키지의 인터페이스를 구현하도록 업데이트 되었으며 많은 기업들이 `java 9` 이 제공한 표준을 사용해 리액티브 프로그래밍 라이브러리를 업데이트 했다.  

### Observable, Observer

```java
package io.reactivex;

public abstract class Observable<T> {...}

public interface Observer<T> {
    void onSubscribe(@NonNull Disposable var1);
    void onNext(@NonNull T var1);
    void onError(@NonNull Throwable var1);
    void onComplete();
}
```

`RxJava` 에선 `Observable` 클래스가 공급자(`Publisher`) 역할  
`Observer` 클래스가 구독자(`Subscriber`) 역할을 한다.  


```java
// 1 초 간격으로 long 값을 1에서 무한 증가 값을 방출
Observable<Long> onePerSec = Observable.interval(1, TimeUnit.SECONDS);

// 한개 이상의 요소를 방출하는 Observable 생성
Observable<String> strings  = Observable.just("first", "second");
// onNext("first"), onNext("second"), onComplete() 가 차례대로 호출됨
```

다양한 방법으로 `Observable`(공급자) 생성 가능하고 구독자 인터페이스에서 `onNext` 메서드만 구현하면 바로 `Observable` 을 `Observer` 에 등록 가능하다.  

아래처럼 `ON_ERROR_MISSING`, `EMPTY_ACTION`, `Functions.emptyConsumer()` 와같은 클래스 내부에 정의해둔 `Consumer` 객체들을 사용해 `Observer` 의 `onNext` 를 제외한 `onError`, `onComplete`, `onSubscribe` 를 구현해주기 때문  

```java
public final Disposable subscribe(Consumer<? super T> onNext) {
    return this.subscribe(onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION, Functions.emptyConsumer());
}
```

유연하게 구독자 생성이 가능하다.  

`subscribe` 오버라이딩 메서드는 모두 `Disposable` 객체를 반환한다.  

```java
package io.reactivex.disposables;

public interface Disposable {
    void dispose();
    boolean isDisposed();
}
```

`dispose()` 메서드는 `Observable`(공급자) 가 더이상 데이터를 발행하지 않도록 구독관계를 해지하는 역할을 하며 `Observable` 의 `Observer` 의 `onComplete` 를 호출할때 자동으로 같이 호출된다.  


```java
// 0 ~ 1 초 간격으로 long 값을 무한 증가 값을 방출
Observable<Long> onePerSec = Observable.interval(1, TimeUnit.SECONDS);
onePerSec.subscribe(i -> {
    System.out.println("num:" + i);
    if (i == 3)
        throw new IllegalArgumentException("number is three");
});
System.out.println("test success");
Thread.sleep(10000); 
// rxjava 에서 제공하는 스레드풀의 데몬 스레드로 실행되기에 sleep 으로 main 이 종료되지 않도록 설정 
// blockingSubscribe 사용하면 main 스레드로 subscribe 하지만 영원히 끝나지 않음
```

증가된 `long` 값이 3이 되면 에러를 반환  

```
io.reactivex.exceptions.OnErrorNotImplementedException: 
    The exception was not handled due to missing onError handler in the subscribe() method call. 
Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | number is three
```

### RxJava 를 사용한 발행자 구독자 모델

구독자(`Subscriber`)에 해당하는 `Observer` 생성

위의 `TempSubscriber` 에 대응되는 `TempObserver` 정의


```java
public class TempObserver implements Observer<TempInfo> {
    @Override
    public void onSubscribe(Disposable disposable) {
    }
    @Override
    public void onError(Throwable t) {
        System.err.println(t.getMessage()); // 에러 출력
    }
    @Override
    public void onNext(TempInfo tempInfo) {
        System.out.println(tempInfo);
    }
    @Override
    public void onComplete() {
        System.out.println("Done!");
    }
}
```

`TempSubscriber` 와 다르게 `onSubscribe` 와 `onNext` 부분에 역압력을 담당하는 `request` 호출문이 없다.  
또한 신청자(`Subscription`)를 필드로 저장하지도 않는다.  


그다음엔 공급자(`Publisher`)에 해당하는 `Observable` 생성


```java
public static void main(String[] args) {
    String town = "NewYork";
    Observable<TempInfo> observable = Observable.create(new ObservableOnSubscribe<TempInfo>() {
        @Override
        public void subscribe(@NonNull ObservableEmitter<TempInfo> observableEmitter) throws Exception {
            Observable.interval(1, TimeUnit.SECONDS).subscribe(i -> { //매초마다 1 ~ n long 방출
                if (!observableEmitter.isDisposed()) {  // 구독자가 폐기되지 않았다면 수행
                    if (i >= 5) observableEmitter.onComplete(); // 구독자 완료처리
                    else {
                        try { observableEmitter.onNext(TempInfo.fetch(town)); }
                        catch (Exception e) { observableEmitter.onError(e); }
                    }
                }
            });
        }
    });
    observable.subscribe(new TempObserver());
    try { Thread.sleep(10000L); } 
    catch (InterruptedException e) { throw new RuntimeException(e); }
}
```

```출력값
NewYork : 88
NewYork : 34
NewYork : 97
NewYork : 20
NewYork : 30
Done!
```


## Observalble 

위에서 간단하게 `RxJava` 의 발행/구독 클래스, 메서드를 살펴보았는데 좀더 자세히 알아보자.  

### create

함수원형

```java
public static <T> Observable<T> create(ObservableOnSubscribe<T> source) {
    ObjectHelper.requireNonNull(source, "source is null");
    return RxJavaPlugins.onAssembly(new ObservableCreate<T>(source));
}
```

개발자가 `onNext, onComplete, onError` 등의 메서드를 직접 호출하는 수동적인 `Observable` 생성 방법

매개변수로 사용되는 `ObservableOnSubscribe` 인터페이스에는 하나의 메서드만 정의되어 있고    

```java
public interface ObservableOnSubscribe<T> {
    void subscribe(@NonNull ObservableEmitter<T> var1) throws Exception;
}
```
`ObservableEmitter` 인터페이스는 아래와 같은 같다.  

```java
public interface Emitter<T> {
    void onNext(@NonNull T var1);
    void onError(@NonNull Throwable var1);
    void onComplete();
}

public interface ObservableEmitter<T> extends Emitter<T> {
    @NonNull
    ObservableEmitter<T> serialize();
    void setDisposable(@Nullable Disposable var1);
    void setCancellable(@Nullable Cancellable var1);
    boolean isDisposed();
    boolean tryOnError(@NonNull Throwable var1);
}
```

> http://reactivex.io/RxJava/javadoc/io/reactivex/ObservableEmitter.html  
`Emitter` 상속하여 구독자역할을 할 수 있는 인터페이스이다.  

```java
public static void main(String[] args) {
    Observable<String> observable = Observable.create(emitter -> {
        emitter.onNext("hello");
        emitter.onNext("world");
        emitter.onNext("one");
        emitter.onNext("two");
        emitter.onNext("three");
        emitter.onComplete();
    });
    Disposable disposable = observable.subscribe(s -> System.out.println(s)); // 데이터 발행 시작
    System.out.println(disposable.isDisposed()); // true
}
```



### fromArray, fromIterable

배열과 컬렉션 객체기반으로 `Observable` 생성  

```java
public static void main(String[] args) {
    List<String> stringList = new ArrayList<>();
    stringList.add("one");
    stringList.add("two");
    stringList.add("three");
    String[] stringArray = {"four", "five", "six"};
    Observable<String> observable1 = Observable.fromIterable(stringList);
    Observable<String> observable2 = Observable.fromArray(stringArray);
    Observable.merge(List.of(observable1, observable2))
            .subscribe(s -> System.out.println(s));
}
```

### formCallable, fromFuture, fromPublisher

`Callable` - `java5` 추가된 매개변수는 없고 반환값은 존재하는 함수형 인터페이스로 `Supplier` 와 비슷
`Publisher` - `java9` 에 추가된 Flow.Publisher 와 똑같은 형식의 인터페이스이지만 rxjava 패키지에서 재구성되어 `org.reactivestreams` 패키지를 사용해야함  

```java
public interface Callable<V> {
    V call() throws Exception;
}
```

해당 반환값을 기반으로 `Observable` 생성  

```java
public static void main(String[] args) {
        Callable<String> callable = () -> {
            System.out.println("callable invoked");
            return "hello";
        };
        Future<String> future = Executors.newSingleThreadExecutor().submit(() -> {
            System.out.println("future invoked");
            return "world";
        });
        Publisher<String> publisher = (s) -> {
            s.onNext("welcome");
            s.onComplete();
        };
        Observable<String> observable1 = Observable.fromCallable(callable);
        Observable<String> observable2 = Observable.fromFuture(future);
        Observable<String> observable3 = Observable.fromPublisher(publisher);
        Observable.merge(List.of(observable1, observable2, observable3))
                .subscribe(s -> System.out.println(s));
    }
```

### interval, intervalRange, timer

`interval` 메서드로 일정 시간 간격으로 데이터 발행하는 발행자 생성  

```java
// long initialDelay, long period, TimeUnit unit
public static void main(String[] args) throws InterruptedException {
    Observable observable = Observable.interval(1000l, 100l, TimeUnit.MILLISECONDS)
        .map(data -> {
            System.out.println("interval:" + data);
            return (data + 1) * 100;
        })
        .take(5);
    observable.subscribe(System.out::println);
    Thread.sleep(3000);
}
// 출력결과
// interval:0
// 100
// interval:1
// 200
// interval:2
// 300
// interval:3
// 400
// interval:4
// 500
```

1초 후부터 0.1초마다 데이터 발행, `take` 를 통해 5개 까지만 발행.  
`interval`은 데이를 지속적으로 발행 가능하다.  

```java
public static void main(String[] args) throws InterruptedException {
    Observable<Long> observable = Observable.intervalRange(1, 9,
            2000l, 1000l, TimeUnit.MILLISECONDS);
    observable.subscribe(System.out::println);
    Thread.sleep(15000);
}
```

`range` 와 `interval` 를 합친 메서드로 2초 후 1초마다 9회 발행한다.  


`timer` 메서드로 일정 시간 후에 데이터를 발행하는 발행자 생성  

```java
public static void main(String[] args) throws InterruptedException {
    Observable<Long> observable = Observable.timer(2000l, TimeUnit.MILLISECONDS)
        .map(data -> data);
    observable.subscribe(System.out::println); // 0
    Thread.sleep(3000);
}
```

2초 후 데이터를 1회 발행한다.  

### defer

일반적인 `Observable` 의 발행시점은 구독자가 `subscribe` 하면서 데이터가 생성되지만 새로운 구독자가 `subscribe`(추가)된다고 데이터를 다시 발행하지 않는다.  

`defer` 를 사용하면 구독자가 `subscribe` 할때마다 새로운 데이터를 다시 만들어 발행한다.  

![image29](/assets/java/java/image29.png)  

그림처럼 시간별로 발행 데이터 색이 변경되어야 하는 경우 사용할 수 있다.  

```java
public static void main(String[] args) throws InterruptedException {
    Observable<LocalTime> observable = Observable.defer(() -> Observable.just(LocalTime.now()));
    observable.subscribe(i -> System.out.println("subscribe1:" + i));
    Thread.sleep(3000);
    observable.subscribe(i -> System.out.println("subscribe2:" + i));
    Thread.sleep(3000);
    observable.subscribe(i -> System.out.println("subscribe3:" + i));
}
// 출력결과
// subscribe1:05:39:15.161997
// subscribe2:05:39:18.180470
// subscribe3:05:39:21.184535
```

구독자가 `subscribe` 할 때 마다 시간값이 변경되는 것으로 보아 새로운 LocalTime 이 생성된다.  

```java
public static void main(String[] args) throws InterruptedException {
    Observable<LocalTime> observable = Observable.just(LocalTime.now());
    observable.subscribe(i -> System.out.println("subscribe1:" + i));
    Thread.sleep(3000);
    observable.subscribe(i -> System.out.println("subscribe2:" + i));
    Thread.sleep(3000);
    observable.subscribe(i -> System.out.println("subscribe3:" + i));
}
// 출력결과 
// subscribe1:05:38:58.197359
// subscribe2:05:38:58.197359
// subscribe3:05:38:58.197359
```

반면에 `just` 메서드로 일반적인 `Observable` 생성시 새로운 `LocalTime` 을 만들지는 않는다.  

### repeat  

말 그대로 지정된 횟수만큼 발행 데이터를 반복 발행

```java
public static void main(String[] args) {
    Observable<Integer> observable = Observable.range(1, 3).repeat(3);
    observable.subscribe(System.out::print);
}
// 출력결과
// 123123123
```

반복회수 제거시 `Long.MAX_VALUE` 횟수만큼 반복한다.  

```java
public static void main(String[] args) throws InterruptedException {
    Observable<LocalTime> observable = Observable.timer(2, TimeUnit.SECONDS)
            .map(i -> LocalTime.now())
            .repeat();
    observable.subscribe(System.out::println);
    Thread.sleep(10000);
}
// 출력결과
// 05:53:27.620033
// 05:53:29.622134
// 05:53:31.627118
// 05:53:33.631298
```

`timer` 와 `repeat` 를 같이 사용해 `interval` 처럼 사용할 수 있다.  

하지만 `repeat` 는 발행 시퀀스가 종료되면 해당 발행자의 스레드를 종료하고 새로운 발행자(스레드)를 만들어 구독자를 재등록하기에 약간 다르다.  


### 뜨거운 Observable, 차가운 Observable

`subscribe` 메서드가 호출되기 전까진 데이터를 발행하지 않는 구조를 차가운 `Observable` 이라 한다(Lazy 접근법).  

위의 `interval, timer` 발행자도 예외 없이 구독자가 ₩ 해야 시간을 체크하고 데이터를 발행하기 시작한다.  

반면 뜨거운 `Observable` 은 구독 여부 상관 없이 데이터를 발행하며, 이로 인해 앞부분 데이터를 유실될 수 있다.  

웹요청, DB쿼리, 파일 입출력은 차가운 `Observable`    
마우스, 키보드, 센서 입출력은 뜨거운 `Observable` 를 사용한다.  

### ConnectableObservable

뜨거운 `Observable` 생성시 사용하는 클래스  

```java
public abstract class ConnectableObservable<T> extends Observable<T> {
}
```

![image25](/assets/java/java/image25.png)  

뜨거운 `Observable` 인 `ConnectableObservable` 은 `Observable` 의 `publish` 메서드 를 통해 생성되며  
`ConnectableObservable` 의 `connect` 메서드 호출 전까지는 데이터 발행을 하지 않는다.   
반대로 `connect` 메서드가 호출되었다면 구독자가 없더라도 데이터가 발행된다.   

```java
public static void main(String[] args) throws InterruptedException {
    Observable<Integer> observable = Observable.interval(1000l, TimeUnit.MILLISECONDS)
            .map(Long::intValue);
    ConnectableObservable<Integer> connObservable = observable.publish();
    connObservable.connect(); // data 발행 시작
    Thread.sleep(3500);
    connObservable.subscribe(i -> System.out.println("subscribe1:" + i));
    connObservable.subscribe(i -> System.out.println("subscribe2:" + i));
    Thread.sleep(3500);
    connObservable.subscribe(i -> System.out.println("subscribe3:" + i));
    Thread.sleep(3500);
}
// 출력결과
// subscribe1:4
// subscribe2:4
// subscribe1:5
// subscribe2:5
// subscribe1:6
// subscribe2:6
// subscribe1:7
// subscribe2:7
// subscribe1:8
// subscribe2:8
// subscribe3:8
// subscribe1:9
// subscribe2:9
// subscribe3:9
// subscribe1:10
// subscribe2:10
// subscribe3:10
```

출력결과에서 `subscribe1,2` 가 출력되는 시기는 3.5초 뒤 `connect` 메서드가 가 호출된 인 4번째 부터이다.  
3.5초 뒤 `subscribe3` 에서 출력되기 시작하고 프로그램이 살아있는 3.5초 동안 세번의 인터벌을 더 출력하고 종료된다.  

## 기타 발행자 클래스 

### Single, Maybe

`Single` - `Observable` 의 변형 클래스로 똑같은 기능을 하나 발행 데이터가 하나임.  

```java
public abstract class Observable<T> implements ObservableSource<T> {
    ...
}
public interface ObservableSource<T> {
    void subscribe(@NonNull Observer<? super T> observer);
}

public abstract class Single<T> implements SingleSource<T> {
    ...
}
public interface SingleSource<T> {
    void subscribe(@NonNull SingleObserver<? super T> observer);
}
```

클래스명만 다르지 내부 구조는 매우 비슷  

여러 방법으로 생성 가능하다.  

```java
public static void main(String[] args) {
    Observable source = Observable.just("hello");
    Single single1 = Single.fromObservable(source);
    Single single2 = Observable.just("world").single("default value");
    Single single3 = Observable.just("one", "two", "three").first("default value");
    Single.merge(single1, single2, single3).subscribe(System.out::println);
}
```

`Single` 의 경우 최소, 최대 1개 데이터를 발행하기에 `default value` 가 필요하지만  
`Maybe` 의 경우 최소 0개, 최대 1개 데이터를 발행 할 수 있다.  


### Subject

발행자와 구독자 2가지 기능을 가진 클래스이다.  

```java
public abstract class Subject<T> extends Observable<T> implements Observer<T> {
}
```


### AsyncSubject  

Subject 클래스의 하위 클래스로 발행이 완료되기 전 마지막 데이터만 처리한다(`onComplete` 호출후 마지막 데이터).  

![image21](/assets/java/java/image21.png)  

```java
public static void main(String[] args) {
    Subject<String> subject = AsyncSubject.create();
    subject.subscribe(s -> System.out.println("subscribe1:" + s));
    subject.onNext("hello");
    subject.subscribe(s -> System.out.println("subscribe2:" + s));
    subject.onNext("one");
    subject.onComplete();
    subject.subscribe(s -> System.out.println("subscribe3:" + s));
    subject.onNext("two");
    subject.onComplete();
    subject.subscribe(s -> System.out.println("subscribe4:" + s));
}
// 출력결과
// subscribe1:one
// subscribe2:one
// subscribe3:one
// subscribe4:one
```

그림처럼 2개의 구독자를 정의 및 `subscribe` 로 등록하고 `onComplete` 호출시에 발행자는 마지막 데이터를 구독자에게 전달한다.  

`onComplete` 이후의 `onNext, onComplete` 는 무시됨으로 영향을 끼치지 않는다.  
이미 `onComplete` 가 호출되었음에도 `subscribe` 된 구독자에게 마지막 데이터를 계속 발행한다.  

`Subject` 는 `Observer` 를 구현함으로 `Observable` 의 `subscribe` 에 등록 가능하다.  

```java
public static void main(String[] args) {
    Observable<String> observable = Observable.fromArray("one", "two", "three");
    AsyncSubject subject = AsyncSubject.create();
    subject.subscribe(s -> System.out.println("subscriber1:" + s));
    subject.subscribe(s -> System.out.println("subscriber2:" + s));
    observable.subscribe(subject);
}
// 출력결과
// subscriber1:three
// subscriber2:three
```


### BehaviorSubject

가장 최근값 혹은 기본값을 발행하는 발행자 겸 구독자.  

![image22](/assets/java/java/image22.png)  

반드시 `onComplete` 를 호출하지 않아도 데이터를 지속적으로 발행한다.  
`onComplete` 되었다면 그 이후에 `subscribe` 된 구독자는 무시된다.  

```java
public static void main(String[] args) {
    Subject<String> subject = BehaviorSubject.create();
    // 기본값 적용시에는 createDefault 사용
    subject.subscribe(s -> System.out.println("subscribe1:" + s));
    subject.onNext("hello");
    subject.subscribe(s -> System.out.println("subscribe2:" + s));
    subject.onNext("one");
    subject.onComplete();
    subject.subscribe(s -> System.out.println("subscribe3:" + s));
    subject.onNext("two");
    subject.onComplete();
    subject.subscribe(s -> System.out.println("subscribe4:" + s));
}
// 출력결과
// subscribe1:hello
// subscribe2:hello
// subscribe1:one
// subscribe2:one
```

### PublishSubject

일반적인 발행자 클래스,  

![image23](/assets/java/java/image23.png)  

발행시 `subscribe` 된 구독자에게 데이터 발행, `onComplete` 이후 등록된 구독자는 무시함.  


### ReplaySubject

뜨거운 `Observable` 로 동작시키기 위한 발행자 모델  

![image24](/assets/java/java/image24.png)  

지금까지 발행했던 데이터를 신규 `subscribe` 된 구독자에게 모두 전달  
메모리 누수 가능성 있음.  

```java
public static void main(String[] args) {
    Subject<String> subject = ReplaySubject.create();
    subject.subscribe(s -> System.out.println("subscribe1:" + s));
    subject.onNext("hello");
    subject.subscribe(s -> System.out.println("subscribe2:" + s));
    subject.onNext("one");
    subject.onComplete();
    subject.subscribe(s -> System.out.println("subscribe3:" + s));
    subject.onNext("two");
    subject.onComplete();
    subject.subscribe(s -> System.out.println("subscribe4:" + s));
}
// 출력결과
// subscribe1:hello
// subscribe2:hello
// subscribe1:one
// subscribe2:one
// subscribe3:hello
// subscribe3:one
// subscribe4:hello
// subscribe4:one
```

`onComplete` 이후 `subscribe` 된 구독자에게도 발행한 데이터를 모두 전달  


## Observable 연산자

`Observable`은 발행 데이터 변경(`map`), 합치기(`merge`), 필터링(`filter`), 개수만큼 가져오기(`take`) 할수 있는 다양한 체이닝 형식의 메서드를 제공한다.  


`Flow` 패키지의 `Processor` 는 발행과 구독 기능을 동시에 하는 인터페이스로 발행자와 구독자 사이에서 발행되는 데이터를 변환하는 기능을 수행한다.  

`RxJava` 도 `ObservableMap` 를 사용하면 발행되는 데이터를 자유자재로 변환할 수 있다.  
심지어 여러개의 `Observable` 를 하나의 `Observable` 로 합쳐서 `ObservableMap` 객체로 제공한다.  

위의 `Observable.create` 은 사실 단순 `Observable` 를 반환하지 않고 `ObservableMap` 를 반환하여 `stream` 객체처럼 발행자와 구독자 사이의 `Processor` 를 정의한것 처럼 행동할 수있다.  

### map, merge, filter, take

![image19](/assets/java/java/image19.png)  

![image20](/assets/java/java/image20.png)  


```java
public static void main(String[] args) {
    Observable<String> observable1 = Observable.create((ObservableOnSubscribe<String>) observableEmitter -> {
        observableEmitter.onNext("hello");
        observableEmitter.onNext("world");
        observableEmitter.onNext("one");
        observableEmitter.onNext("two");
        observableEmitter.onNext("three");
        observableEmitter.onComplete();
    });
    Observable<String> observable2 = Observable.create((ObservableOnSubscribe<String>) observableEmitter -> {
        observableEmitter.onNext("test");
        observableEmitter.onNext("command");
        observableEmitter.onNext("four");
        observableEmitter.onNext("five");
        observableEmitter.onNext("six");
        observableEmitter.onComplete();
    });
    Observable.merge(List.of(observable1, observable2))
            .map(String::toUpperCase)
            .filter(s -> s.length() > 3)
            .take(3)
            .subscribe(s -> System.out.println(s));
}
// 출력결과
// HELLO
// WORLD
// THREE
```

2개의 발행자를 하나로 합치고(`merge`) 소문자를 대문자로 변경(`map`), 3글자 이상의 데이터만 필터(`filter`) 하여 위에서 3개 데이터만 가져와(`take`) 데이터 발행   

### zip, zipWith

`merge` 가 두개의 `Observable` 을 하나로 합치는 거라면  
`zip` 은 각 `Observable` 의 요소를 하나로 합친다  

```java
public static void main(String[] args) {
    String[] strings1 = {"one", "two", "three", "four"};
    String[] strings2 = {"first", "second", "third"};
    Observable<String> observable = Observable.zip(
            Observable.fromArray(strings1),
            Observable.fromArray(strings2),
            (string1, string2) -> string1 + "-" + string2);
    observable.subscribe(System.out::println);
}
// 출력결과
// one-first
// two-second
// three-third
```

두 발행자의 요소 개수가 달라 먼저 `onComplete` 가 호출된다면 근접 발행자도 같이 종료된다.  

이미 생성된 `Observable` 에 새로운 `Observable` 의 요소를 합칠땐 zipWith 메서드를 사용하는게 편하다.  

```java
public static void main(String[] args) {
    String[] strings1 = {"one", "two", "three", "four"};
    String[] strings2 = {"first", "second", "third"};
    String[] strings3 = {"hello", "rx", "java", "reactive"};
    Observable<String> observable = Observable
        .zip(Observable.fromArray(strings1),
            Observable.fromArray(strings2),
            (string1, string2) -> string1 + "-" + string2)
        .zipWith(Observable.fromArray(strings3),
            (string1, string2) -> string1 + "-" + string2);
    observable.subscribe(System.out::println);
}
// 출력결과
// one-first-hello
// two-second-rx
// three-third-java
```

### combineLatest

![image32](/assets/java/java/image32.png)  

2개 이상의 `Observable` 를 연관지어 새로운 데이터가 발행될 때 마다 요소를 엮어 구독자에게 다시 발행한다.  

```java
public static void main(String[] args) throws InterruptedException {
    String[] strings1 = {"one", "two", "three", "four"};
    String[] strings2 = {"first", "second", "third"};
    Observable<String> observable = Observable.combineLatest(
        Observable.fromArray(strings1)
            .zipWith(Observable.interval(1000L, TimeUnit.MILLISECONDS),
                (s, notUsed) -> s),
        Observable.fromArray(strings2)
            .zipWith(Observable.interval(1500L, TimeUnit.MILLISECONDS),
                (s, notUsed) -> s),
        (s1, s2) -> s1 + "-" + s2);
    observable.subscribe(System.out::println);
    Thread.sleep(10000);
}
// 출력결과
// one-first
// two-first
// three-first
// three-second
// four-second
// four-third
```

두개 `Observable` 중 하나라도 요소가 발행되면 각 `Observable` 의 최신 요소를 결합하여 반환한다.  

### concat

2개 이상의 `Observable` 를 이어 붙이는 메서드, 첫번째 `Observable` 이 종료되어야 두번째 `Observable` 이 진행된다.  

```java
public static void main(String[] args) throws InterruptedException {
    String[] strings1 = {"one", "two", "three", "four"};
    String[] strings2 = {"first", "second", "third"};
    Observable<String> observable = Observable.concat(
        Observable.fromArray(strings2)
            .zipWith(Observable.interval(1000L, TimeUnit.MILLISECONDS),
                (s, notUsed) -> s),
        Observable.fromArray(strings1)
            .zipWith(Observable.interval(1500L, TimeUnit.MILLISECONDS),
                (s, notUsed) -> s));
    observable.subscribe(System.out::println);
    Thread.sleep(10000);
}
```

### flatMap

![image26](/assets/java/java/image26.png)  

`map` 과 같이 데이터 가공을 위한 메서드  

그림을 보면 원 하나당 마름모 2개를 발행하는데  
`stream` 의 `flatMap` 과 같이 내부의 요소가 단일 데이터가 아닌 `Observable` 일 경우    
`Observable` 의 발행 데이터(마름모 2개)를 끄집어 내서 구독자에게 전달할 수 있도록 한다.  

```java
public static void main(String[] args) throws InterruptedException {
    Observable<String> observable = Observable.fromArray("one", "two", "three");
    Function<String, Observable<String>> modifyString = s -> Observable.just(s + "*", s + "#");
    observable.flatMap(modifyString).subscribe(System.out::println);
}
// 출력결과
// one*
// one#
// two*
// two#
// three*
// three#
```

> `Function` 은 `java8` 의 함수형 인터페이스와 똑같은 형식의 `reactivex` 패키지의 인터페이스이다.  

위 코드로 문자열 1개 집어 넣으면 뒤에 `*, #` 을 붙인 문자열 2개 발행한다.  

간단한 구구단 기능을 `flatMap` 으로 구현  

```java
public static void main(String[] args) {
    Function<Integer, Observable<String>> gugudan = dan -> Observable
            .range(1, 9)
            .map(row -> dan + "*" + row + "=" + dan * row);
    Observable<String> observable = Observable.just(9).flatMap(gugudan);
    observable.subscribe(System.out::println); // 9단 출력
}
// 출력결과
// 9*1=9
// 9*2=18
// 9*3=27
// 9*4=36
// 9*5=45
// 9*6=54
// 9*7=63
// 9*8=72
// 9*9=81
```

단을 넣으면 9개의 새로운 문자열 데이터가 발행된다.  

### concatMap  

`flatMap` 과 같이 다중 요소를 처리하는 map 메서드이지만 `flatMap` 과 다르게 순차적으로 처리하는 특징이 있다.

```java
public static void main(String[] args) throws InterruptedException {
    System.out.println("start:" + LocalTime.now());
    Observable<LocalTime> observable = Observable.interval(1000l, TimeUnit.MILLISECONDS)
        .map(time -> LocalTime.now())
        .take(5)
        .flatMap(now -> Observable.interval(2000l, TimeUnit.MILLISECONDS)
            .map(notUsed -> now)
            .take(2));
    observable.subscribe(now -> System.out.println(now.getMinute() + ":" + now.getSecond()));
    Thread.sleep(30000);
}
// 출력 결과
// 14:29
// 14:30
// 14:31
// 14:29
// 14:32
// 14:30
// 14:33
// 14:31
// 14:32
// 14:33
```

첫번째 발행자는 1초마다 현재 시간값을 5번 행하고  
두번째 발행자는 2초마다 첫번째 발행자에게 받은 시간값을 다시 2번 발행한다.  

총 10번 데이터가 발행되는데 출력결과를 보면 `flatMap` 안에 있는 두번째 발행자가 데이터를 받는 순가 바로 처리하기에  
2초 유격 사이에 1초마다 쏟아지는 데이터를 바로 발행해버린다.  

`flatMap` 을 그대로 `concatMap` 으로 변환하면 아래와 같이 출력된다.  

```java
public static void main(String[] args) throws InterruptedException {
    System.out.println("start:" + LocalTime.now());
    Observable<LocalTime> observable = Observable.interval(1000l, TimeUnit.MILLISECONDS)
        .map(time -> LocalTime.now())
        .take(5)
        .concatMap(now -> Observable.interval(2000l, TimeUnit.MILLISECONDS)
            .map(notUsed -> now)
            .take(2));
    observable.subscribe(now -> System.out.println(now.getMinute() + ":" + now.getSecond()));
    Thread.sleep(30000);
}
// 출력결과
// 16:46
// 16:46
// 16:47
// 16:47
// 16:48
// 16:48
// 16:49
// 16:49
// 16:50
// 16:50
```

데이터를 받더라도 두번째 발행자의 발행이 완료되지 않았다면 그 이후의 데이터를 발행하지 않고 기다린다.  
(물론 첫번째 발행자의 데이터는 5초동안 발행이 모두 완료된다)

### switchMap

`concatMap` 이 순서 보장을 위해 데이터를 발행하지 않고 대기한다면  
`switchMap` 은 순서 보장을 위해 기존에 진행중이던 작업을 중단하고 새로 들어온 작업을 진행한다.   

![image29](/assets/java/java/image29.png)  

그림처럼 `3` 데이터 발행 후 바로 `5` 발행될 경우 기존 작업을 취소하고 `5` 에 대한 작업을 수행한다.  

```java
public static void main(String[] args) throws InterruptedException {
    System.out.println("start:" + LocalTime.now());
    Observable<LocalTime> observable = Observable.interval(1000l, TimeUnit.MILLISECONDS)
        .map(time -> LocalTime.now())
        .take(5)
        .switchMap(now -> Observable.interval(2000l, TimeUnit.MILLISECONDS)
            .map(notUsed -> now)
            .take(2));
    observable.subscribe(now -> System.out.println(now.getMinute() + ":" + now.getSecond()));
    Thread.sleep(30000);
}
// 출력결과
// 20:6
// 20:6
```

위 예제를 그대로 `switchMap` 으로 변경시 마지막 데이터만 정상 처리되고 이전 발행 데이터는 모두 취소되어 버린다.  

### reduce

![image27](/assets/java/java/image27.png)  

`stream` 의 `reduce` 와 같이 재귀적인 구조를 가지며 발행되는 데이터를 모아 같이 처리할 수 있다.  

```java
public static void main(String[] args) {
    Maybe<Integer> observable = Observable.range(1, 9).reduce((i, j) -> i + j);
    observable.subscribe(System.out::println);
}
// 출력결과
// 45
```

> 반환하는 발행자 타입이 `Maybe` 이며 이는 발행 데이터가 있을수도, 없을수도 있음을 뜻한다.  

### scan

![image31](/assets/java/java/image31.png)  

그림을 보면 `reduce` 와 비슷하지만 데이터 발행 건수가 다른것을 알 수 있다.  
반환값 또한 `Observable`  

```java
public static void main(String[] args) {
    Observable<Integer> observable = Observable.range(1, 9).reduce((i, j) -> i + j);
    observable.subscribe(System.out::println);
}
// 출력결과
// 1
// 3
// 6
// 10
// 15
// 21
// 28
// 36
// 45
```

### groupBy

![image30](/assets/java/java/image30.png)  

```java
public static void main(String[] args) {
    Observable<GroupedObservable<Boolean, Integer>> observable = Observable.fromArray(1, 2, 3, 4, 5, 6)
        .groupBy(i -> i % 2 == 0)
        .filter(groupedObservable -> groupedObservable.getKey() == false);

    observable.subscribe(groupedObservable -> groupedObservable
        .subscribe(val -> System.out.println(val)));
}
// 출력결과
// 1
// 3
// 5
```

입력된 데이터를 `groupBy` 로 짝/홀 로 분류, `filter` 로 홀수에 해당하는 데이터만 걸러낸다.  

발행되는 요소를 보면 `GroupedObservable` 이다.  

```java
public abstract class GroupedObservable<K, T> extends Observable<T> {
    final K key;
    protected GroupedObservable(@Nullable K key) {
        this.key = key;
    }
    @Nullable
    public K getKey() {
        return key;
    }
}
```

`key` 필드를 갖는 새로운 발행자이며 2차원 배열처럼 `subscribe` 로 하나씩 벗겨가며 `groupBy` 된 데이터에 접근할 수 있다.  
