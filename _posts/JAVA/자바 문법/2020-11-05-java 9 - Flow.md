---
title:  "java 9 - Flow, RxJava!"
read_time: false
share: false
toc: true
toc_sticky: true
author_profile: false

# classes: wide
categories:
  - Java
tags:
  - Java
  - 문법
---

# 리액티브 프로그래밍  

`java9` 에 추가된 `java.util.concurrent.Flow` 패키지를 사용해 리액티브 프로그래밍이 가능하다.  

> https://grokonez.com/java/java-9-flow-api-reactive-streams 그림으로 설명이 잘되어있음.

`CompletableFuture` 를 사용해 특정 연산일 끝났음을 알리고(발행) 이후에 동작할 연산을 미리 정의(구독) 하는 모델은 간단하지만  

어플리케이션이 커질수록 자바의 객체지향을 사용한 옵저버 패턴으로 변경해야 쉬운 유지보수가 가능하다.  

또한 `RxJava, Akka, Reactor, Vert.x` 등의 서드파티 라이브러리들이 `java9 Flow` 패키지를 사용해 리액티브 프로그래밍을 위한 라이브러리를 개발해 두었다.  


`Publisher`, `Subscriber`, `Subscription`, `Processor` 클래스들로 쉽게 구현할 수 있다.   

![image17](/assets/java/java/image17.png){: .shadow}  

```java
package java.util.concurrent;

public static interface Publisher<T> {
    public void subscribe(Subscriber<? super T> subscriber);
}
```
발행자(`Publisher`) 는 `subscribe()` 메서드로 구독자를 등록할 수 있다.  

```java
public static interface Subscriber<T> {
    public void onSubscribe(Subscription subscription);
    public void onNext(T item);
    public void onError(Throwable throwable);
    public void onComplete();
}
```
`Publisher` 가 발행하는 이벤트에 대한 콜백 메서드 4개  

* `onSubscribe` - 구독시작 콜백  
* `onNext` - 메세지 발행 콜백  
* `onError` - 에러 발행 콜백  
* `onComplete` - 완료 콜백  


```java
public static interface Processor<T,R> extends Subscriber<T>, Publisher<R> {
}
```
`Processor` 는 발행/구독자 상속으로 두가지 역할을 모두 수행한다.  

발행자와 구독자 사이에 껴서 데이터를 재가공 하는 역할이 가능하다.   


### 역압력   

발행자가 구독자에게 데이터를 밀어넣는(`onNext`) 것을 압력이라 한다.  
압력이 무한히 많아지면 시스템에 부담이 가도록 요청했을 때만 압력이 쏟아지도록 하는 것, 압력을 `pull` 하는 것을 역압력이라 한다.  

`Subscription`(신청자) 인터페이스의 `request` 메서드를 사용해 역압력 구현이 가능하다.  

```java
public static interface Subscription {
    public void request(long n);
    public void cancel();
}
```

* `request` - `Publisher` 에게 주어진 개수의 이벤트 처리 준비가 완료됨을 알림  
* `cancel` - 구독 취소

신청자를 통해 `Subscriber` 가 이벤트를 처리할 수 있도록 설정해야 한다.  

아래의 `TempSubscription` 처럼 
`Subscriber` 에서 `onSubscribe(Subscription subscription)` 형식으로 필드에 `Subscription`(신청자) 을 저장해두고  
신청자를 동해 
구독자에게 특정 데이터를 전달하거나 특정 코드(`request`, `cancel`)를 전달할 수 있다.  

![image18](/assets/java/java/image18.png){: .shadow}  

1. 신청자(`Subscription`)가 설정된 공급자(`Publisher`)와 구독자(`Subscriber`) 생
성 및 `subscribe` 메서드로 구독자 등록  
2. 구독과 동시에 구독자의 `onSubscribe` 호출, 구독자에게 신청자 등록  
3. 공급자는 이제 신청자를 통해 공급자에게 이벤트 신청을 할 수 있음  

구독자가 신청자의 `request` 메서드를 통해 몇개 데이터를 처리할지 결정하고 신청자는 공급자로부터 데이터를 가져와 구독자에게 전달한다.  

구독자가 데이터를 땡겨오기에 시스템 압력조절이 가능하다.   

## 발행자 구독자 모델   

```java
public static void main(String[] args) {
    Publisher<TempInfo> newYorkTempPub = new Publisher<TempInfo>() { // 발행자 생성
        @Override
        public void subscribe(Flow.Subscriber<? super TempInfo> subscriber) {
            // 구독자에게 TempSubscription 을 전송
            subscriber.onSubscribe(new TempSubscription(subscriber, "New York"));
        }
    };

    TempSubscriber tempSubscriber = new TempSubscriber();
    newYorkTempPub.subscribe(tempSubscriber);
}
```

발행자를 구독하는 순간 아래와 같은 `onSubscribe()` 메서드가 호출된다.  

```java
public class TempSubscriber implements Subscriber<TempInfo> {

    private Subscription subscription;

    @Override
    public void onSubscribe(Subscription subscription) {
        // 구독 이벤트 실행
        this.subscription = subscription;
        subscription.request(1);
    }
    @Override
    public void onError(Throwable t) {
        System.err.println(t.getMessage()); // 에러 출력
    }
    @Override
    public void onNext(TempInfo tempInfo) {
        System.out.println(tempInfo);
        subscription.request(1);
    }
    @Override
    public void onComplete() {
        System.out.println("Done!");
    }
}
```

`subscription` 의 `request()` 메서드가 호출되고 위에서 생성한  
`new TempSubscription(subscriber, "New York")` 의 `request` 구현 메서드가 호출된다.
구현된 `request` 는 아래와 같다.  

```java
@RequiredArgsConstructor
public class TempSubscription implements Subscription {

    private static final ExecutorService executor = Executors.newSingleThreadExecutor();
    private final Subscriber<? super TempInfo> subscriber;
    private final String town;

    @Override
    public void request(long n) {
        executor.submit(() -> {
            for (long i = 0L; i < n; i++) {
                System.out.println("N:" + n);
                try {
                    subscriber.onNext(TempInfo.fetch(town));
                } catch (Exception e) {
                    subscriber.onError(e);
                    // executor.shutdown();
                    break;
                }
            }
        });
    }
    ...
}
```

`onNext` 를 통해 구독자에게 데이터(메세지)를 발행하고  
예외가 발생하면 `onError` 를 통해 구독자에게 에러를 발행한다.  

위의 `onNext` 내부를 보면 메세지 수신 이벤트를 실행하고 다시 `request` 메서드를 호출함으로 재귀 루프가 형성된다.  

반면 onError 의 경우 에러 출력만 하고 이후의 처리가 없다.  

`TempInfo` 는 아래 참고  

```java
@Getter
@AllArgsConstructor
public class TempInfo {
    private final String town;
    private final int temp;
    public static TempInfo fetch(String town) {
        if (rndBound(10) == 0) { // 10 분의 1 확률로 에러 발생
            throw new RuntimeException("Error!");
        return new TempInfo(town, rndBound(100));
    }
    @Override
    public String toString() { return town + " : " + temp; }
}
```

순서는 간략히 아래와 같다.  

1. `Publisher` 정의  
2. `TempSubscriber` 생성 및 `Publisher` 구독  
3. 구독과 동시에 구독 이벤트 콜백으로 전달한 `TempSubscription` 의 코드(`request`) 실행  
4. `request` 내부에서 `onNext`, `onNext` 내부에서 `request` 를 번갈아가면 무한 재귀 호출  
5. `request` 에러 발생시 `onError` 호출 후 재귀 종료  

맨위의 `main` 을 실행시키면 아래와 같이 실행되다 1/10 확율로 에러가 발생하여 프로그램이 정지된다.

```
N:1
New York : 24
N:1
New York : 1
N:1
New York : 8
N:1
Error!
```

`TempSubscriber` 의 `onNext` 메서드 `TempSubscription` 의 `request` 를 호출하면서 역압력형식으로 구성된다.  
만약 구독자가 많은 시스템 부담을 느낀다면 request 호출을 제거하면 된다.  

## RxJava
  
넷플릭스에서 리액티브 프로그래밍을 위해 개발한 라이브러리로 `java 9` 이 업데이트 되기 전에 개발되었다.  
`RxJava 2.0` 부터 `Flow` 패키지의 인터페이스를 구현하도록 업데이트 되었으며 많은 기업들이 `java 9` 이 제공한 표준을 사용해 리액티브 프로그래밍 라이브러리를 업데이트 했다.  

### Observable  


```java
package io.reactivex;

public abstract class Observable<T> {...}
```

`RxJava` 에선 `Observable` 클래스가 공급자(`Publisher`) 역할을 한다.  


```java
// 1 초 간격으로 long 값을 1에서 무한 증가 값을 방출
Observable<Long> onePerSec = Observable.interval(1, TimeUnit.SECONDS);

// 한개 이상의 요소를 방출하는 Observable 생성
Observable<String> strings  = Observable.just("first", "second");
// onNext("first"), onNext("second"), onComplete() 가 차례대로 호출됨
```

다양한 방법으로 공급자 생성 가능  


### Observer


```java
package io.reactivex;

public interface Observer<T> {
    void onSubscribe(@NonNull Disposable var1);
    void onNext(@NonNull T var1);
    void onError(@NonNull Throwable var1);
    void onComplete();
}
```

`RxJava` 에선 `Observer` 클래스가 구독자(`Subscriber`) 역할을 한다.  

구독자 인터페이스에서 `onNext` 메서드만 구현하면 바로 `Observable` 에 등록 가능하다.  

아래처럼 `ON_ERROR_MISSING`, `EMPTY_ACTION`, `Functions.emptyConsumer()` 와같은 클래스 내부에 정의해둔 `Consumer` 객체들을 사용해 `Observer` 의 `onNext` 를 제외한 `onError`, `onComplete`, `onSubscribe` 를 구현해주기 때문  

```java
public final Disposable subscribe(Consumer<? super T> onNext) {
    return this.subscribe(onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION, Functions.emptyConsumer());
}
```

아래와 같이 유연하게 구독자 생성이 가능하다.  

```java
// 0 ~ 1 초 간격으로 long 값을 무한 증가 값을 방출
Observable<Long> onePerSec = Observable.interval(1, TimeUnit.SECONDS);
onePerSec.subscribe(i -> {
    System.out.println("num:" + i);
    if (i == 3)
        throw new IllegalArgumentException("number is three");
});
System.out.println("test success");
Thread.sleep(10000); 
// rxjava 에서 제공하는 스레드풀의 데몬 스레드로 실행되기에 sleep 으로 main 이 종료되지 않도록 설정 
// blockingSubscribe 사용하면 main 스레드로 subscribe 하지만 영원히 끝나지 않음
```

증가된 `long` 값이 3이 되면 에러를 반환  

```
io.reactivex.exceptions.OnErrorNotImplementedException: 
    The exception was not handled due to missing onError handler in the subscribe() method call. 
Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | number is three
```

### RxJava 를 사용한 발행자 구독자 모델

구독자(`Subscriber`)에 해당하는 `Observer` 생성

위의 `TempSubscriber` 에 대응되는 `TempObserver` 정의


```java
public class TempObserver implements Observer<TempInfo> {
    @Override
    public void onSubscribe(Disposable disposable) {
    }
    @Override
    public void onError(Throwable t) {
        System.err.println(t.getMessage()); // 에러 출력
    }
    @Override
    public void onNext(TempInfo tempInfo) {
        System.out.println(tempInfo);
    }
    @Override
    public void onComplete() {
        System.out.println("Done!");
    }
}
```

`TempSubscriber` 와 다르게 `onSubscribe` 와 `onNext` 부분에 역압력을 담당하는 `request` 호출문이 없다.  
또한 신청자(`Subscription`)를 필드로 저장하지도 않는다.  


그다음엔 공급자(`Publisher`)에 해당하는 `Observable` 생성


```java
public static void main(String[] args) {
    String town = "NewYork";
    Observable<TempInfo> observable = Observable.create(new ObservableOnSubscribe<TempInfo>() {
        @Override
        public void subscribe(@NonNull ObservableEmitter<TempInfo> observableEmitter) throws Exception {
            Observable.interval(1, TimeUnit.SECONDS).subscribe(i -> { //매초마다 1 ~ n long 방출
                if (!observableEmitter.isDisposed()) {  // 구독자가 폐기되지 않았다면 수행
                    if (i >= 5) observableEmitter.onComplete(); // 구독자 완료처리
                    else {
                        try { observableEmitter.onNext(TempInfo.fetch(town)); }
                        catch (Exception e) { observableEmitter.onError(e); }
                    }
                }
            });
        }
    });
    observable.subscribe(new TempObserver());
    try { Thread.sleep(10000L); } 
    catch (InterruptedException e) { throw new RuntimeException(e); }
}
```

```출력값
NewYork : 88
NewYork : 34
NewYork : 97
NewYork : 20
NewYork : 30
Done!
```

`ObservableOnSubscribe`, `ObservableEmitter` 처음보는 개체 2개에 대해 알아보자.  

```java
public interface ObservableOnSubscribe<T> {
    void subscribe(@NonNull ObservableEmitter<T> var1) throws Exception;
}
```

`subscribe` 메서드 하나만 있는것이 `Flow.Publisher` 처럼 생겼다.  

실제로도 `Observable.create` 메서드는 공급자를 만들기 위한 메서드로 구독자 등록시 특정 행위를 하도록 메서드를 구성한다.  


`ObservableEmitter` 는 아래와 같다.  

```java
public interface ObservableEmitter<T> extends Emitter<T> {
    @NonNull
    ObservableEmitter<T> serialize();
    void setDisposable(@Nullable Disposable var1);
    void setCancellable(@Nullable Cancellable var1);
    boolean isDisposed();
    boolean tryOnError(@NonNull Throwable var1);
}
```

내부의 `Disposable` 객체를 사용해 해당 구독자가 더이상의 메세지 처리 기능이 폐기되었는기 확인한다.  

```java
package io.reactivex.disposables;

public interface Disposable {
    void dispose();
    boolean isDisposed();
}
```

`Emitter` 상속하여 구독자역할을 할 수 있는 인터페이스이다.  

```java
package io.reactivex;

public interface Emitter<T> {
    void onNext(@NonNull T var1);
    void onError(@NonNull Throwable var1);
    void onComplete();
}
```

> `Observer` 의 `void onSubscribe(@NonNull Disposable var1);` 가 빠진 형태, 서로 비슷한 기능을 함.  

`ObservableEmitter` 는 `Disposable`(처분여부) 설정 메서드로 해당 구독자가 폐기되었는지 확인한다. `onComplete` 가 호출되면 자동 폐기된다. 
> http://reactivex.io/RxJava/javadoc/io/reactivex/ObservableEmitter.html  


### ObservableMap

발행자(`Observable`)를 변형, 합치기

`Flow` 패키지의 `Processor` 는 발행과 구독자 기능동시에 하는 인터페이스를 사용해 발행자와 구독자 사이에서 발행되는 데이터를 변환하는 기능을 수행한다.  

`RxJava` 도 `ObservableMap` 를 사용하면 발행되는 데이터를 자유자재로 변환할 수 있다.  
심지어 여러개의 `Observable` 를 하나의 `Observable` 로 합쳐서 `ObservableMap` 객체로 제공한다.  

위의 `Observable.create` 은 사실 단순 `Observable` 를 반환하지 않고 `ObservableMap` 를 반환하여 `stream` 객체처럼  
발행자와 구독자 사이의 `Processor` 를 정의한것 처럼 행동할 수있다.  

```java
public static void main(String[] args) {
    Observable<String> observable = Observable.create((ObservableOnSubscribe<String>) observableEmitter -> {
        observableEmitter.onNext("hello");
        observableEmitter.onNext("world");
        observableEmitter.onComplete();
    }).map(String::toUpperCase);
    observable.subscribe(s -> System.out.println(s));
}
```

출력값

```
HELLO
WORLD
```

리액티브 스트림 라이브러리에서 제공하는 그림을 통해서 RxJava 의 함수를 그림으로 표기할 수 있다.  

![image19](/assets/java/java/image19.png){: .shadow}  

merge 를 사용하면 여러개의 발행자를 하나로 합쳐 하나의 구독자가 처리할 수 있게 한다.  

```java
public static void main(String[] args) {
    Observable<String> observable1 = Observable.create((ObservableOnSubscribe<String>) observableEmitter -> {
        observableEmitter.onNext("hello");
        observableEmitter.onNext("world");
        observableEmitter.onNext("one");
        observableEmitter.onNext("two");
        observableEmitter.onNext("three");
        observableEmitter.onComplete();
    });
    Observable<String> observable2 = Observable.create((ObservableOnSubscribe<String>) observableEmitter -> {
        observableEmitter.onNext("test");
        observableEmitter.onNext("command");
        observableEmitter.onNext("four");
        observableEmitter.onNext("five");
        observableEmitter.onNext("six");
        observableEmitter.onComplete();
    });
    Observable.merge(List.of(observable1, observable2))
            .map(String::toUpperCase)
            .filter(s -> s.length() > 3)
            .subscribe(s -> System.out.println(s));
}
```

```
HELLO
WORLD
THREE
TEST
COMMAND
FOUR
FIVE
```

![image20](/assets/java/java/image20.png){: .shadow}  

RxJava 에 대해선 향후 더 알아볼 예정.