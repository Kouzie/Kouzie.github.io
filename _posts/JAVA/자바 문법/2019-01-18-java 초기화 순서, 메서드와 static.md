---
title:  "java 초기화 순서, 메서드와 static!"
read_time: false
share: false
toc: true
author_profile: false

classes: wide
categories:
  - Java
tags:
  - Java
  - 문법
---

## 클래스 멤버 변수(필드)의 초기화 순서

### 일반 멤버 변수
기본값 초기화 &rarr; 명시적 초기화 &rarr; 인스턴스 블럭 초기화 &rarr; 생성자 초기화  

맨 앞에서 뒤로 수행되기 때문에 앞에서 초기화 된건 덮어씌어진다.  

### 정적변수 초기화 순서
기본값 초기화 &rarr; 명시적 초기화 &rarr; 스태틱 블럭 초기화  
스태틱 초기화 블럭은 클래스가 메모리로 올라갈때(거의 프로그램 시작, 클래스 로딩시) 딱 한번 실행된다.  

참고로 `static`키워드로 선언한 변수들을  
`static`변수, 클래스 변수, 정적변수, `static`필드, `shared`변수 라고 부른다.  

----------------------------------------------------------------------------------------------------

## 메서드에 static 붙이면 좋은일

메서드 앞에 `static`을 붙이는 이유는 다음과 같다  
1. private `static` 변수에 `static` 메서드(`getter`, `setter`)로 접근하기 위해서  
2. 자주 사용하는 메소드를 편하게 사용하기 위해서  

객체를 인스턴스로 만들지 않고도 `클래스명.static메소드명()` 으로 호출할 수 있다.  
물론 `static`메소드 정보는 프로그램 시작(클래스 로딩시) 과 동시에 올라간다.  

참고로 `static`메소드 안에서는 `this`참조변수를 사용 못한다, 인스턴스 변수도 마찬가지.   

`static`메소드는 인스턴스가 생성되기도 전에 메모리에 올라가는 함수인데 인스턴스의 주소를 참조하는 `this`나 인스턴스 필드를
사용할 수가 없다.  

하지만 살다보면 `static`메소드에서 생성된 인스턴스에 접근하거나 인스턴스 필드에 접근하고싶을때가 있다.  
아래 사이트 참조 (비록 C++ 내용이지만 자바에서도 되지 않을까)  
> https://gazam.tistory.com/entry/C-클래스-static-맴버-함수를-사용할-때-this포인터-사용하기

----------------------------------------------------------------------------------------------------

## 얕은복제와 깊은복제 (얕은복사와 깊은복사)

클래스 `Test`란 놈이 멤버 변수로 **참조변수**(객체, 배열)을 갖고 있을때  (참조변수 이름을 `m`으로 하자)  
두개의 인스턴스를 만들고  
```java
Test t1 = new Test(); 
Test t2 = new Test();
t1.m = new int[10]; //m은 배열이고 동적할당해서 힙에 공간을 할당해주었다.
t1.m = t2.m 
```
`t1`의 `m`과 `t2`의 `m`은 **힙의 같은공간 공유**하는 상황이 발생한다. (얕은복제)  

깊은복제를 하려면  
```java
t2.m = new int[10];
t2.m[0] = t1.m[0];
....
t2.m[9] = t1.m[9]; 
```
`new int`로 별도의 힙 공간을 할당 해주어야 함 

----------------------------------------------------------------------------------------------------

## 싱글톤(Singleton Pattern)  -  디자인 패턴 - 오직 하나만의 인스턴스만 만들겠다!

단 하나만의 인스턴스를 생성해서 사용하겠다.  
전체 프로그램 상에서 [단 하나만의 객체] 만 만들도록(생성) 보장하는 패턴  
`new` 연산자로 객체생성이 안된다! (생성자는 고의로 막아 놓을거 거든!)  

DB를 연동해주는 커넥션 객체같은 경우 여러개 만들면 오히려 오류가 발생하기 떄문에 하나만 만들야한다  
이렇게 하나만 결정권을 쥐는게 더 나은 경우 싱글톤 패턴으로 디자인 하는것이 좋다.  
```java
class DBConnection
{
	//private  DBConnection connection; 
	//이녀석은 getter setter만들어도 쓸모없다. 어차피 생성자가 private으로 돼있어서 인스턴스화 못함
	//인스턴스화 시킬만한 static메서드를 만들어주자, getInstance!
	//일단 메인함수에서 생성자를 통해 인스턴스를 만들지 않고 바로 getInstance호출해야 하기 때문에 static메소드를 사용해야 하고
	//static메소드이기때문에 connection도 static으로 바꿔줘야한다.
	private static DBConnection connection;
	
	public static DBConnection getInstance()
	{
		//만약 이미 connection이 생성되었다면 다시 생성하지 않고 반환하기만함.
		if(connection == null)
			connection = new DBConnection();
		
		return connection;
	}
	
	private DBConnection()
	{
		//싱글톤에선 생성자로 계속 새로운 인스턴스를 생성못하게 막아두었습니다.
		//오직 getInstance를 통해 하나의 인스턴스만을 만들 수 있습니다.
	}
}

public static void main(String[] args) {
		DBConnection con1 = DBConnection.getInstance();
		DBConnection con2 = DBConnection.getInstance();
		DBConnection con3 = DBConnection.getInstance();
		
		System.out.println(con1);
		System.out.println(con2);
		System.out.println(con3);
	}
```
여러개 만들더라고 모든 객체가 하나의 인스턴스를 가리키고있다.  

Calender라는 클래스가 위의 방식으로 코딩되어있다.  
```Calender cal = new Calender();``` <-- 이거 오류난다.  
```Calender cal = Calender.getInstance();``` <-- 이렇게 쓰라고 설명문에 쓰여있다.  

싱글톤 패턴은 멀티스레드 환경에서 문제가 발생할 수 있다, `synchronized` 키워드를 사용하면 쉽게 해결 가능하겠지만 성능은 포기해야 한다.  

https://medium.com/@joongwon/multi-thread-환경에서의-올바른-singleton-578d9511fd42

```java
public class Singleton {
  private Singleton() {}
  public static Singleton getInstance() {
    return LazyHolder.INSTANCE;
  }
  
  private static class LazyHolder {
    private static final Singleton INSTANCE = new Singleton();  
  }
}
```
LazyHolder기법을 사용하면 멀티스레드 환경에서도 안전하고 빠르게 사용가능하다 한다.  

기존에는 static 키워드를 사용해 싱글톤으로 생성할 객체를 코드가 메모리에 올라감과 동시에 생성하였는데 위 코드대로라면 `getInstance`메서드 호출시 생성된다.  

JVMd에서 객체를 사용시에 생성하기 때문에 메모리관점에서도 이득이고 JVMd에서 `Thread Safe`하게 객체를 관리한다고 한다.  


----------------------------------------------------------------------------------------------------

## 상속  -  객체지향 필수 아이템

상속이란 기존 클래스 재사용해서 새로운 클래스 작성할때 사용하는 문법  

**상속장점**   
적은 코딩으로 새로운 클래스 작성 사능 -&rarr; 재활용하니까! 생산성도 높아지고 유지보수도 쉬워짐  

공통적으로 코드를 관리 &rarr; 상위클래스가 바뀌면 하위클래스가 물려받는것도 자동으로 바뀌어서 물려받음  

**헷갈리는 명칭**  
|물려받는클래스|물려주는클래스|
|---|---|
|자식|부모|
|하위|상위|
|파생|기반|

### UML
개발자간의 의사소통을 원활하게 하기 위해 표준화한 모델링 언어  
그림을 그려서 클래스 관계도를 명확히 알수 있게 해준다.  

이중에서 `Use case Diagram`, `Sequence Diagram`, `Class Diagram`은 많이 쓴다.  


----------------------------------------------------------------------------------------------------

## 상속과 생성자

생성자는 따로 상속되지 않지만 하위클래스는 상위클래스의 필드를 초기화해줄 의무가 있다.  

하위클래스 생성자에 상위클래스 생성자 호출문이 있어도 되지만   
따로 호출문을 코딩하지 않아도 자바 컴파일러가 알아서 상위 클래스 생성자를 먼저 호출해준다.  

하위 객체가 만들어 질때 먼저 상위 객체의 필드와 메소드가 메모리에 올라가고 생성자 호출후  
하위 객체의 필드와 메소드가 따라 올라가고 생성자가 호출된다.  

하위 생성자에서 상위생성자의 값을 초기화 해줄때 만약 디폴트 생성자에 초기화 안해놓으면
어떻게 상위객체의 필드를 초기화할 수 있을까?  

`super()` 를 사용하면 된다.  
부모 인스턴스를 참조하는 참조변수로 부모 생성자를 호출하겠단 뜻이다  
`super(num1, num2)` 이런식으로 사용 가능.  

----------------------------------------------------------------------------------------------------

## 오버로딩과 오버 라이딩

부모에서 상속 받았는데 상속 받은 함수가 맘에 안들어서 다르게 바꾸고 싶다면  
오버로딩이나 오버라이딩으로 다르게 바꿀 수 있다(덮어 씌우는 개념).  

인자개수, 인자 타입을 다르게 해서 정의하면 오버 로딩이고  
인자개수와 인자타입 모두 부모에게 상속받은것과 같은데 내용이 다르다면 오버 라이딩이라 한다.  

### 오버라이딩 재정의 규칙!

접근지정자는 똑같거나 부모클래스보다 범위가 넒어야 한다.  
만약 부모 메소드가 `public`이면 자식도 무조건 `public` 써야하고  
부모 메소드가 `private`이면 자식은 `private`, `protected`, `default`, `public` 골라쓸 수 있다.  


오버라이딩 하기위해 자동추가하면 메소드 위에 `@Override` 키워드가 붙는다.  
에너테이션(annotation)이라 하는데 주석 메모라는 뜻이다.   
`java.lang.annotation`패키지에 포함되어있다.   
이건 프로그래머 보기 편하라고 만들어지는 것이 아니라 자바 컴파일러에게 통보하는 것이다.  
이 메소드가 오버로딩된것이라 명시적으로 알리고 오타나 에러를 방지한다.  

>참고: `protected`키워드가 정확히 하는 역할을 혼동할 때 가 많은데 기본적으로 default가 같은 기능을 하며 자신의 하위클래스에게도 접근을 혀용한다.  

----------------------------------------------------------------------------------------------------


## 상속에서 final

클래스 앞에 `final`키워드가 붙으면 자식을 가질수 없는 최종 클래스란 뜻이다.  

메소드 앞에 `final`키워드가 붙으면 더이상 오버라이딩 할 수 없는 최종 메소드란 뜻이다.  

필드 앞에 붙으면 그냥 변경할수 없는 상수화 시키는것..(상속이랑 관계 X)  
`final` 변수를 초기화 할수 있는 방법은 여러가지다.    
1. final변수 선언과 동시에 초기화 하는 방법  
2. 생성자에서 초기화 하는 방법.  
3. 초기화 블럭에서 초기화 하는 방법.  


물론 생성자에서 초기화 할때 이렇게 하면 오류난다.  
```java
class A
{
	final int t;
	A()
	{
		t=100;
	}
	A(int num)
	{
		this();
		//t = 200; //오류발생, t가 두번 초기화됨.
	}
}
```