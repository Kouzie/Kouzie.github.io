---
title:  "DB 2일차!"

header:
  overlay_image: /assets/DB/dbimage.jpg
  caption: "Photo credit: [**oracle**](https://www.oracle.com)"

read_time: false
share: false
author_profile: false
# classes: wide

categories:
  - DataBase
---



## CREATE TABLE

TABLE은 **ROW(행)와 COLUMN(열)**로 구성되어 있다.

TABLE 생성 방법

1. 테이블을 만드는 가장 단순하면서도 일반적인 명령 형식으로 만드는 방법  
2. Subquery를 이용한 table 생성  
3. NESTED TABLE 생성  
4. Partitioned Tables & Indexes 생성  
5. Extend table 생성  
6. External table 생성  

테이블 만드는 방법만 6개….  

### 테이블을 만드는 가장 단순하면서도 일반적인 명령 형식으로 만드는 방법

CREATE TABLE 문에 일반적인 명령형식으로 만드는 방법

#### 형식
```sql
 CREATE [GLOBAL TEMPORARY] TABLE [schema.] table
 ( 
       열이름  데이터타입 [DEFAULT 표현식] [제약조건] 
       [,열이름  데이터타입 [DEFAULT 표현식] [제약조건] ] 
       [,...]  
 );
```

테이블을 만들기 전엔 기술서를 작성하는게 좋다.
![image3](/assets/DB/days08/image3.png){: .shadow}  

위처럼 기술서를 대충 만들고 테이블을 생성해보자.  

**테이블 명세서: 회원테이블**

**컬럼명**|**자료형**|**디폴트값**|**널허용**|**제약조건**
:-----:|:-----|:-----|:-----|:-----
아이디|varchar2(20)| |X|PK(기본키) 
이름|varchar2(10)| |X| 
나이|number(3)| |X| 
생년월일|date| |O| 
가입일|date|sysdate|O| 

```sql
CREATE TABLE tbl_member
(
     id       VARCHAR2(20) NOT NULL PRIMARY KEY
    ,name     VARCHAR2(10) NOT NULL
    ,age      NUMBER
    ,birth    DATE
    ,regdate  DATE DEFAULT SYSDATE
);
```
![image4](/assets/DB/days08/image4.png){: .shadow}  
<br><br>


### Subquery를 이용한 table 생성

말 그대로 서브쿼리를 사용해서 새로운 테이블을 생성.

#### 형식
```sql
CREATE TABLE 테이블명 [컬럼명 (,컬럼명),...]
AS subquery;
```

emp 테이블을 통해 tbl_emp테이블 생성!  

```sql
CREATE TABLE tbl_emp
AS
SELECT deptno, empno, ename, hiredate
FROM emp;
```
![image5](/assets/DB/days08/image5.png){: .shadow}  

테이블의 컬럼명 생략시 서브쿼리의 컬럼명으로 적용된다.  

자료형 또한 emp의 정보가 그대로 반영된다.  
안의 데이터 또한 emp의 데이터가 그대로 저장됨.  

단 제약조건 정보까지는 복사되지 않는다.  
```sql
SELECT * FROM user_constraints
WHERE table_name = 'EMP';
```
![image6](/assets/DB/days08/image6.png){: .shadow}  

emp테이블의 제약조건 2개가 나오지만 tbl_emp는 제약조건이 없다.  
(서브쿼리로 만든 테이블이니 당연)  


30번 부서의 데이터만 담은 tbl_emp30 이라는 테이블을 만들고 싶다면 WHERE절을 사용해 조건을 주면 된다.  

```sql
CREATE TABLE tbl_emp30 
AS
SELECT deptno, empno, ename, hiredate
FROM emp
WHERE deptno = 30;
```

칼럼명이 마음에 안든다면 CREATE TABLE 뒤에 칼럼명을 지정해줘도 되지만 alias로 칼럼명을 바꿀 수 도 있다.  

```sql
CREATE TABLE tbl_emp10
AS
SELECT empno AS no, ename, sal + NVL(comm, 0) pay
FROM emp
WHERE deptno = 10;
```
![image7](/assets/DB/days08/image7.png){: .shadow}  

별칭이 컬럼명으로 적용되었다. pay의 datatype은 **NUMBER로 자동으로 적용됨.**  

만약 안의 데이터는 필요없고 구조만 같은 테이블을 만들고 싶다면   
```sql
CREATE TABLE tbl_emp
AS
SELECT *
FROM emp; 
DELETE FROM tbl_emp; 
```

`CREATE`로 만들고 `DELETE`로 모든 행 삭제해도 되지만

```sql
CREATE TABLE tbl_emp
AS
SELECT *
FROM emp
WHERE 1=0
```
**항상 거짓인** WHERE 조건절을 줘도 된다.
<br><br>


### NESTED TABLE 생성

![image8-1](/assets/DB/days08/image8-1.png){: .shadow}  

이런식으로 테이블 안에 테이블 데이터를 저장하고 싶다면 사용


먼저 컬럼3에 해당하는 이상한 데이터 타입을 만들어야 한다.

```sql
CREATE TYPE people_typ AS OBJECT(
   last_name     VARCHAR2(25), 
   department_id NUMBER(4),
   salary        NUMBER(8,2));
```

하나의 타입을 만드는데 안에 여러개의 정보를 가지고 있는 테이블 같은 데이터 타입. C의 구조체같은 녀석?  

```sql
CREATE TYPE people_tab_typ AS TABLE OF people_typ
```
그리고 만든 타입에 앞으로 쓸 자료형 이름을 부여...  
이제 만든 타입을 쓸 수 있다.  
```sql
CREATE TABLE hr_info(
    department_id  NUMBER(4),
    location_id    NUMBER(4),
    manager_id     NUMBER(6),
    people         people_tab_typ
)
NESTED TABLE people STORE AS people_stor_tab;
```
그리고 만든 자료형을 테이블에 사용하기
특이하게 CREATE TABLE 괄호가 끝나고 NESTED TABLE 키워드를 붙여 표기
<br><br>

### Partitioned Tables & Indexes 생성

`CREATE TABLE ... PARTITION ... 문`

하나의 테이블인데 부서별로 저장공간을 달리하고 싶다면 사용한다. 테이블 분할!  
테이블 분할(table partition)은 테이블 내의 데이터들을 어떤 기준에 따라 여러 개의 부분으로 나눌 수 있는데 이를 테이블을 분할한다고 한다.  

레코드가 너무 많으면 검색하기 힘들기 때문에 나누어 놓으면 사용하기 편하다.  

```sql
CREATE TABLE emp(
 emp_id  VARCHAR2(5),
 name    VARCHAR2(20),
 age     NUMBER,
 dept    VARCHAR2(20),
 CONSTRAINT emp_pk PRIMARY KEY (emp_id))
PARTITION BY RANGE(age)
  (PARTITION Part1 VALUES LESS THEN (20) TABLESPACE Part01,
   PARTITION Part2 VALUES LESS THEN (30) TABLESPACE Part02,
   PARTITION Part3 VALUES LESS THEN (40) TABLESPACE Part03,
   PARTITION Part4 VALUES LESS THEN (50) TABLESPACE Part04,
   PARTITION Part5 VALUES LESS THEN (MAXVALUE) TABLESPACE Part05);
```
나이를 기준으로 파티션을 나눔,  
![image8](/assets/DB/days08/image8.png){: .shadow}  

이 예에서는 5개의 테이블스페이스가 각각의 분할된 데이터를 저장하기 위해서 쓰인다.   
결국, 20세 이하의 age는 Part1이라는 파티션에 저장되는데 이는 물리적 Part01이라는 테이블스페이스에 저장된다.  
21∼30세의 age는 part2라는 파티션으로 저장되고 그 테이블스페이스는 Part02이다.  
마지막 MAXVALUE라는 키워드는 50세 이후의 age를 갖는 모든 데이터가 Part5라는 파티션에 저장된다.  



### Extend table 생성

캐싱 테이블 만들 때 사용함, 거의 만들일 없다.  
캐싱 테이블은 빈번하게 사용되는 테이블 데이터를 데이터버퍼 캐시영역에 상주시켜 검색시 성능을 향상시킨다.  

Nologging 테이블은 테이블 인덱스를 생성할 때 nologging 키워드를 사용하면, 생성 후 발생하는 모든 트랜젝션의 로그 정보가 로그버퍼영역에 저장되지 않는다.  
로그버펑역에 대한 경합을 최소화시킬 수 있어 성능향상에 도움이 된다.  

#### 형식
```sql
CREATE TABLE 테이블명
	(컬럼명 데이터타입 [, 컬럼명 데이터타입]...)
	[TABLESPACE tablespace명] – 테이블 생성 위치(DEFAULT users)
	[PCTFREE 정수]
	[PCTUSED 정수]
	[INITRANS 정수]
	[MAXTRANS 정수]
	[STORAGE storage절]
	[LOGGING ¦ NOLOGGING]
	[CACHE ¦ NOCACHE];
```
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-zlqz{font-weight:bold;background-color:#c0c0c0;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style>
<table class="tg">
  <tr>
    <th class="tg-zlqz">속성</th>
    <th class="tg-zlqz">설명</th>
  </tr>
  <tr>
    <td class="tg-zlqz">PCTFREE</td>
    <td class="tg-0pky">BLOCK에 data를 INSERT할 때 INSERT를 하지 않고 남겨 놓은 free space에 대한 비율을 나타내는 parameter</td>
  </tr>
  <tr>
    <td class="tg-zlqz">PCTUSED</td>
    <td class="tg-0pky">INSERT가 시작되는 시점을 결정하기 위한 parameter</td>
  </tr>
  <tr>
    <td class="tg-zlqz">INITRANS</td>
    <td class="tg-0pky">BLOCK을 구성할 때 BLOCK의 header에다가 transaction enrty를 몇개를 만들 것인가를 결정하는 parameter</td>
  </tr>
  <tr>
    <td class="tg-zlqz">MAXTRANS</td>
    <td class="tg-0pky">BLOCK 하나가 동시에 지원하는 transaction의 최대 수를 지정하는 parameter</td>
  </tr>
  <tr>
    <td class="tg-zlqz">STORAGE절</td>
    <td class="tg-0pky">
    INITIAL, NEXT, PCTINCREASE, MAXEXTENTS등을 지정할 수 있는 절
    <style type="text/css">
    .tg  {border-collapse:collapse;border-spacing:0;}
    .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
    .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
    .tg .tg-llyw{background-color:#c0c0c0;border-color:inherit;text-align:left;vertical-align:top}
    .tg .tg-y6fn{background-color:#c0c0c0;text-align:left;vertical-align:top}
    .tg .tg-0lax{text-align:left;vertical-align:top}
    </style>
    <table class="tg">
      <tr>
        <th class="tg-y6fn">INITIAL</th>
        <th class="tg-0lax">첫 번째 EXTENT의 크기</th>
      </tr>
      <tr>
        <td class="tg-y6fn">NEXT</td>
        <td class="tg-0lax">다음 EXTENT의 크기</td>
      </tr>
      <tr>
        <td class="tg-y6fn">MINEXTENTS</td>
        <td class="tg-0lax">처음 생성된 EXTENT의 총 개수</td>
      </tr>
      <tr>
        <td class="tg-y6fn">MAXEXTENTS</td>
        <td class="tg-0lax">할당 가능한 EXTENT의 총 개수</td>
      </tr>
      <tr>
        <td class="tg-y6fn">PCTINCREASE</td>
        <td class="tg-0lax">다음 EXTENT의 크기 증가율</td>
      </tr>
      <tr>
        <td class="tg-llyw">FREELISTS</td>
        <td class="tg-0lax">사용 가능한 BLOCK의 LIST 수</td>
      </tr>
    </table>
    </td>
  </tr>
  <tr>
    <td class="tg-zlqz">FREELISTS</td>
    <td class="tg-0pky">사용 가능한 BLOCK의 LIST 수</td>
  </tr>
  <tr>
    <td class="tg-zlqz">LOGGING/NOLOGGING</td>
    <td class="tg-0pky">Redo Log File 에 TABLE생성과 관련된 정보의 저장 여부를 결정하는 parameter (default = NOLOGGING)</td>
  </tr>
  <tr>
    <td class="tg-zlqz">CACHE/NOCACHE</td>
    <td class="tg-0pky">Full table scan시 읽어들인 BLOCK 을 buffer cache 내에 지정할 지 여부를 나타내는 parameter</td>
  </tr>
</table>


```sql
CREATE TABLE tbl_extent(
     no CHAR(3)
    ,name VARCHAR2(10))
    STORAGE (initial 10k
        next 10k
        minextents 1
        maxextents 121
        pctincrease 50);
```

알아만 두자…


### External table 생성

Extrenal 테이블은 DB 외부에 저장된 data source를 조작하기 위한 접근 방법의 하나로 읽기 전용 테이블이다.  
Extrenal 테이블의 실제 데이터는 DB 외부에 존재하지만, external 테이블에 대한 metadata는 DB 내부에 존재하는 일종의 가상 테이블이다.  

그냥 알고만 있자.  





## ALTER

ALTER 명령은 객체에 대한 모든 변경을 위해 사용된다.  
ALTER TABLE 명령을 사용하여 새로운 컬럼을 추가, 삭제, 변경할 수 있다.  
ALTER TABLE 명령을 사용하여 새로운 컬럼을 추가하면 기존의 테이블의 마지막 컬럼이 된다.  

### ALTER TABLE의 종류

1. ALTER TABLE... ADD 컬럼 
2. ALTER TABLE... MODIFY 컬럼 
3. ALTER TABLE... RENAME COLUMN 컬럼 TO 컬럼
4. ALTER TABLE... DROP[CONSTRAINT] 제약조건 
5. ALTER TABLE... DROP COLUME컬럼


이 문을 실행하려면 자신의 스키마에 대해 **ALTER 객체 권한과 ALTER ANY TABLE 시스템 권한**이 있어야 한다.



### ALTER TABLE … ADD

테이블 생성후 컬럼추가 할 때 사용

#### 형식
**컬럼추가**
```sql
ALTER TABLE 테이블명
ADD (컬럼명 datatype [DEFAULT 값]
  [,컬럼명 datatype]...);
```
**constraint추가**
```sql
ALTER TABLE 테이블명
ADD (컬럼명 datatype CONSTRAINT constraint명 constraint실제값
  [,컬럼명 datatype]...);
```

한번의 add 명령으로 **여러 개의 컬럼 추가**가 가능하다.  
하나의 컬럼만 추가하는 경우에는 괄호를 생략해도 된다.  

추가된 컬럼은 **테이블의 마지막 부분에 생성**되며 사용자가 컬럼의 위치를 지정할 수 없다.  
당연히 새로 추가된 칼럼안의 데이터는 모두 NULL로 초기화된다. 새로 입력되는 값에만 DEFAULT가 적용됨.  

```sql
ALTER TABLE tbl_member
ADD( tel   VARCHAR2(12)
    ,etc VARCHAR2(100)
);
```
![image9](/assets/DB/days08/image9.png){: .shadow}  
<br><br>

### ALTER TABLE … MODIFY

modify 명령은 테이블의 컬럼을 변경하고자 할 때 사용한다.
데이터의 **type, size, default** 값을 변경할 수 있다

#### 형식
```sql
ALTER TABLE 테이블명
MODIFY (컬럼명 datatype [DEFAULT 값]
      [,컬럼명 datatype]...);
```

#### MODIFY 유의사항…

컬럼 크기의 변경은 **저장된 데이터의 크기보다 크거나 같을 경우에만 가능**하다.  
**NOT NULL 컬럼**인 경우에는 **size의 확대만 가능**하다.    
ALTER TABLE … MODIFY를 이용하여 **constraint를 수정할 수 없다.**  

etc의 테이터 크기를 VARCHAR2(100) -> VARCHAR2(255)로 변경  

```sql
ALTER TABLE tbl_member
MODIFY etc VARCHAR(255);
```

수정할 칼럼이 하나이면 괄호 생략 가능.
<br><br>


### ALTER TABLE … RENAME

etc칼럼명을 memo로 변경
```sql
ALTER TABLE tbl_member
RENAME COLUMN etc to memo;
```


### ALTER … DROP COLUMN

테이블의 컬럼이나 constraint를 삭제할 때 사용한다.  

#### 형식  
```sql
ALTER TABLE 테이블명
DROP COLUMN 컬럼명; 
```

#### 유의사항
한번에 하나의 컬럼만 삭제할 수 있다.
삭제 후 테이블에는 적어도 하나의 컬럼은 존재해야 한다.
DDL문으로 삭제된 컬럼은 복구할 수 없다.

---


## UPDATE

UPDATE는 기존의 데이터를 변경할 때 사용한다.

### 형식
```sql 
UPDATE 테이블명
SET 컬럼명= 변경할값[, 컬럼명= 변경할값,...]
[WHERE 조건];
```

```sql
UPDATE tbl_member
SET NAME = '고길동
```
**모든** 이름을 고길동으로 변경  

```sql
UPDATE tbl_member SET 
NAME = '고길동'
WHERE NAME = '홍길동'; 
```
홍길동만 고길동으로 변경   


**참고사항** 
`DML(INSERT, UPDATE, DELETE)`의 변경내용은 세션에만 저장되기 때문에 롤백, 커밋으로 뒤로가기 가능, 


이름과 전화번호를 바꿔보자, 콤마로 찾으면 된다.
```sql
UPDATE tbl_member SET 
  name = '장길동'
, tel = '010-1111-2222'
WHERE name = '고길동';
```

컴마로 같이 변경이 가능.

### subquery를 사용한 UPDATE

#### 자신의 테이블에서 subquery하여 UPDATE
subquery를 사용하면 한 번의 update 명령으로 여러 개의 컬럼을 수정할 수 있다.  
여러 컬럼을 subquery의 결과 값으로 UPDATE 한다.  
```sql
UPDATE dept
SET (dname,loc) = (SELECT dname,loc FROM dept WHERE deptno=40)
WHERE deptno=10;
```
Deptno가 40번인 dname과 loc를 가져와서 deptno이 10번인 엔트리의 데이터를 바꿈.

다른 테이블에서 subquery하는 것도 마찬가지다.
두 경우 **모두 같은 유형, 같은 개수의 칼럼**을 가져야 한다.

---

## 연습문제!
CREATE TABLE (서브쿼리), ALTER TABLE, UPDATE 쿼리를 사용해서 다음 문제를 풀어보자.

1.	insa테이블에서 num과 name 칼럼으로 tbl_score테이블 생성  
2.	tbl_score에 kor, eng, mat, tot, avg, grade 칼럼 추가하기  
3.	kor, eng, mat 랜덤값으로 설정 후 총점, 평균, grade 계산하기  
    평균 60이상, 과목중 40점 이하 - 과락  
    평균 60이상, 모든과몽 40 이상 - 합격  
    그외 탈락  

```sql
CREATE TABLE tbl_score
AS
SELECT num, name
FROM insa
WHERE num < 1011;
```
![image10](/assets/DB/days08/image10.png){: .shadow}  

ROW가 너무 많아서 10개만 가져옴

```sql
ALTER TABLE tbl_score
ADD ( kor NUMBER(3)
     ,eng NUMBER(3)
     ,mat NUMBER(3)
     ,tot NUMBER(3)
     ,avg NUMBER(5, 2)
     ,grade VARCHAR2(20)
     );
desc tbl_score;
```
국, 영, 수, 총점, 평균, grade 칼럼 추가
```sql
UPDATE tbl_score SET kor = TRUNC(dbms_random.VALUE(0, 101)),
                     mat = TRUNC(dbms_random.VALUE(0, 101)),
                     eng = TRUNC(dbms_random.VALUE(0, 101));
```
![image11](/assets/DB/days08/image11.png){: .shadow}  

`dbms_random.VALUE` 함수로 랜덤값 적용

```sql
UPDATE tbl_score SET 
tot = kor+eng+mat ,
avg = (kor+eng+mat)/3 ,
grade = CASE	WHEN kor<40 OR eng<40 OR mat <40 THEN '과락'
              WHEN (kor+eng+mat)>= 60 AND kor>=40 AND eng>=40 AND mat>=40 THEN '합격'
             	ELSE '불합격'
        END;
```
![image12](/assets/DB/days08/image12.png){: .shadow}  

UPDATE와 CASE를 사용해서 조건식 작성.

---

## INSERT

### INSERT 유형 
1. INSERT INTO 테이블명 (컬럼명…) values (값…)  
2. INSERT INTO 테이블명 VALUES()  
3. INSERT INTO (컬럼명…) VALUES(SELECT …)  
<br><br>

### INSERT INTO 테이블명 (컬럼명…) values (값…)

가장 기본적인 방법, 칼럼명과 값을 같이 써서 INSERT

```sql
DESC tbl_member
```
![image13](/assets/DB/days08/image13.png){: .shadow}  

```sql
INSERT INTO tbl_member (id, name, age, birth, tel)
VALUES ('admin', '관리자', 35, '19850123', '010-1234-1234');
```
문자열과 날짜형 홀 따옴표 주의!
![image14](/assets/DB/days08/image14.png){: .shadow}  
 
괄호안 **컬럼명 순서대로 값을 부여**해야 오류가 안뜬다! 컬럼의 순서는 바뀌어도 상관없다.
<br><br>
 
### INSERT INTO 테이블명 VALUES (값…)

```sql
INSERT INTO tbl_member
VALUES ('admin', '김길동', 27, '19931029', sysdate, '010-1234-1234', null);
```
(칼럼명,,,) 이 생략됐다. 생략할 경우 칼럼 개수에 맞게 같은 유형의 데이터를 순서대로 넣어야 한다.  
<br><br>



### INSERT INTO 테이블명 (SELECT …)

**SELECT로 검색된 모든 행들이 INSERT된다.** 

```sql
CREATE TABLE cp_emp(
  id NUMBER,   
  name VARCHAR2(10),
  salary NUMBER
  );
```
![image15](/assets/DB/days08/image15.png){: .shadow}  

```sql
INSERT INTO cp_emp 
SELECT empno, ename, sal FROM emp;
```
![image16](/assets/DB/days08/image16.png){: .shadow}  
<br><br>

### 다중 INSERT

하나의 insert 문으로 하나의 테이블에 하나의 행(row)만을 입력하지 않고  
하나의 insert 문으로 **여러 개의 테이블에 동시에 하나의 행을 입력**하는 것이다.  

다중 insert 문에는 다음과 같은 4가지가 있다

**종류**|**설명**
:-----:|:-----
|unconditional INSERT ALL|조건없이 지정한 여러 테이블에 데이터를 입력|
|conditional INSERT ALL|조건에 맞는 행들을 원하는 여러 테이블에 입력|
|conditional FIRST INSERT|조건에 맞는 행들을 원하는 여러 테이블에 나누어 삽입(첫 when조건이 충족되면 다음의 when절은 수행하지 않음)|
|pivoting INSERT|into 절에 오직 하나의 테이블만 지정함|

<br><br>


#### Unconditional INSERT ALL 문 (조건없는 INSERT ALL)

**형식**
```sql
INSERT ALL | FIRST
[INTO 테이블1 VALUES (컬럼1,컬럼2,...)]
[INTO 테이블2 VALUES (컬럼1,컬럼2,...)]
.......
Subquery;
```

먼저 구조만 가져온 tbl_emp10, tbl_emp20, tbl_emp30 
테이블 3개 생성
```sql
CREATE TABLE tbl_emp10
AS
SELECT * FROM emp
WHERE 0 = 1;
```
![image17](/assets/DB/days08/image17.png){: .shadow}  


모든 테이블에 INSERT INTO! 하고 싶다면 INSERT ALL!

```sql
INSERT ALL
INTO tbl_emp10 VALUES(empno, ename, job, mgr, hiredate, sal, comm, deptno)
INTO tbl_emp20 VALUES(empno, ename, job, mgr, hiredate, sal, comm, deptno)
INTO tbl_emp30 VALUES(empno, ename, job, mgr, hiredate, sal, comm, deptno)
SELECT * FROM emp;
```

SELECT * FROM tbl_emp10;
SELECT * FROM tbl_emp20;
SELECT * FROM tbl_emp30;
![image18](/assets/DB/days08/image18.png){: .shadow}  

`SELECT * FROM emp` 로부터 얻어온 ROW를 모두 INSERT한다.
<br><br>

#### Conditional INSERT ALL 문

**형식**
```sql
INSERT ALL
WHEN 조건절1 THEN
  INTO [테이블1] VALUES (컬럼1,컬럼2,...)
WHEN 조건절2 THEN
  INTO [테이블2] VALUES (컬럼1,컬럼2,...)
........
ELSE
  INTO [테이블3] VALUES (컬럼1,컬럼2,...)
Subquery;
```

`WHEN`과 `THEN`, `ELSE` **조건절**을 사용해서 **INSERT할 ROW를 분류 가능**.
각 tbl_emp마다 해당되는 부서만 들어갈 수 있도록 조건절을 적용해보자.

```sql
INSERT ALL
WHEN deptno = 10 THEN
INTO tbl_emp10 VALUES(empno, ename, job, mgr, hiredate, sal, comm, deptno)
WHEN deptno = 20 THEN
INTO tbl_emp20 VALUES(empno, ename, job, mgr, hiredate, sal, comm, deptno)
ELSE
INTO tbl_emp30 VALUES(empno, ename, job, mgr, hiredate, sal, comm, deptno)
SELECT * FROM emp;
```

부서별로 데이터가 저장된다!
<br><br>

#### Conditional first insert

Conditional first insert 문은 conditional insert all 문과 동일하게 특정 조건들을 기술하여 그 조건에 맞는 행(row)들을 원하는 테이블에 나누어 삽입하고자 할 때 사용하지만,  
conditional insert all 문과 달리 **첫 번째 when 절에서 조건을 만족할 경우 다음의 when 절은 수행하지 않는다.**  

**형식**
```sql
INSERT FIRST
WHEN 조건절1 THEN
  INTO [테이블1] VALUES (컬럼1,컬럼2,...)
WHEN 조건절2 THEN
  INTO [테이블2] VALUES (컬럼1,컬럼2,...)
........
ELSE
  INTO [테이블3] VALUES (컬럼1,컬럼2,...)
Sub-Query;
```

```sql
INSERT FIRST
WHEN job = 'CLERK' THEN
INTO tbl_emp10 VALUES(empno, ename, job, mgr, hiredate, sal, comm, deptno)
WHEN deptno = 20 THEN
INTO tbl_emp20 VALUES(empno, ename, job, mgr, hiredate, sal, comm, deptno)
ELSE
INTO tbl_emp30 VALUES(empno, ename, job, mgr, hiredate, sal, comm, deptno)
SELECT * FROM emp;
```

tbl_emp10에는 모든 CLERK 직업을 가진 레코드가 저장되고  
tbl_emp20에는 모든 20번 부서를 가진 레코드가 저장되지만 그중 **CLERK직업을 가진 20번 부서 직원은 빠지게된다.**  
<br><br>


### Pivoting insert 문

pivoting insert 문은 unconditional insert all 문과 거의 동일하나 into 절에 단 한 개의 테이블만 올 수 있다.  

대부분의 관계형 데이터베이스에서 테이블을 생성할 때 유사한 정보가 저장되는 컬럼은 하나의 공통 컬럼으로 설계하여 사용하는 것이 보통이다.  

하지만, 비관계형 데이터베이스에서는 이러한 방법으로 설계하지 않고 각각 필요한 컬럼을 따로 설계하여 데이터를 저장한다.  

pivoting insert 문은 이와 같이 **비관계형 데이터베이스 구조의 컬럼을 읽어서 관계형 데이터베이스 구조의 테이블에 데이터를 일괄 입력시킬 때 사용**한다.  

여러 개의 into 절을 사용할 수 있지만, into 절 뒤에 오는 테이블은 모두 동일해야 한다. 

#### 형식
```sql
INSERT ALL
WHEN 조건절1 THEN
  INTO [테이블1] VALUES (컬럼1,컬럼2,...)
  INTO [테이블1] VALUES (컬럼1,컬럼2,...)
  ..........
Sub-Query;
```

두개의 테이블 생성
```sql
CREATE TABLE tbl_sales(
 employee_id        NUMBER(6),
 week_id            NUMBER(2),
 sales_mon          NUMBER(8,2),
 sales_tue          NUMBER(8,2),
 sales_wed          NUMBER(8,2),
 sales_thu          NUMBER(8,2),
 sales_fri          NUMBER(8,2)
 );

CREATE TABLE tbl_sales_data(
  employee_id        NUMBER(6),
  week_id            NUMBER(2),
  sales              NUMBER(8,2));
```

tbl_sales에 INSERT INTO!
```sql
INSERT INTO tbl_sales VALUES(1101,4,100,150,80,60,120);
INSERT INTO tbl_sales VALUES(1102,5,300,300,230,120,150);
```
![image19](/assets/DB/days08/image19.png){: .shadow}  


```sql
INSERT ALL
  INTO tbl_sales_data (employee_id, week_id, sales) VALUES(employee_id, week_id, sales_mon)
  INTO tbl_sales_data (employee_id, week_id, sales) VALUES(employee_id, week_id, sales_tue)
  INTO tbl_sales_data VALUES(employee_id, week_id, sales_wed)
  INTO tbl_sales_data VALUES(employee_id, week_id, sales_thu)
  INTO tbl_sales_data VALUES(employee_id, week_id, sales_fri)
SELECT *
FROM tbl_sales; 
```
![image20](/assets/DB/days08/image20.png){: .shadow}  

그냥 한테이블에 PIVOT처럼 각각 다른값을 저장…

---

## MERGE (병합)

다음과 같은 2개의 테이블을 합칠 때 MERGE를 사용하면 편하다.

**A테이블**  
상품A: 5개  
상품B: 3개  

**B테이블**  
상품A: 3개  
상품C: 10개  

B테이블은 이번에 새로 들어온 상품 리스트이다.  
A테이블은 기존 창고에 있는 상품 리스트이다.  

상품A는 UPDATE로 더하는 **수정작업**을, 상품C는 INSERT로 **추가작업**을 해야 한다.  

### 형식
```sql
MERGE INTO 테이블명 alias
USING [테이블명 | 뷰명 | subquery] alias
ON 조건
WHEN MATCHED THEN
	UPDATE SET ...
WHEN NOT MATCHED THEN
	INSERT ...
	VALUES ...;
```

ON에는 조인조건이 들어간다.


dept1과 dept2 테이블을 만들고 합쳐보자.
```sql
CREATE TABLE dept1
AS
SELECT * FROM dept;

CREATE TABLE dept2
AS
SELECT * FROM dept;
```
```sql
INSERT INTO dept2 
VALUES(50,'KIM_gun','COREA');

UPDATE dept2 SET 
dname='LEE_gun' 
WHERE deptno=30;
```
```sql
SELECT * FROM dept1;
```
![image21](/assets/DB/days08/image21.png){: .shadow}  

```sql
SELECT * FROM dept2;
```
![image22](/assets/DB/days08/image22.png){: .shadow}  


dept2는 새로 50번 부서 인원이 추가되고 LEE_gun으로 SALES가 수정되었다.

```sql
MERGE INTO dept1 d
USING dept2 de
ON (d.deptno=de.deptno) 
WHEN MATCHED THEN
UPDATE SET
  d.dname=de.dname,
  d.loc=de.loc
WHEN NOT MATCHED THEN
  INSERT VALUES(de.deptno, de.dname, de.loc);
```

dept1에 dept2를 MERGE해보자, deptno을 기준으로 부서번호가 같으면 dname과 loc을 서로 같게 UPDATE하고 다르면 INSERT 시키자  

UPDATE연산은 4번, INSERT연산은 1번 총 5개행이 변경된다.  
![image23](/assets/DB/days08/image23.png){: .shadow}  

병합되어서 dept1와 dept2가 서로 같게 되었다.   
물론 WHEN MATCHED THEN과 WHEN NOT MATCHED THEN을 통해 서로 다르게 설정할 수 있다.  

```sql
MERGE INTO tbl_merge_bonus D
    USING (SELECT id, salary FROM tbl_merge_emp) S
    ON (D.id = S.id)
  WHEN MATCHED THEN
    UPDATE SET
    D.bonus=D.bonus + S.salary*0.01
  WHEN NOT MATCHED THEN
    INSERT(D.id, D.bonus)
    VALUES(S.id,S.salary*0.01);
```
USING에 서브쿼리를 사용할 수 도 있다.



---

## 잡다구리

### purge
```sql
DROP TABLE tbl_member; -- 휴지통에 버려진 상태
DROP TABLE tbl_member purge; -- 완전삭제
```
XE 무료버전은 둘다 완전 삭제된다. 휴지통 복원기능 없음....

### UNPIVOT
```sql
SELECT *
FROM
(
   SELECT * FROM tbl_sales
)
UNPIVOT(weeks_value  FOR dayOfweek  IN (sales_mon,sales_tue,sales_wed ,sales_thu ,sales_fri));
```

FROM절 안의 서브쿼리 실행
![image1](/assets/DB/days08/image1.png){: .shadow}  

UNPIVOT을 통해 세로로 출력
![image2](/assets/DB/days08/image2.png){: .shadow}  


# 제약조건

## 데이터 딕셔너리

**사용자와 데이터 베이스 자원을 효율적으로 관리**하기 위한 다양한 정보를 저장하는 **시스템 테이블의 집합**.
사용자가 테이블을 생성하거나 사용자를 변경하는 등의 작업을 할 때 DB서버에 의해 자동으로  갱신되는 테이블이다.

사용자는 데이터 딕셔너리의 내용을 직접 수정, 삭제할 수 없고 사용자가 이해 할 수 있는 데이터를 읽기 전용 뷰 형태로 정보를 제공한다.

---

## 스키마(Scheema)
DB에서 어떤 목적을 위하여 필요한 여러 개로 구성된 DB객체들의 집합을 Schema라 한다.
이런 집합을 표현할 때 객체를 소유한 사용자 명을 사용한다. 
>DB객체(테이블, 시퀀스, 뷰, 프로시저, 함수, 패키지… 등등)

![image1](/assets/DB/days09/image1.png){: .shadow}  

계정 생성과 동시에 계정명으로 스키마가 자동으로 만들어 진다.

DB객체를 조회할 때 스키마(사용자명)을 앞에 붙인다

`SELECT * FROM 소유자명.DB객체`

`SELECT * FROM scott.emp`

사용자 자신이 자신의 객체에 쿼리를 날리 때는 스키마(사용자명)을 생략해도 된다.



---
 
## 제약조건(constraints)	

제약조건은 data integrity(데이터 무결성)을 위하여 
주로 테이블에 행(row)을 입력, 수정, 삭제할 때 적용되는 규칙이다.

> 데이터 무결성
<br><br>

### 개체 무결성 규칙
 
![image2](/assets/DB/days09/image2.png){: .shadow}  
하나 하나의 부서를 구별하기 위한 부서번호(deptno)가 중복된다면 개체 무결성에 위배된다.  
측 개체 무결성 규칙은 릴레이션(테이블)에 저장되는 튜플(tuple)의 **유일성을 보장하기 위한 제약조건**이다.  
개체 무결성을 보장하기 위해 기본키(PRIMARY KEY)를 사용한다.  
<br><br>

### 참조 무결성

```sql
INSERT INTO EMP 
VALUES(9999, 'JAMES', 'CLERK', 7698, '81/12/03', 950, 100, 50);
```
deptno를 50으로 설정해서 INSERT하면 다음과 같은 에러가 뜬다.  
`ORA-02291: integrity constraint (SCOTT.FK_DEPTNO) violated - parent key not found`  
**PARENT KEY NOT FOUND**… 부모키를 찾을 수 없다고 한다.   

이 뜻은 부모 테이블인 dept테이블에서 외래키로 사용하고 있는 depno에서 50을 찾을 수 없다는 뜻.  

내부적으로 deptno는 dept테이블의 deptno를 외래키(FOREIGN KEY)로 참조하고 있는데 50번 부서가 없는데 참조했기 때문에
에러가 났다.  
이런 경우를 참조 무결성이라 한다.  
즉 참조 무결성 규칙은 릴레이션 간의 **데이터의 일관성을 보장하기 위한 제약조건**이다.  
>부모키(Parent Key) = 외래키(Foreign Key) = 참조키(Reference Key), 외부키, 외부식별자 라고도 한다.

detp테이블에서 10번 부서를 삭제해보자

```sql
DELETE FROM dept
WHERE deptno = 10;
```

`ORA-02292: integrity constraint (SCOTT.FK_DEPTNO) violated - child record found`   
자식 레코드에서 해당 레코드가 참조됐다고 에러코드를 발생했다.  

10번 부서를 없애고 싶다면 모든 10번부서의 사원을 emp테이블에서 삭제하거나(CASCADE)
UPDATE시켜서 10번 부서를 사용하지 않도록 해야 한다.  
<br><br>


### 도메인 무결성	

도메인 무결성 규칙은 속성에서 허용 가능한 **값의 범위를 지정하기 위한 제약조건**이다.

![image3](/assets/DB/days09/image3.png){: .shadow}  

국, 영, 수, 총점, 평균이 칼럼으로 있는 테이블에 다음과 같은 데이터를 INSERT 해보자.  
```sql
INSERT INTO tbl_score
VALUES(1006, '홍길동', 110, 100, 90, 100, 100, '합격');
```

국어점수는 100점을 넘길 수 없는데 110점이 들어갔다. 이런 경우 도메인 무결성을 위배했다 볼 수 있다.  

도메인 무결성 규칙에서는 속성의 범위 말고도 속성의 **데이터 타입, 길이, 기본 키, 유일성, null 허용 같은 다양한 제약조건을 지정할 수 있다.**
 
### 제약조건 5가지

**Constraint**|**설명**
:-----:|:-----
PRIMARY KEY(PK)|해당 컬럼 값은 반드시 존재해야 하며, 유일해야 함<br>(NOT NULL과 UNIQUE 제약조건을 결합한 형태)
FOREIGN KEY(FK)|해당 컬럼 값은 참조되는 테이블의 컬럼 값 중의 하나와 일치하거나 NULL을 가짐
UNIQUE KEY(UK)|테이블내에서 해당 컬럼 값은 항상 유일해야 함 (후보키)
NOT NULL|컬럼은 NULL 값을 포함할 수 없다.
CHECK(CK)|해당 컬럼에 저장 가능한 데이터 값의 범위나 조건 지정
 

<!-- ![image4](/assets/DB/days09/image4.png){: .shadow}   -->


### 제약조건의 특징

* DML 작업에서 잘못되는 것을 제약조건에 의해 방지한다.  
* 모든 정보가 데이터 사전에 저장된다.  
* 언제든지 disable, enable시킬 수 있다.  
* 처리결과가 즉시 사용자에게 넘겨진다.  
* 한 컬럼에 여러 개의 제약조건을 지정할 수 있다.  
* 하나의 컬럼뿐만 아니라 여러 컬럼을 조합하여 하나의 key를 구성하는 composit key(복합키)를 만들 수 있다. 예: PRIMARY KEY(pno, ename)  
* 제약조건의 관리는 DB server가 담당한다.  

 
### 제약조건 확인하기
```sql
SELECT * FROM user_constraints;
user_constrains
```
![image5](/assets/DB/days09/image5.png){: .shadow}  

user_constraints는 – **뷰(가상테이블) 테이블** 이다.
<br><br>

### 제약 조건 적용하기

#### 형식
```sql
CREATE TABLE [schema.] table(
  column datatype [ DEFAULT expression]
  [column_constraint],
  [table_constraint][,...]
  )
```

CREATE테이블에서 제약조건 정의하는 방법은 2가지다.
1. column constarint (칼럼 레벨 제약조건)  
2. table constraint (테이블 레벨 제약조건)  

#### 칼럼 레벨 제약조건 예제

```sql
CREATE TABLE tbl_pk_dept(
  DEPTNO NUMBER(2)  NOT NULL  PRIMARY KEY –칼럼레벨 제약조건정의
, DNAME  VARCHAR2(14) 
, LOC    VARCHAR2(13) 
);
```
![image6](/assets/DB/days09/image6.png){: .shadow}  

**NOT NULL제약조건**과 **PRIMARY KEY 제약조건** 2개가 생겼다.  
제약조건명을 붙이지 않으면 **SYS_XXXX 형식으로 제약조건명이 자동 설정**된다.  


제약조건명은 다음과 같이 정의할 수 있다.
```sql
CREATE TABLE tbl_pk_dept(
  DEPTNO NUMBER(2)  NOT NULL  CONSTRAINT pk_tbl_pk_dept_deptno PRIMARY KEY
, DNAME  VARCHAR2(14) 
, LOC    VARCHAR2(13) 
);
```
![image7](/assets/DB/days09/image7.png){: .shadow}  

`CONSTRAINT “제약조건명” PRIMARY KEY` 명령을 통해 제약조건 이름을 정할 수 있음.  
<br><br>


#### 테이블 레벨 제약조건 예제

```sql
CREATE TABLE tbl_pk_dept(
  DEPTNO NUMBER(2)  NOT NULL -- NOT NULL은 칼럼레벨로만 제약조건을 부여할 수 있다.
, DNAME  VARCHAR2(14) 
, LOC    VARCHAR2(13) 
, CONSTRAINT pk_tbl_pk_dept_deptno PRIMARY KEY(deptno)  --테이블 레벨 제약조건 방식
);
```

만약 deptno와 dname 2개의 칼럼을 기본키로 하고 싶다면, **여러 개의 칼럼을 하나의 제약조건으로 묶을 때** 는 테이블레벨로 밖에 할 수 없다.  

CREATE TABLE로 테이블만들 때 제약조건을 줄 수 있지만
서브쿼리 등으로 테이블을 만들 때 NOT NULL만 복사되고 나머지 제약조건이 복사되지 않는다.  

따라서 **ALTER TABLE로 제약조건을 추가 또는 삭제**해줘야 한다.  
참고로 ALTER로 제약조건 수정은 안된다. MODIFY로 칼럼 수정은 가능했지만 제약조건은 안된다.
<br><br>


#### ALTER로 제약조건 추가 예제

**형식**  
```sql
ALTER TABLE 테이블명
ADD (컬럼명 datatype CONSTRAINT constraint명 constraint실제값
  [,컬럼명 datatype]...);
```

CREATE와 서브쿼리로 dept복사본 tbl_pk_dept 테이블을 생성
```sql
CREATE TABLE tbl_pk_dept
AS
SELECT * FROM dept;
```
tbl_pk_dept의 deptno는 기본키여야 하지만 서브쿼리로 복붙했기 때문에 아무런 제약조건이 걸려있지 않다.  
```sql
ALTER TABLE tbl_pk_dept
ADD CONSTRAINT pk_tblpkdept_deptno PRIMARY KEY(deptno);
```
![image8](/assets/DB/days09/image8.png){: .shadow}  

적용된 제약조건을 지우고 싶다면 `DROP CONSTRAINT “제약조건명”`  
```sql
ALTER TABLE tbl_emp10
DROP CONSTRAINT pk_tblpkdept_deptno;
```
또는
```sql
ALTER TABLE tbl_emp10
DROP PRIMARY KEY;
```
어차피 테이블에 **PRIMARY KEY는 하나밖에 없기 때문에** 제약조건명 없이 ‘DROP PRIMARY KEY’ 로 기본키 제약조건을 없앨 수 있다.  
 

`NOT NULL`은 `MODIFY`를 사용해서 추가, 삭제가능하다.

```sql
ALTER TABLE tbl_emp10
MODIFY job CONSTRAINT NN_tbl_emp10_job NOT NULL
--NOT NULL 제약조건 설정

ALTER TABLE tbl_emp10
MODIFY job CONSTRAINT NULL
--NOT NULL 제약조건 삭제
```

`ALTER TABLE`과 `CHECK`제약조건을 사용해서도 수정 가능.

```sql
ALTER TABLE tbl_emp
ADD ( CONSTRAINTS pk_tblemp_empno PRIMARY KEY(empno),
      CONSTRAINT nn_tblemp_ename CHECK(ename IS NOT NULL) );
```


>참고: 외래키로 참조중인 기본키는 바로 삭제할 수 없다.
```sql
ALTER TABLE dept
DROP PRIMARY KEY;
```

`ORA-02273: this unique/primary key is referenced by some foreign keys`  
dept의 기본키를 emp테이블에서 외래키로 사용 중이기 때문에 삭제 불가  
삭제하고 싶다면 `CASCADE`옵션을 사용해야함  
<br><br>


### FOREIGN KEY

#### FOREIGN KEY 칼럼레벨 방식으로 추가하기

**형식**
```sql
CREATE TABLE 테이블명(
칼럼명 데이터 타입 CONSTRAINT constraint명 FOREIGN KEY(컬럼명) REFERENCES 참조테이블명(참조컬럼명)
```

테스트를 위해 tbl_fk_emp 테이블 생성
```sql
CREATE TABLE tbl_fk_emp(
 EMPNO    NUMBER(4)     NOT NULL CONSTRAINT pk_tblfkemp_empno PRIMARY KEY
,ENAME    VARCHAR2(10) 
,JOB      VARCHAR2(9)  
,MGR      NUMBER(4)    
,HIREDATE DATE         
,SAL      NUMBER(7,2)  
,COMM     NUMBER(7,2)  
,DEPTNO   NUMBER(2)     CONSTRAINT fk_tblfkemp_deptno REFERENCES dept(deptno)
);
```
![image9](/assets/DB/days09/image9.png){: .shadow}  

기본키, NOT NULL, 외래키 제약조건 3개를 주었다. 
CONSTRAINT_TYPE에 NOT NULL은 `C`, 기본키는 `P`, 외래키는 `R` 표시

하나의 테이블에 여러개의 외래키가 존재할 수도 있기에 외래키 삭제 시 제약조건 명을 써주어야 한다.  
```sql
ALTER TABLE tbl_fk_emp
DROP CONSTRAINT tbl_fk_emp;
```
~~그냥 `DROP CONSTRAINT` 제약조건명 만 기억하자~~
<br><br>



#### FOREIGN KEY 테이블 레벨 방식으로 추가하기
```sql
DROP TABLE tbl_fk_emp;
CREATE TABLE tbl_fk_emp(
 EMPNO    NUMBER(4)     NOT NULL
,ENAME    VARCHAR2(10) 
,JOB      VARCHAR2(9)  
,MGR      NUMBER(4)    
,HIREDATE DATE         
,SAL      NUMBER(7,2)  
,COMM     NUMBER(7,2)  
,DEPTNO   NUMBER(2)
, CONSTRAINT pk_tblfkemp_empno PRIMARY KEY(empno)
, CONSTRAINT fk_tblfkemp_deptno FOREIGN KEY(deptno) REFERENCES dept(deptno)
);
```
<br><br>


####FOREIGN KEY ALTER 명령어로 추가하기

추가
```sql
ALTER TABLE tbl_fk_emp
ADD ( CONSTRAINT pk_tblfkemp_empno PRIMARY KEY(empno)
     ,CONSTRAINT fk_tblfkemp_deptno FOREIGN KEY(deptno) 
        REFERENCES tbl_fk_dept(deptno) );
```

삭제
```sql
ALTER TABLE tbl_fk_emp
DROP CONSTRAINT pk_tblfkemp_empno;

ALTER TABLE tbl_fk_emp
DROP CONSTRAINT fk_tblfkemp_deptno;
```
<br><br>

#### CASCADE, SET NULL 옵션

```sql
ALTER TABLE tbl_fk_emp
ADD ( CONSTRAINT pk_tblfkemp_empno PRIMARY KEY(empno)
     ,CONSTRAINT fk_tblfkemp_deptno FOREIGN KEY(deptno) 
        REFERENCES tbl_fk_dept(deptno) ON DELETE CASCADE
);
```
![image10](/assets/DB/days09/image10.png){: .shadow}  

```sql
ALTER TABLE tbl_fk_emp
ADD ( CONSTRAINT pk_tblfkemp_empno PRIMARY KEY(empno)
     ,CONSTRAINT fk_tblfkemp_deptno FOREIGN KEY(deptno) 
        REFERENCES tbl_fk_dept(deptno) ON DELETE SET NULL
);
```
![image11](/assets/DB/days09/image11.png){: .shadow}  

**CASCADE**옵션과 **SET NULL**옵션을 줄 수 있다.  
 
옵션 설정 전에는 아래 코드를 실행하면 에러 난다.  
`DELETE FROM tbl_fk_dept WHERE deptno = 10;`

`ORA-02292: integrity constraint (SCOTT.FK_TBLFKEMP_DEPTNO) violated - child record found`
자식 레코드가 외래키로 참조 중이기 때문에 참조 무결성에 따라 삭제 불가능 하다는 에러를 띄운다.  
삭제하고 싶다면 emp의 10번 소속 레코드를 모두 삭제하거나 다른 부서 코드에 속하게 해야한다.  

`ON DELETE CASCAD`E는 10번 소속 레코드를 모두 삭제하는 옵션이고  
`ON DELETE SET NULL`은 10번 소속 레코드의 부서를 모두 NULL로 설정하는 옵션이다.  
![image12](/assets/DB/days09/image12.png){: .shadow}  

<br><br>

이외에도 
`RESTRICT, CASCADE, NO ACTION, SET NULL`제약조건이 있으니 참고하자.  



### UNIQUE

중복될 수 없도록 하는 제약조건

insa테이블을 복사해서 ssn칼럼에 UNIQUE 제약조건 설정을 해보자.

```sql
CREATE TABLE tbl_uk_insa
AS
SELECT num, name, ssn, ibsadate
FROM insa
WHERE num <= 1005;

ALTER TABLE tbl_uk_insa
ADD(CONSTRAINT pk_tblukinsa_num PRIMARY KEY(num)
   ,CONSTRAINT uk_tblukinsa_ssn UNIQUE(ssn));
```

>UNIQUE괄호 안에 여러개의 칼럼명을 줄수 있다. UNIQUE(ssn, , , ,);  
![image13](/assets/DB/days09/image13.png){: .shadow}  

NOT NULL은 복사되었고 CREATE TABLE AS로 인해 복사된 제약조건이고   
ALTER로 num을 PRIMARY KEY, snn에 UNIQUE 제약조건 설정.  

1006번째 데이터를 INSERT, 테스트용으로 기존에 있는 주민번호를 집어넣어 보자.
```sql
INSERT INTO tbl_uk_insa
VALUES(1006, '한석봉', '771212-1022432', '04/08/13');
```

`ORA-00001: unique constraint (SCOTT.UK_TBLUKINSA_SSN) violated`  
'771212-1022432' 주민번호는 기존에 있기 때문에 unique 제약조건을 위배한다고 에러가 뜬다.  

ssn에 NULL값을 집어넣을 수 있도록 설정하고 NULL을 2개 넣어보자.  
```sql
ALTER TABLE tbl_uk_insa
MODIFY(ssn NULL);
```

ssn이 null인 엔트리 2개 삽입  
```sql
INSERT INTO tbl_uk_insa
VALUES(1006, '한석봉', null, '04/08/13');

INSERT INTO tbl_uk_insa
VALUES(1007, '둘석봉', null, '04/08/13');
```
NULL도 UNIQUE로 판단해서 2개 이상 넣으면 에러 날 것 같았는데 잘 들어가진다.
>MS-SQL에서는 안들어가진다고함
<br><br>

### 제약조건 활성화, 비활성화(disable)

비활성화는 삭제가 아니라 사용 안 하는 것. 

```sql
ALTER TABLE tbl_uk_insa
ENABLE CONSTRAINT uk_tblukinsa_ssn;
```
![image14](/assets/DB/days09/image14.png){: .shadow}  


```sql
ALTER TABLE tbl_uk_insa
DISABLE CONSTRAINT uk_tblukinsa_ssn CASCADE;
```
>CASCADE옵션을 주면 외래키로 참조하는 칼럼의 제약조건도 연달아 비활성화 된다.  
<br><br>


### CHECK

도메인 무결성을 위한 CHECK 제약조건  
`<` `>` `=`연산자, `AND` `OR`연산자 `BETWEEN`연산자, `IN`연산자, `LIKE`연산자 등을 사용해서 해당 컬럼에 저장 가능한 **데이터 값의 범위나 조건 지정**할 수 있다.  

#### 칼럼레벨과 테이블 레벨 CHECK 제약조건 설정  

```sql
CREATE TABLE tbl_score(
  kor NUMBER(3) CONSTRAINT ck_tblscore_kor CHECK (KOR BETWEEN 0 AND 100)
 ,eng NUMBER(3) 
 ,mat NUMBER(3)
 , CONSTRAINT ck_tblscore_eng CHECK (eng>=0 AND eng <= 100)
 );
```

#### ALTER TABLE로 CHECK 제약조건 추가

```sql
ALTER TABLE tbl_score
ADD CONSTRAINT ck_tblscore_mat CHECK(mat BETWEEN 0 AND 100);
``` 
![image15](/assets/DB/days09/image15.png){: .shadow}  
<br>
 
### 복합키(composit key)

보통 복합키를 만들기 보다는 순번을 기본키로 설정한다, 복합키를 기본키로 하면 성능이 떨어지기 때문...  
성능을 위해 복합키를 없애기 위해 순번 칼럼을 넣어 테이블을 쪼개는 행위를 '역정규화' 라고 한다.  

```sql
CREATE TABLE tbl_outputsal(
  empno     NUMBER(4)
, ename     VARCHAR2(20)
, outputdate DATE
, pay       NUMBER(9)
, CONSTRAINT pk_tbloutputsal_empno_date PRIMARY KEY (empno, outputdate)
);
```

empno와 outputdate일을 복합키로 설정.  
**복합키는 테이블 레벨에서만 설정** 가능하다.  

또는 ALTER TABLE로 복합키 설정
```sql
ALTER TABLE tbl_outputsal
ADD CONSTRAINT pk_tbloutputsal_empno_date PRIMARY KEY (empno, outputdate);
```


# 뷰, 시퀀스, 게시판 모델링

## 뷰 (가상 테이블)

뷰란 한 개 이상의 기본 테이블이나 다른 뷰를 이용하여 생성되는 가상 테이블(virtual table)이다.  

뷰는 기존에 생성된 테이블 또는 다른 뷰에서 접근할 수 있는 전체 데이터 중에서 일부만 접근할 수 있도록 제한하기 위한 기법이다  

테이블은 디스크 공간이 할당되어 데이터를 저장할 수 있지만,  
뷰는 데이터 딕셔너리 테이블에 뷰에 대한 정의만 저장하고 디스크에 저장 공간이 할당되지 않는다. (저장공간 효율성 UP, 성능도 UP)  

뷰는 물리적인 저장 공간과 데이터를 갖지는 않지만 테이블에서 파생된 객체이므로 테이블과 유사하게 사용할 수 있다.  


### 뷰의 특징

* 뷰를 이용하면 중요한 데이터를 보호하기 위한 보안(security) 목적과, 사용자에게 편의성(flexibility)를 제공하기 위한 목적을 달성하기 위해서이다. (성능도 올라감)  
* 테이블과 같이 뷰에 대한 DML 연산 즉, 쿼리, update, insert, delete가 가능하며 constraint(제약조건)도 부여할 수 있다.  
* 뷰는 데이터 값이 아니라 실제적으로는 질의 문장만을 가진다.  
* 뷰는 기본 테이블에서 정의된 모든 무결성 제약조건을 상속 받는다.  
* 뷰를 정의한 기본 테이블의 데이터가 변경되면 뷰에도 반영된다.  
* 뷰에 대한 정의는 user_views 데이터 딕셔너리 테이블을 통해서 조회할 수 있다.  
<br>


뷰의 종류는 __2가지__ 로 나뉜다.


1.	복합뷰  
하나의 테이블로 뷰를 만드는게 아닌 여러 개의 테이블을 JOIN해서 뷰를 생성

2.	단일뷰  
하나의 테이블로 뷰를 생성.

**특징**|**simple view**|**complex view**
:-----:|:-----:|:-----:
테이블 개수 |1개 |1 개 이상 
함수(수식) |없음 |포함 
data group |없음 |포함 
뷰를 통한 DML |가능 |항상 가능한 것은 아님

<br><br>

panmai, gogaek 을 JOIN하여  
복합뷰 생성

```sql
CREATE VIEW panmai_view
AS
SELECT b.b_id, title, g_name, p_su
FROM book b 
JOIN panmai p ON b.b_id = p.b_id
JOIN gogaek g ON g.g_id = p.g_id;
```
![image1](/assets/DB/days11/image1.png){: .shadow}  

>참고: VIEW를 만드려면 SYS로부터 **CREATE VIEW** 권한을 받아야 한다.
GRANT CREATE VIEW TO SCOTT;


```sql
SELECT * FROM panmai_view;
```

뷰를 생성하면 구문검사를 view를 호출할 때 마다 매번 하는 것이 아니라  

**이미 메모리에 올라가 있기 때문**에 구문검사 할 필요가 없어진다.   
(오히려 그냥 테이블 사용하는 것 보다 빠르다)  
 

### 형식
```sql
CREATE [OR REPLACE] [FORCE | NOFORCE] VIEW 뷰이름
  [(alias[,alias]...]
AS subquery
[WITH CHECK OPTION]
[WITH READ ONLY];
```

각각의 옵션의 의미.  

**옵션**|**설명**
:-----:|:-----
OR REPLACE | 같은 이름의 뷰가 있을 경우 무시하고 다시 생성 
FORCE | 기본 테이블의 유무에 상관없이 뷰를 생성 
NOFORCE | 기본 테이블이 있을 때만 뷰를 생성 
ALIAS | 기본 테이블의 컬럼이름과 다르게 지정한 뷰의 컬럼명 부여 
WITH CHECK OPTION | 뷰에 의해 access될 수 있는 행(row)만이 삽입, 수정 가능 
WITH READ ONLY | DML 작업을 제한(단지 읽는 것만 가능)

<br><br>

### OR REPLACE 옵션

```sql
CREATE VIEW tbl_emp_view
AS
SELECT * FROM tbl_emp
```

이미 tbl_emp_view가 존재한다면 오류를 반환한다.  
`ORA-00955: name is already used by an existing object`  

CREATE 뒤에 `OR REPLACE` 옵션을 사용하면 뷰가 이미 존재하더라도 지우고 다시 생성한다.

```sql
CREATE OR REPLACE VIEW tbl_emp_view
AS
SELECT * FROM tbl_emp
```
<br><br>


### FORCE 옵션


```sql
CREATE OR REPLACE NOFORCE VIEW noforceview
AS
SELECT a, b, c FROM xx ORDER BY a asc;
```

서브쿼리의 xx라는 테이블은 **존재하지 않는 테이블**이다.  

`ORA-00942: table or view does not exist`  
당연히 오류뜬다.  

하지만 `FORCE` 옵션을 사용하면 강제로 생성 가능하다.  

```sql
CREATE OR REPLACE FORCE VIEW forceview  
AS
SELECT a, b, c FROM xx ORDER BY a asc;
```

`경고: 컴파일 오류와 함께 뷰가 생성되었습니다. ` 

테이블 유무 상관없이 뷰를 생성하라는 뜻. 앞으로 xx테이블 만들거니까!
<br><br>

### NOFORCE 옵션

```sql
CREATE OR REPLACE NOFORCE VIEW noforceview
AS
SELECT a, b, c FROM xx ORDER BY a asc;
```

기존 테이블이 존재하지 않으면 뷰를 생성하지 않음. 기본적으로 적용되니 굳이 적지 않아도 상관 없다.  
<br><br>


### ALIAS 옵션

CREATE VIEW 로 만들어진 뷰의 칼럼명을 ALIAS를 통해 따로 지정할 수 있다.  
특히 수식을 사용한 표현식은 별칭을 주지 않으면 오류 나기 때문에 꼭 주어야함.  

```sql
CREATE VIEW tbl_empdept_view
AS
SELECT d.deptno, d.dname, e.empno, e.ename, sal + NVL(comm, 0)
FROM dept d, emp e
WHERE d.deptno = e.deptno;
```

오류 보고   
`ORA-00998: must name this expression with a column alias`

Sal + NVL(comm, 0)은 표현식인데 별칭을 주지 않아서 오류가 발생했다.  
 
별칭을 주는 방법은 2가지가 있다.  
1.	CREATE VIEW의 ALIAS 괄호안에 별칭 지정  
```sql
CREATE VIEW tbl_empdept_view
(dno, dname, eno, ename, pay)
AS
SELECT d.deptno, d.dname, e.empno, e.ename, sal + NVL(comm, 0)
FROM dept d, emp e
WHERE d.deptno = e.deptno;
```
 
2.	서브쿼리에서 AS로 별칭 지정  
```sql
CREATE VIEW tbl_empdept_view
AS
SELECT d.deptno dno, d.dname dname
     , e.empno eno, e.ename ename, sal + NVL(comm, 0) pay
FROM dept d, emp e
WHERE d.deptno = e.deptno;
```
![image2](/assets/DB/days11/image2.png){: .shadow}   

서브쿼리에 별칭지정 하여도 똑같다.
<br><br>
 
#### VIEW와 DML문 

  >VIEW에도 INSERT, DELETE, UPDATE 같은 DML을 사용해서 데이터 수정이 가능하다.  
  ```sql
  INSERT INTO tbl_emp_view (empno, ename) values(9999, 'admin');
  ```
  삽입된다!
  ```sql
  SELECT * FROM tbl_emp
  ```
  ![image3](/assets/DB/days11/image3.png){: .shadow}   

  >실제 테이블에도 들어간 걸 확인  
  ```sql
  UPDATE tbl_emp_view
  SET mgr = 7839, hiredate = sysdate
  WHERE empno = 9999;
  ```
  ![image4](/assets/DB/days11/image4.png){: .shadow}   

  >UPDATE역시 VIEW를 통해서 가능!


  >복합뷰를 사용해서 각각의 테이블에 데이터를 집어넣을 수 있을까?
  ```sql
  INSERT INTO tbl_empdept_view (dno, dname, eno, ename)
  VALUES(50, 'XXX', 6666, 'admin')
  ```

  `ORA-01779: cannot modify a column which maps to a non key-preserved table`

  **수식이 들어간 표현식이 있는경우** DML문 사용불가  

  **복합뷰**역시 일부의 경우만 DML문 사용이 가능하다.  



  **다음 사항 포함시 삭제 않됨**|**아래 포함시 수정 않됨**|**아래 포함시 추가 안됨**
  :-----:|:-----:|:-----:
  그룹함수 |그룹함수 |그룹함수 
  GROUP BY 절 |GROUP BY 절 |GROUP BY 절 
  DISTINCT 키워드 |DISTINCT 키워드 |DISTINCT 키워드 
  ROWNUM pseudo 컬럼 |ROWNUM pseudo 컬럼 |ROWNUM pseudo 컬럼 
  |표현식으로 정의된 컬럼 | 표현식으로 정의된 컬럼
  | | 뷰에 의해 선택되지 않은<br>NOT NULL 컬럼이 기본 테이블에 있을 때

  그룹함수 ~ ROWNUM pseudo칼럼이 VIEW에 있을경우 조회만 가능하고 DML은 사용 불가능하다.  
  표현식으로 정의된 칼럼이 VIEW에 있을경우 석재먼 가능하다.    
  <br><br>

### READ ONLY 옵션

`WITH READ ONLY` 옵션을 사용해서 DML을 사용해 **기본 테이블을 변경 못하도록 설정**한다.

```sql
CREATE OR REPLACE VIEW tbl_emp_view
AS
SELECT * FROM tbl_emp
WITH READ ONLY;
```
![image5](/assets/DB/days11/image5.png){: .shadow}   

```sql
INSERT INTO tbl_emp_view (empno, ename) values(9999, 'admin');
```

`SQL 오류: ORA-42399: cannot perform a DML operation on a read-only view`
`2399.0000 - "cannot perform a DML operation on a read-only view"`

READ ONLY 옵션을 적용했기 때문에 더이상 DML로 테이블 수정이 불가능하다.  
<br><br>



### CHECK OPTION

`WIT CHECK OPTION`을 사용하면 WHERE 조건문에 위배되는 행동은 하지 못하도록 에러를 반환한다.  
조건 칼럼 값을 변경하지 못하게 한다.  


**WITH CHECK OPRION의 기능**  
* 뷰를 통한 참조 무결성 검사  
* constraint의 적용  
* 데이터 검증 확인  

```sql
CREATE OR REPLACE VIEW tbl_emp_view
AS
SELECT * FROM tbl_emp
WHERE deptno=10; 
```

10번부서 사원만 빼서 VIEW로 생성

![image6](/assets/DB/days11/image6.png){: .shadow}   

VIEW를 SELECT하면 딱 10번 부서 사원만 검색된다.

10번부서만 갖고있는 `tbl_emp_view`를 통해 `20`번, `30`번 부서의 사원 데이터를 `INSERT`

```sql
INSERT INTO tbl_emp_view (empno, ename, deptno) values(8888, 'hongil', 20);
INSERT INTO tbl_emp_view (empno, ename, deptno) values(9999, 'admin', 30);
```

실제 tbl_emp테이블에도 해당 사원 정보가 들어간다.
```sql
SELECT * FROM tbl_emp
```

![image7](/assets/DB/days11/image7.png){: .shadow}   

10번 사원만 다루는 **뷰를 통해서** 20, 30번 사원을 **INSERT**하는 것이 취약해 보인다



이런일로 발생할 수 있는 불상사를 막기 위해 `WITH CHECK OPTION`을 사용할 수 있다.

#### 형식

```sql
CREATE VIEW 뷰이름
AS subquery
WITH CHECK OPTION CONSTRAINT constraint명;
```
tbl_emp_view에 `WITH CHECK OPTION` 적용  

```sql
CREATE OR REPLACE VIEW tbl_emp_view
AS
SELECT * FROM tbl_emp
WHERE deptno=10
WITH CHECK OPTION;
```

user_constraints 딕셔너리에서 확인 가능.

![image8](/assets/DB/days11/image8.png){: .shadow}   

```SQL
CREATE OR REPLACE VIEW tbl_emp_view
AS
SELECT * FROM tbl_emp
WHERE deptno=10
WITH CHECK OPTION CONSTRAINTS test_vw_ck;
```
`WIT CHECK OPTION`또한 제약조건의 일종이기 때문에 **제약조건명**을 줄 수 있음

이 상황에서 20번, 30번 부서 사원 데이터를 INSERT 하면 다음 오류가 발생한다.
`ORA-01402: view WITH CHECK OPTION where-clause violation`

그 외에 10번 부서 사원을 20번 부서로 바꾼다던지의 UPDATE문도 오류를 발생한다.

---

### user_views

뷰의 내부 구조를 보고 싶다면 `user_views` 데이터 딕셔너리를 확인

![image9](/assets/DB/days11/image9.png){: .shadow}   

지금까지 만들었던 VIEW 목록을 볼 수 있다.
 

---


## 시퀀스(Sequence 순서)

시퀀스란 유일한 숫자를 자동으로 생성하는 자동 번호 발생기(**oracle객체**)이다.  

테이블에 중복되지 않은 순서가 필요할 경우 사용한다 (글 번호 같은)


### 시퀀스의 특징
* 유일한 연속번호를 자동으로 생성  
* 기본키값 생성을 위해 사용  
* Application Code를 대채  
* 메모리에 Cache되어 access 효율성을 증가  
* 시퀀스는 여러 테이블에 의해 공유될 수 있다.   

```sql
INSERT INTO dept(deptno, dname, loc)
VALUES(50, '영업부', '서울');

INSERT INTO dept(deptno, dname, loc)
VALUES(60, '총무부', '서울');

INSERT INTO dept(deptno, dname, loc)
VALUES(70, '생산부', '서울');
```

부서를 더할 때마다 **기본키가 중복되는지 체크**하며 INSERT 해야 한다.  

값이 어떻게 되던지 상관없이 집어넣을때마다 10씩 증가하면 부서를 집어넣고 싶다면?

```sql
INSERT INTO dept(deptno, dname, loc)
VALUES((SELECT MAX(deptno)+10 FROM dept), '생산부', '서울'); 
```
`서브쿼리`를 사용해서 집어넣어도 된다!(이렇게 해야할 상황이 올 수 있다)

`SEQUNECE`를 사용하면 간단하게 해결 할 수 있다.  
<br><br>

 
### 시퀀스의 생성

다른 객체의 생성과 마찬가지로 create 문을 사용한다.  
옵션이 다양하므로 각 옵션의 순서와 옵션 생략시의 디폴트 값을 알아 둘 필요가 있다.  



### 형식
```sql
CREATE SEQUENCE 시퀀스명
[ INCREMENT BY 정수]
[ START WITH 정수]
[ MAXVALUE n ¦ NOMAXVALUE]
[ MINVALUE n ¦ NOMINVALUE]
[ CYCLE ¦ NOCYCLE]
[ CACHE n ¦ NOCACHE];
```


**옵션**|**설명**
:-----:|:-----
INCREMENT BY 정수 |시퀀스 번호를 정수만큼씩 증가(디폴트=1) 
START WITH 정수 |시작값을 지정(디폴트=1) cycle 옵션을 사용한 경우 다시 값을 생성할 때 minvalue에 설정한 값부터 시작 
MAXVALUE 정수 |증가할 수 있는 최대값 
NOMAXVALUE(default) |시퀀스의 최대값이 없음을 정의, 오름차순은 10^27까지 커질 수 있고, 내림차순으로 1까지 작아질 수 있음 
MINVALUE 정수 |생성할 수 있는 최소값 
NOMINVALUE(default) |시퀀스의 최소값이 없음을 정의, 오름차순은 최소 1까지, 내림차순으로 -(10^26)까지 간다. 
CYCLE |최대 또는 최소값에 도달한 후 값을 다시 생성 
NOCYCLE(default) |최대 또는 최소값에 도달한 후 값을 다시 재시작할 수 없음 
CACHE |빠른 access를 위해 시퀀스의 값을 메모리에 저장(기본 20) 
NOCACHE |어떤 시퀀스값도 캐싱되지 않음


`CREATE SEQUENCE`로 시퀀스 생성.  
```sql
CREATE SEQUENCE seq_deptno
START WITH 50 --생략시 1부터 시작한다
INCREMENT BY 10; --증가값 설정
```

시퀀스 확인은 `user_sequences` 딕셔너리에서 확인할 수 있다.  

![image10](/assets/DB/days11/image10.png){: .shadow}   


```sql
CREATE SEQUENCE seq_01; 
```
모든 옵션을 생략하고 생성

 
시작값 1부터 1씩 증가하는 시퀀스가 생성된다.  
`SELECT * FROM user_sequences;`  
![image12](/assets/DB/days11/image10.png){: .shadow}   


<br><br>
 
### Pseudo 컬럼을 이용한 시퀀스의 사용


sequence는 내부적으로 `CURRVAL`과 `NEXTVAL`이라는 `pseudo` 컬럼을 사용하여 값을 리턴한다.  

`CURRVAL`이 참조되기 전에 `NEXTVAL`이 먼저 사용되어야 한다.  
이는 pseudo 컬럼의 CURRVAL의 값은 NEXTVAL 컬럼 값을 참조하기 때문이다.  

그러므로 `NEXTVAL` **컬럼이 사용되지 않은 상태에서** `CURRVAL`을 사용하면 아무런 값이 없기 때문에 error를 출력한다.  


**Pseudo column**|**사용형식**|**설명**
:-----:|:-----:|:-----:
NEXTVAL |시퀀스명.NEXTVAL |새로 작성된 시퀀스의 다음 값을 반환 
CURRVAL |시퀀스명.CURRVAL |새로 작성된 시퀀스의 현재 값을 반환

누군가 1번 시퀀스를 뽑았다면 2번시퀀스가 대기중,  
NEXTVAL가 2이고 CURRVAL가 1이다.  

시퀀스를 만들고 바로 다음 쿼리를 실행하자
```sql
SELECT seq_deptno.currval
FROM dual
```

에러발생  
`--ORA-08002: sequence SEQ_DEPTNO.CURRVAL is not yet defined in this session`  

`currval`을 사용하기 위해선 적어도 한번의 `nextval`를 사용해야 한다.   

`nextval`을 해야 현재 어떤 `currval`이 대기중인지 알 수 있다.


#### 주의사항
1. NEXTVAL과 CURRVAL을 사용할 수 있는 경우  
- subquery가 아닌 SELECT 문  
- INSERT 문의 DML SELECT 문  
- INSERT 문의 DML VALUES 절  
- UPDATE 문의 SET 절  

2. NEXTVAL과 CURRVAL을 사용할 수 없는 경우  
- VIEW 문의 SELECT 문  
- DISTINCT 키워드를 사용한 SELECT 문  
- GROUP BY, AVING, ORDER BY를 이용한 SELECT 문  
- SELECT, DELETE, UPDATE 문에서의 subquery  
- CREATE TABLE, ALTER TABLE 명령문의 DEFAULT절  
 

시퀀스를 사용하여 `INSERT`  

```sql
INSERT INTO dept(deptno, dname, loc)
VALUES(seq_deptno.nextval, '총무부', '서울');

INSERT INTO dept(deptno, dname, loc)
VALUES(seq_deptno.nextval, '영업부', '서울');
```

![image11](/assets/DB/days11/image11.png){: .shadow}   
 

**시퀀스는 다시 예전 숫자를 뽑을수 없다.**  

때문에 dept테이블에서 50, 60을 지웠다면 다시 시퀀스를 사용해 50, 60번 부서를 INSERT 할 수 없다.  

시퀀스를 삭제하고 `START WITH 50` 으로 설정해서 다시 생성하여 사용할 수 밖에 없다.  
<br><br>

### 시퀀스 수정(ATLER SEQUENCE)

`ALTER SEQUENCE` 명령어를 사용하여 시퀀스의 각 옵션을 수정할 수 있다.  

하지만, **모든 값이 수정 가능한 것은 아니므로** 미리 잘 알아 둬야 한다.  

**ALTER SEQUENCE 주의사항**  
- START WITH 값은 시퀀스가 생성된 직후의 시작 값을 의미하므로 변경할 수 없다. 그러므로 **START WITH 값을 변경하려면 시퀀스를 다시 생성**해야 한다.  
- 시퀀스가 MAXVALUE 또는 MINVALUE에 도달하면 시퀀스값을 할당받지 못하므로 error가 발생한다.  
- 수정은 시퀀스의 소유자나 alter 권한을 가진자만 가능하다.  
- 변경 이후의 시퀀스 번호만 영향을 받는다.  
- 다른 번호로 다시 시작하려면, 시퀀스를 삭제한 후 다시 생성해야 한다.  
- cycle 옵션은 시퀀스의 고유특성을 위반하므로 기본 키(PRIMARY KEY)가 정의된 컬럼에서는 사용하지 않는다.  


#### 형식 
```sql
ALTER SEQUENCE 시퀀스명
[ INCREMENT BY 정수]
[ MAXVALUE n | NOMAXVALUE]
[ MINVALUE n | NOMINVALUE]
[ CYCLE | NOCYCLE]
[ CACHE n | NOCACHE];
```
예제
```sql
ALTER SEQUENCE dept_deptno
INCREMENT BY 20
MAXVALUE 500
NOCACHE
NOCYCLE;
``` 
<br><br>

### 시퀀스 삭제(DROP SEQUENCE)

`DROP` 문을 사용하여 시퀀스를 삭제한다.  
>삭제는 시퀀스소유자나 DROP ANY SEQUENCE 권한을 가진자만 가능하다.  


#### 형식
```sql
DROP SEQUENCE 시퀀스이름;
```
```sql
DROP SEQUENCE dept_deptno;
```
<br><br>



### 시퀀스 값의 간격이 발생하는 경우
- ROLLBACK이 발생한 경우
- system crash가 발생한 경우
- 다른 테이블에서 같은 시퀀스를 사용할 때




---

 
## 게시판 테이블 설계하기

게시판용 테이블을 하나 만들어보자  

![image13](/assets/DB/days11/image13.png){: .shadow}   


```sql
CREATE TABLE tbl_board(
  seq       NUMBER  NOT NULL CONSTRAINT pk_tblboard_seq PRIMARY KEY
, Name      VARCHAR2(20)  NOT NULL    
, Email     VARCHAR2(100)
, Password  VARCHAR2(20)  NOT NULL
, Subject   VARCHAR2(255)  NOT NULL
, Content   CLOB 
, Tag       CHAR(1)  default 'n'
, cnt       number DEFAULT 0
, UserIP    VARCHAR2(15)  NOT NULL
, Regdate   date  DEFAULT sysdate
);
```
그림 그대로 테이블 생성  

```sql
ALTER TABLE tbl_board
ADD CONSTRAINT ck_tblboard_tag CHECK(tag IN ('n', 'y'));
```
script 코드 사용 유무 칼럼인 tag칼럼은 `CHECK` 제약조건을 사용해 `n` , `y` 둘중 하나만 넣을 수 있도록 설정


게시판에선 글쓰기, 페이지 선택, 검색, 게시글 보기, 이메일 보내기 등의 작업이 있다.

### 글쓰기 작업

![image14](/assets/DB/days11/image14.png){: .shadow}   

글쓰기 버튼을 클릭하면 위와 같은 페이지가 뜰것이고  
작성 완료 버튼을 클릭하면 아래 쿼리가 DB로 날아가게 된다.  

```sql
INSERT INTO tbl_board
(seq, name, password, email, subject, content, tag, userip)
VALUES(seq_myboard.nextval, '김덕영', '1234$!', 'maestrody@origio.net', '헉.왜이렇게 썰렁해?', '이거 뭐야 \r\n무지하게 썰렁하네. -_-a', 'y', '127.0.0.1');
```

게시글이 하나 INSERT 되었다.

![image15](/assets/DB/days11/image15.png){: .shadow}   


<br><br>
 
### 검색 작업

#### 글쓴이 검색

```sql
SELECT * 
FROM tbl_board
WHERE subject LIKE '%검색어%';
```


#### 제목 검색

```sql
SELECT * 
FROM tbl_board
WHERE subject LIKE '%검색어%';
```


#### 내용 검색

```sql
SELECT * 
FROM tbl_board
WHERE content LIKE '%내용%';
```
<br><br>


### 게시글 보기 작업


```sql
SELECT name, email, subject, content, cnt, regdate
FROM tbl_board
WHERE seq = 1;
```

하고 끝일 것 같지만 **조회수 증가를 먼저 하고** SELECT로 조회해야 한다.

1번 작업
```sql
UPDATE tbl_board
SET cnt = cnt+1
WHERE seq = 1;
```
2번 작업
```sql
SELECT name, email, subject, content, cnt, regdate
FROM tbl_board
WHERE seq = 1;
```
![image16](/assets/DB/days11/image16.png){: .shadow}   

cnt가 1 증가했다.


만약 `UPDATE`는 실행됬는데 `SELECT`가 오류로 인해 실행되지 않았을 경우 조회수를 증가시키지 않아야 한다.  

`ROLLBACK`작업이 이루어 져야 하는데 이런 작업을 `트랜잭션 처리` 작업이라 한다.
<br><br>

### 게시글 삭제작업, 수정작업

게시글 삭제는 글쓴이, 관리자만 삭제할 수 있어야 한다.  
로그인을 통해 인증과정을 거쳤다면 확인가능하다.  
하지만 우리 게시판은 **비밀번호**를 입력해서 확인하는 것만 가능하다.  

1.	인증거치기  

```sql
SELECT DECODE('1234$!' ,
(SELECT password
FROM tbl_board
WHERE seq = 1), 'TRUE', 'FALSE')
FROM dual;
```


2.	삭제 혹은 수정하기  

```sql
DELETE FROM tbl_board
WHERE seq = 1;

UPDATE tbl_board
set password = '수정내용', subject = '수정내용'
  , content= '수정내용', tag = '수정내용'
WHERE seq = 1
```






### 게시글 목록 띄우기 작업

```sql
INSERT INTO tbl_board
(seq, name, password, email, subject, content, tag, userip)
VALUES(
  seq_myboard.nextval
, dbms_random.string('U', 5)
, '1234$!'
, dbms_random.string('A', 5)||'@origio.net'
, dbms_random.string('A', dbms_random.value(10,20))
, dbms_random.string('A', dbms_random.value(10,20))
, 'y', '127.0.0.1');
```

위의 쿼리를 70개정도 수행  
![image17](/assets/DB/days11/image17.png){: .shadow}   

이름, 이메일, 제목, 내용이 랜덤하게 채워졌다.  

75개가 넘는 게시글을 모두 한 목록 화면에 띄울 순 없다.  
 
만약 한페이지에 10개씩 뿌린다 하면 8페이지가 필요할 것이다.   

이렇게 하나의 페이지에 10개씩 또는 N개씩 뿌리는 작업을 **페이징 처리**라 한다.  

먼저 한화면에 게시글 몇 개 표시할건지, 그러면 몇페이지기 나오는지,   
다음버튼이 필요한지, 필요없는지, 마지막 페이지에는 몇 개의 게시글을 표시할건지 결정해야한다.  

쿼리도 75개의 ROW를 모두 알필요 없음으로 현제 페이지에 맞는 ROW행만 요청하면 된다.
 
#### 페이징 처리시 알아야할 정보

**총 게시글 수**  
`SELECT COUNT(*) FROM tbl_board;`  
67개 (8개 삭제함)  


**페이지 수**  
총 게시글 수를 알면 다음 과 같은 식으로 총 페이지 수를 구하면 된다.  

```sql
SELECT CEIL(COUNT(*) / 10) "총 페이지", COUNT(*) "총 게시글", 10 "출력 게시글"
FROM tbl_board;
```
![image18](/assets/DB/days11/image18.png){: .shadow}   


만약 내가 6번째 페이지를 보고 있다면 몇번째 ROW부터 10개를 가져와야 할까?

1번 페이지라면 1~10번
2번 페이지라면 11~20;
N번 페이지라면 `(N-1)*10+1 ~ N*10`

이런식으로 구하면 된다.
```sql
WITH temp2 AS(
    SELECT ROWNUM AS no, temp.*
    FROM
    (
        SELECT seq, name, email, subject, cnt, regdate
        FROM tbl_board
        ORDER BY seq desc
    )temp
)
SELECT temp2.* FROM temp2
WHERE temp2.no BETWEEN (:pn-1)*10+1 AND :pn*10;
)
```