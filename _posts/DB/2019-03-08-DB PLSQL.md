---
title:  "DB 14일차!"
# classes: wide
header:
  overlay_image: /assets/DB/dbimage.jpg
  caption: "Photo credit: [**oracle**](https://www.oracle.com)"

read_time: false
share: false
author_profile: false

categories:
  - DataBase

toc: true
toc_sticky: true

---


## PL SQL 개요

```sql
SELECT ename, sal, (SELECT MAX(sal) FROM emp) max_sal
FROM emp;
```

![image1](/assets/DB/days14/image1.png){: .shadow}  

 
서브쿼리를 12번 질의하고 서브쿼리 안에 있는 집계함수도 12번 호출된다.    
5000이란 MAX값은 **하나의 변수에 저장**하고 사용하면 좋겠지만 SQL문만으로는 불가능하다.   

**PL/SQL**을 사용하면 MAX를 변수에 넣고 한번만 함수 호출하면 된다.   


PL/SQL은 Procedural Language extensions to SQL(절차적으로 확장된 SQL)을 의미하며, 이는 **비절차적인 SQL 언어를 절차적으로 사용**할 수 있도록 한다.   


또한 PL/SQL은 절차적으로 표현하기 위해 다음 기능을 제공한다.  


- 변수를 선언할 수 있는 기능, 
- 참과 거짓을 구별할 수 있는 기능, 
- 반복문과 제어문 (흐름제어) 기능,
- 프로시저와 함수를 정의할 수 있는 기능
- 실행 오류를 찾아낼수 있는 기능(예외처리 가능)
- 원하는 곳으로 이동할 수 있는 기능 따위를 제공한다.

PL/SQL은 **블록 구조**로 된 언어이며,  
각각의 블록 내에 선언된 선언문은 선언된 블록 내에서만 유효하며 블록을 벗어나면 무효하다. (지역변수 같은)  


PL/SQL은 3개의 블록구조로 이루어진다.  
여기서 `EXCEPTION`, `DECLARE` 블록은 생략 가능하다. 

1. [DECLARE 블록]   - 선언문  
    변수나 상수를 선언하는 블록이다.  
2. BEGIN 블록       - 실행문  
   DECLARE블록에서 선언한 변수가지고 지지고 볶고 하는 블록  
   실행문은 반드시 존재해야 한다.  
3. [EXCEPTION 블록] - 예외처리문  

**형식**

```sql
 [ DECLARE ]
     -- 선언문(declarations)
 BEGIN
     -- 실행문(statements)
 END;
 [ EXCEPTION ]
     -- 예외 처리문(handlers
```

## PL/SQL의 종류

PL/SQL의 종류는 다음 6가지 종류가 있다.  

| | |
:-----|:-----
**anonymous procedure**<br>익명 프로시저|anonymous PL/SQL은 **DECLARE ...로 시작되며**, 사용자가 반복적으로 실행하려는 SQL문을 필요할 때마다 작성하여 실행하는 방법, 데이터베이스에 그 정보가 저장되지 않음 
**stored procedure**<br>저장 프로지서|**CREATE PROCEDURE name ...문에 의해서 생성**된 후, 데이터베이스 내에 그 정보가 저장됨.<br>stored procedure는 로직을 처리만 하고 끝남 
**stored function**|stored procedure와 같으며, stored procedure는 로직을 처리만 하고 끝나지만, stored function은 그 처리 결과를 사용자에게 반환함. 
**package**|자주 사용되는 여러 procedure, function들을 하나의 package묶어서 관리에 편리토록 함 
**trigger** |어떤 작업전, 또는 작업 후 trigger에 정의한 로직을 실행시키는 PL/SQL 블럭임. 
**object type** |객체에 데이터를 입력, 수정, 삭제, 조회하기 위해서는 반드시 PL/SQL 언어를 사용해야 함 

우리는 문법배우기 위해 `DECLARE`로 시작하는 `익명 프로시저`를 사용 중이다.   
다른 프로시저들은 실행하면 딕셔너리의 해당 내용이 (저장)올라가지만 `익명 프로시저`는 따로 딕셔너리에 저장되지 않는다.  


---

## PL/SQL의 작성요령

- 블럭 내에 SQL 문을 여러번 사용할 수 있음  
	블록내에서 실행된 SQL문의 **결과를 변수에 저장**하고 **다음 SQL문에 사용**할 수 있다.  

- 식별자는 최대 30문자로 작성  
	**변수명, 함수명, 프로시저명**을 **식별자**라 한다. (개인키를 식별자로 부르는 것 과 다른 의미이다)  

- 식별자는 테이블 또는 컬럼명과 같을 수 없음  
  
- 식별자는 알파벳으로 시작해야 함  
  
- 문자와 날짜 타입은 단일 인용부호로 표시함   
  
- 주석은 단일 라인인 경우 2개의 대시(--), 여러 라인 경우 /* ... */로 표기  
  
- 블럭 내에는 CREATEST, LEAST, DECODE, 그룹함수를 사용할 수 없음  




### dbms_output 패키지

이 패키지는 PL/SQL 내에서 처리된 어떤 결과를 사용자의 **화면에 출력**할 때 사용한다. (C언어의 `printf`와 유사)    

패키지 안의 출력을 위한 **함수**들은 다음과 같다.  

**함수명**|**설명**
:-----|:-----
put,<br>put_line |정의된 문자값을 화면에 출력하는 프로세서 
NEW_LINE |GET_LINE에 의해 읽힌 행의 다음 라인을 읽을 때 사용 
GET_LINE,<br>GET_LINES |현재 라인의 문자값을 읽는 프로세서 
ENABLE |화면에 문자값을 출력하는 모드로 설정하며 문자값을 지정할 수 있는 버퍼크기를 정의함 
DISABLE |화면에 문자값을 출력하는 모드로 해제함


```sql
DECLARE
    vnum NUMBER;
    vname VARCHAR2(20); --변수 선언마다 ; 를 붙여야 한다.
    PI CONSTANT NUMBER(5,2) := 3.14; --상수선언
    --오라클에선 대입연산자가 = 하나가 아니라 := 이다.
BEGIN
    vnum := 100;
    vname:='홍길동';
    dbms_output.put_line('>vnum = ' || vnum);
END;
```

![image2](/assets/DB/days14/image2.png){: .shadow}  

`DECLARE`에서 각종 변수를 선언하고  
`BEGIN`에 숫자형, 문자형 데이터를 집어넣고 출력.  


`>vnum = 100` 이 출력된다.  

위에서 12번이나 서브쿼리, 집계합수를 호출했던 질의문을 PL/SQL을 사용해서 바꿔보자.  

```sql
DECLARE
    vmax_sal emp.sal%type;
    vempno emp.empno%type;
    vename emp.ename%type;
BEGIN
    SELECT MAX(sal) 
        INTO vmax_sal
    FROM emp;
    
    SELECT empno, ename
    INTO vempno, vename
    FROM emp
    WHERE sal = vmax_sal;
    
    dbms_output.put_line(
    '>vempno = ' || vempno || ',' ||
    '>vename = ' || vename || ','
    );
END;
```
![image3](/assets/DB/days14/image3.png){: .shadow}  


이제 가장 큰 `sal` 를 가진 사원 검색도 PL/SQL을 사용해서 처리할 수 있다.

`vmax_sal`에 값을 집어넣고 해당 변수를 두번째 SELECT문에 사용해서 검색
 

### 작성요령 정리  

변수 선언, 쿼리문, 함수 사용 후 라인의 끝에는 항상 `;`을 붙인다.   
대입연산자는 `:=` 로 사용한다. (조금 헷갈린다...)  
`SELECT`로 절의한 결과를 변수에 대입하고 싶다면 `INTO` 연산자를 사용한다.  
>상수 선언은 변수선언 방법에 **CONSTANT**라는 예약어를 사용하면 된다.  

>참고로 **선언과 동시에 초기화**가 가능하다.  
```sql
DECLARE
    vmax_sal emp.empno%type := 7369;
...
```

 
보기에서 DBMS 출력창을 띄우고 + 버튼을 눌러 연결까지 하면 DBMS출력창에서 출력된다.



---

## DECLARE 블록 작성 

나중에 설명하겠지만 `DECLARE`블록을 사용하는 프로시저는 `익명 프로시저`이다.  
한번 실행되고 끝나는, 저장되지 않는 프로시저이다.  

PL/SQL 문법을 배우기 위해 당분간은 `DECLARE` 블록을 선언하는 `익명 프로시저`를 사용할 예정이다.  

### %type 

이 특성(attribute)은 원래의 컬럼이나 테이블의 데이터 타입을 그대로 상속하는 것이다.  
그러므로 원래의 컬럼이나 테이블의 데이터 타입을 변경하면 변경된 데이터타입이 그대로 상속된다.  

 
emp테이블의 모든 칼럼을 선언한 변수에 대입해보자.  
```sql
DECLARE
    vempno emp.empno%type;
    vename emp.ename%type;
    vjob emp.job%type;
    vmgr emp.mgr%type;
    vhiredate emp.hiredate%type;
    vsal emp.sal%type;
    vcomm emp.comm%type;
    vdeptno emp.deptno%type;
    --힘들다....
BEGIN
    SELECT *
    INTO 
    vemprow.empno,
    vemprow.ename,
    vemprow.job,
    vemprow.mgr,
    vemprow.hiredate,
    vemprow.sal,
    vemprow.comm,
    vemprow.deptno
    FROM emp
    WHERE empno = :pempno;
 
    dbms_output.put_line(
    '>empno = ' || vemprow.empno || ',' ||
    '>ename = ' || vemprow.ename || ','
    );
END;
```
![image4](/assets/DB/days14/image4.png){: .shadow}  



### %rowtype

위에서 각 칼럼의 변수를 선언하느라 많이 힘들었다....  
한 행(row, 레코드) 자체를 저장할 변수 타입이 있다!  

`rowtype` 을 사용하면 해당 테이블의 한 행의 값을 저장하는 변수 선언이 가능하다.  
이 특성은 원래의 테이블이 가지는 row의 특성을 모두 상속받는 것이다.
 


```sql
DECLARE
    vemprow emp%rowtype;
    --한 레코드를 저장할수있는 변수를 선언할 수 있다!
BEGIN
    SELECT *
    INTO vemprow
    FROM emp
    WHERE empno = :pempno;
 
    dbms_output.put_line(
    '>empno = ' || vemprow.empno || ',' ||
    '>ename = ' || vemprow.ename || ','
    );
END;
```
모든행을 `vemprow` 변수안에 한번에 집어넣기!  


물론 %rowtype을 사용해도 `*` 아닌 칼람을 각각 집어넣을 수 도 있다.   

```sql
DECLARE
    vemprow emp%rowtype;
BEGIN
    SELECT empno, ename
    INTO 
    vemprow.empno,
    vemprow.ename,
    FROM emp
    WHERE empno = :pempno;
 
    dbms_output.put_line(
    '>empno = ' || vemprow.empno || ',' ||
    '>ename = ' || vemprow.ename || ','
    );
END;
```
![image4](/assets/DB/days14/image4.png){: .shadow}  


 

### PL/SQL의 RECORD형 변수

테이블의 `행(row)`을 표현하기 위하여 `%rowtype`을 사용하여 레코드를 선언하지만, 레코드내의 데이터 **타입을 지정**하거나 **필드를 선언**할 수 없다.  

레코드는 유일한 필드이름을 가지며, 각 필드는 다른 데이터 타입을 가질 수 있다.  


**형식**  

```sql
TYPE [type명] IS RECORD 
  ( field_name1  datatype [[NOT NULL] { := ¦ DEFAULT} expr] 
    field_name2  datatype [[NOT NULL] { := ¦ DEFAULT} expr] 
    .................. 
  );
record명   type명;
```
구조체 같은 놈이네!  

**사용 예제**

```sql
DECLARE 
    TYPE dept_record_type IS RECORD(
      deptno	NUMBER(2),
      dname	VARCHAR2(13),
      loc		VARCHAR2(14) 
    );                             --레코드 타입 정의하고
    dept_record  dept_record_type; --레코드 타입 변수 선언하고
BEGIN
    dept_record.deptno := 10;
    dept_record.dname := '아리랑';
    dept_record.loc := 'Corea';
    dbms_output.put_line(dept_record.deptno || ',' || dept_record.dname || ',' || dept_record.loc);
END;
```

emp테이블에서도 `RECORD` 자료형을 가지고 값을 받아보자.  
```sql
DECLARE
    TYPE emp_type IS RECORD(
      ename emp.ename%type,
      sal emp.sal%type,
      pay NUMBER
    );
    emp_row emp_type;
    vempno NUMBER;
BEGIN
    vempno := :pempno;
    SELECT ename, sal, NVL(comm, 0)+sal pay
        INTO emp_row
    FROM emp
    WHERE empno = vempno;
    dbms_output.put_line(
    '>empno = ' || vempno || ', ' ||
    'ename = ' || emp_row.ename || ', ' ||
    'sal = ' || emp_row.sal || ', ' ||
    'pay = ' || emp_row.pay
    );
END;
```
`RECODE`변수도 `rowtype`처럼 한꺼번에 모든 칼럼을 집어넣을 수 있다.   


>PL SQL에서 UPDATE하기  

```sql
declare
    v_empno    number;
    v_ename    varchar2(14);
    v_job      varchar2(13);
begin
    select empno,ename, job
    into  v_empno, v_ename, v_job
    from emp
    where empno=7934;
    
    update emp set sal=sal*1.1
    where job=v_job;
end;
```

7934의 직업을 얻어와서 해당 직업의 sal를 10프로씩 인상!  
변수로 저장할 수있으니 다음 쿼리에도 써먹을 수 있다.  

>기존 CLERK 직업의 sal   
![image5](/assets/DB/days14/image5.png){: .shadow}  

>프로시저 실행후 바뀐 sal  
![image6](/assets/DB/days14/image6.png){: .shadow}  



---

## PL/SQL 제어문

### IF...THEN...ELSE 문

**형식**

```sql
IF 조건1 THEN 
수행문1; 
ELSIF 조건2 THEN 
수행문2; 
ELSIF 조건3 THEN 
수행문3; 
END IF;
```

주의할 점은 `ELSEIF` 가 아닌 `ELSIF` 라는 것....  

홀수, 짝수를 구하는 PL/SQL을 작성해보자  

```sql
DECLARE
    vnum NUMBER(2);
    vresult VARCHAR2(2 char);
BEGIN
    vnum := :num;
    IF MOD(vnum, 2)=0 THEN
        vresult := '짝수';
    ELSE
        vresult := '홀수';
    END IF;
        dbms_output.put_line(vresult || ' vnum = ' || vnum);
END;
```
![image7](/assets/DB/days14/image7.png){: .shadow}  


국어 점수를 입력받아 `수,우,미,양,가`를 출력  

```sql
DECLARE
    vkor NUMBER(2);
    vresult VARCHAR2(1 char);
BEGIN
    vkor := :num;
    IF vkor BETWEEN 90 AND 100 THEN
        vresult := '수';
    ELSIF  vkor BETWEEN 80 AND 89 THEN
        vresult := '우';
    ELSIF  vkor BETWEEN 70 AND 79 THEN
        vresult := '미';
    ELSIF  vkor BETWEEN 60 AND 69 THEN
        vresult := '양';
    ELSE
        vresult := '가';
    END IF;
        dbms_output.put_line(vresult || ' vkor = ' || vkor);
END;
```


### CASE 문

위의 점수별 등급 분류를 `IF`문 대신 `CASE`를 사용해서 출력해보자.  

```sql
DECLARE
    vkor NUMBER;
    result VARCHAR2(1 CHAR);
BEGIN
    vkor := :input;
    vkor := TRUNC(vkor/10);
    CASE WHEN vkor = 10 OR vkor = 9 THEN result := '수';
         WHEN vkor = 8 THEN result := '우';
         WHEN vkor = 7 THEN result := '미';
         WHEN vkor = 6 THEN result := '양';
         ELSE result := '가';
    END CASE;
    dbms_output.put_line('> 결과 = ' || result);
END;
```
>`TRUNC`를 사용하는게 더 좋은코딩...  


SQL 쿼리에서 쓰던 CASE와 약간 차이점이 있다.  
```sql
SELECT ename, deptno, sal,
CASE WHEN deptno = 10 THEN sal*1.5
     WHEN deptno = 20 THEN sal*1.8
     WHEN deptno = 30 THEN sal*2.0
     ELSE sal*1.0
END AS pay
FROM emp;
```   
`WHEN` 절이 끝날때마다 `;`을 붙인다.  
그 외의 문법은 비슷함.




### FOR문

**형식**
```sql
FOR counter IN [REVERSE] 시작수 .. 끝낼수 
    LOOP 
      실행문; 
    END LOOP;
```
VBA같은 FOR문 형식을 가지고 있다....


1 ~ 10 까지 출력하는 FOR문 예제  

```sql
DECLARE
    vi NUMBER; --반복변수
BEGIN
    FOR vi IN 1 .. 10
    LOOP
        dbms_output.put_line(vi);
    END LOOP;
END;
```
![image8](/assets/DB/days14/image8.png){: .shadow}  


10 ~ 1 까지 출력하는 FOR문 예제  

```sql
DECLARE
    vi NUMBER; --반복변수
BEGIN
    FOR vi IN REVERSE 1 .. 10
    LOOP
        dbms_output.put_line(vi);
    END LOOP;
END;
```
![image9](/assets/DB/days14/image9.png){: .shadow}  

큰수부터 작은수로 가는건 `REVERSE` 예약어를 사용하면 된다.  


사실 **반복변수** 굳이 **선언하지 않아도 된다!**  

```sql
DECLARE
BEGIN
    FOR i IN REVERSE 1 .. 10
    LOOP
        dbms_output.put_line(i);
    END LOOP;
END;
```
![image10](/assets/DB/days14/image10.png){: .shadow}  

`DECLARE`에서 `i` 라는 변수를 선언한적 없지만 바로 FOR문에서 사용중.  

https://kouzie.github.io/database/DB-11일차/#게시글-보기-작업  
11일차의 랜덤하게 데이터 입력하는 INSERT문 70번 수행하는것도 힘들었는데
이제 FOR문으로 간단하게 수행하자  

```sql
DECLARE
BEGIN
    FOR i IN REVERSE 1 .. 500
    LOOP
        INSERT INTO tbl_board
        (seq, name, password, email, subject, content, tag, userip)
        VALUES(
          seq_myboard.nextval
        , dbms_random.string('U', 5)
        , '1234$!'
        , dbms_random.string('A', 5)||'@origio.net'
        , dbms_random.string('A', dbms_random.value(10,20))
        , dbms_random.string('A', dbms_random.value(10,20))
        , 'y', '127.0.0.1');
        commit;
    END LOOP;
END;
```
![image11](/assets/DB/days14/image11.png){: .shadow}  


500개까지 FOR문을 통해 삽입된걸 알 수 있다.  
<br>


#### FOR문 사용 예제 1 - 1~pn 까지의 합 출력  
`예) 1+2+3+4+5+6+7+8+9+10=55`

>`EXIT`을 이용한 반복문 탈출  
FOR문 실행도중 빠져나오고 싶다면 `EXIT` 예약어 사용, java 반복문의 `break` 와 비슷한 역할이다.  

```sql
DECLARE
  vn NUMBER := :pn;
  vsum NUMBER := 0;
  vout VARCHAR2(1000);
BEGIN
   FOR i IN  1..vn
   LOOP
     vsum := vsum + i;
     dbms_output.put(i );
     EXIT when i=vn;
     dbms_output.put( '+' );
   END LOOP;
   dbms_output.put_line('=' || vsum);
END;
```
![image11-2](/assets/DB/days14/image11-2.png){: .shadow}  




### PL SQL WHILE문

**형식**
```sql
WHILE 조건 
LOOP 
  실행문; 
END LOOP; 
```

```sql
DECLARE 
  vi number := 1;
BEGIN
    WHILE ( vi < 10 )
    LOOP
        vi := vi + 1;
        dbms_output.put_line(vi);
    END LOOP;
END;
```

`WHILE`에 **괄호** 유무는 자유  

>무한 루프를 돌리고 싶다면 WHILE 없이 LOOP만 하면 된다.  
```sql
LOOP 
  EXIT WHEN 조건; 
  실행문; 
END LOOP; 
```
빠져나올 LOOP안에 조건을 정의하면 된다.  
<br>

#### WHILE문 사용 예제 구구단 출력

```sql
DECLARE 
  vi number := 2;
  vj number := 1;
BEGIN
    WHILE  vi < 10  --괄호는 묶어도 되고 안 묶어도 된다.
    LOOP
        vj := 1;
        WHILE ( vj < 10)
        LOOP
            dbms_output.put(vi || '*' || vj || '=' || vi*vj ||' ');
            vj := vj + 1;
        END LOOP;
        dbms_output.put_line(' ');
        vi := vi+1;
    END LOOP;
END;
```
![image11-1](/assets/DB/days14/image11-1.png){: .shadow}  



### PL/SQL GOTO문

PL/SQL의 GOTO문도 다른 언어의 GOTO문과 같은 역할을 한다.  
`Label`을 지정하고 해당 위치로 이동한다.  

```sql
DECLARE
    chk NUMBER := 0; 
BEGIN
    <<samplename>> --label명
    chk := chk +1; 
    dbms_output.put_line(TO_CHAR(chk)); 
    IF chk != 5 THEN
        GOTO samplename; 
    END IF; 
END;
```
![image16](/assets/DB/days14/image16.png){: .shadow}  

chk가 5가 아니라면 계속 위로 다시 돌려보낸다. 

GOTO문으로 FOR문처럼 사용 가능,  
GOTO문을 사용하기 위해선 `<<>>`로 감싼 `라벨명`이 필요하다.  

```sql
DECLARE
    vsum NUMBER := 0;    
BEGIN
    FOR i IN  1..10
    LOOP
    dbms_output.put(i);
    vsum := vsum + i;
    IF i = 10 THEN GOTO for_out;
    END IF;
    dbms_output.put( '+' );
    END LOOP;
    <<for_out>>
    dbms_output.put_line('=' || vsum);
END;
```
![image11-2](/assets/DB/days14/image11-2.png){: .shadow}  

FOR문 탈출조건으로 `EXIT`을 써도 되지만 `GOTO`문으로도 탈출 할 수 있다.

---
 
## PL/SQL CURSOR

많은 row(레코드)를 변수에 집어넣을 수 있을까?

```sql
DECLARE
    vename emp.ename%type;
BEGIN
    SELECT ename
        INTO vename
    FROM emp;
        dbms_output.put_line(
    '>vename = ' || vename || ','
    );
END;
```

`ORA-01422: exact fetch returns more than requested number of rows`
하나의 레코드만 저장할 수 있는 `vename`에는 다중 레코드를 저장할 수 없다.  

PL/SQL에서 **여러개의 처리결과를 담기위해서는 커서(cursor)**가 필요하다.  

`CURSOR`란 PL/SQL 블럭 내에서 실행되는 SELECT 문으로 처리된 **여러행의 결과가 메모리에 저장**되는데 이 메모리 영역을 가리키는 **일종의 포인터**이다.   

오라클에서는 여러 레코드로 구성된 작업영역 정보를 저장하기 위해서 `CURSOR`를 사용하며 다음과 같이 **2 종류로 분류**한다.  

**커서의 종류**  
1.	명시적 커서  
2.	묵시적 커서  


 

### 명시적 커서

`CURSOR` 자료형을 명시적으로 **선언, 초기화** 하고 사용하는 경우를 명시적 커서라 한다.  

먼저 간단한 예시를 보자.  
emp테이블의 사원 정보를 모두 읽어서 `c1`이라는 커서에 저장하고 출력한다. 

```sql
DECLARE 
    emp_rec emp%rowtype; 
    CURSOR c1 IS
    SELECT *
    FROM emp
    WHERE deptno = 10;
BEGIN 
    FOR emp_rec IN c1 
    LOOP
        dbms_output.put_line(
        '>deptno = ' || emp_rec.deptno || ', ' ||
        'ename = ' || emp_rec.ename || ', ' ||
        'job = ' || emp_rec.job || ', ' ||
        'sal = ' || emp_rec.sal || ', ' ||
        'comm = ' || emp_rec.comm || ', ' ||
        'hiredate = ' || emp_rec.hiredate
        );
    END LOOP;
END;
```
`DECLARE` 블록에 `c1`이란 커서를 선언하고 SELECT문을 사용해 `c1`이 가리키는 작업공간을 초기화한다.   
`emp_rec`라는 `%rowtype` 변수에 한 행씩 데이터 대입, 출력한다.  
![image13](/assets/DB/days14/image13.png){: .shadow}  

### 커서의 속성

커서를 실행한 후 그 실행 결과를 참조하기 위해서는 커서의 속성을 이용하면 간편해지는데, 그 속성과 의미는 다음과 같다.  

**속성**|**설명**
:-----|:-----
%ROWCOUNT|실행된 커서문장에서 읽힌 행의 수
%FOUND|실행된 커서문장에서 검색된 행이 발견되었는지 알 수 있는 속성
%NOTFOUND|실행된 커서문장에서 검색된 행이 발견되지 않았음을 알 수 있는 속성
%ISOPEN|선언된 커서가 현재 OPEN되어 있는지를 반환



### 명시적 커서의 실행절차  

**실행순서**|**설명**
:-----:|:-----
CURSOR 선언|실행하려는 SELECT 문을 작성
OPEN|CURSOR 선언에서 선언된 SELECT문의 실행을 의미
FETCH|open된 SELECT문에 의해 검색된 하나의 행 정보를 읽어옴<br>만약, 반환되는 결과가 여러 개인 경우, LOOP...END LOOP와 같은 반복문을 통해 마지막 행이 읽힐 때까지 계속 읽어 들이도록 함
CLOSE|선언된 SELECT 문의 선언을 종료함

순서는 4가지나 있지만 위의 코드는 `CURSOR선언`만 있지 `OPEN`, `FETCH`, `CLOSE` 같은 키워드는 보이지 않는다.  

이유는 **키워드는 생략**해도 4가지 과정은 **자동**으로 거치기 떄문!  

실행 절차를 적용해서 PL/SQL을 작성해보자.  
그리고 커서의 속성을 사용해서 PL/SQL을 작성해보자.   

```sql
DECLARE
    CURSOR emp_cursor IS  --1. CURSOR 선언
    (SELECT empno, ename, sal
    FROM emp);
    vempno emp.empno%type;
    vename emp.ename%type;
    vsal emp.sal%type;
BEGIN
    OPEN emp_cursor; --2. open, 선언된 SELECT문을 실행해서 결과물을 가져옴
    LOOP
        FETCH emp_cursor INTO vempno, vename, vsal; --3. fetch를 통해 한행을 가져온다.
        EXIT WHEN emp_cursor%NOTFOUND ;
        dbms_output.put_line(vempno || ' ' || vename || ' ' || vsal);
    END LOOP;
    CLOSE emp_cursor; --4. close
END;
```
![image14](/assets/DB/days14/image14.png){: .shadow}  

그냥 `LOOP`만 써서 무한루프로 돌리고 `EXIT`으로 빠져나오는 조건을 주었다.  
탈출 조건은 `%NOTFOUND`, 실행된 커서 문장에 검색된 행이 없다면 탈출한다.  

만약 5명만 읽어오고 싶다면 `%ROWCOUNT` 속성을 사용
```sql
DECLARE
    CURSOR emp_cursor IS-- 1. CURSOR 선언
    (SELECT empno, ename, sal
    FROM emp);
    vempno emp.empno%type;
    vename emp.ename%type;
    vsal emp.sal%type;
BEGIN
    OPEN emp_cursor; -- 2. open, SELECT문을 실행해서 결과물을 가져옴
    LOOP
        FETCH emp_cursor INTO vempno, vename, vsal; -- 3. fetch를 통해 한행을 가져온다.
        EXIT WHEN emp_cursor%ROWCOUNT > 5 OR emp_cursor%NOTFOUND ;
        dbms_output.put_line(vempno || ' ' || vename || ' ' || vsal);
    END LOOP;
    CLOSE emp_cursor; -- 4. clo
END;
```
![image15](/assets/DB/days14/image15.png){: .shadow}  

`%ROWCOUNT`가 5보다 크거나 `%NOTFOUND`라면 LOOP를 빠져나온다.  



---

### 명시적 커서 사용방법

방법 1
```sql
CURSOR [커서명]
IS
 [SELECT절];
OPEN [커서명];
FOR
LOOP
 FETCH [커서명] INTO [변수명];
 EXIT WHEN [조건절];
END LOOP;
CLOSE [커서명];
```

방법 2
```sql
CURSOR [커서명]
IS
 [SELECT절];
FOR [record명] IN [커서명] LOOP
   [처리부]
END LOOP;
```

지금까지 `방법 1`을 사용해서 커서의 절차를 알아 보았는데
`방법 2` 를 사용하면 `OPEN`, `FETCH`, `CLOSE`는 생략가능하다.
`OPEN`, `FETCH`, `CLOSE`과정 자체가 생략된 것이 아니다.  

```sql
DECLARE
    CURSOR emp_cursor IS-- 1. 커서 선언
    (SELECT empno, ename, sal
    FROM emp);
BEGIN
    FOR r IN emp_cursor
    LOOP
        EXIT WHEN emp_cursor%ROWCOUNT > 5 OR emp_cursor%NOTFOUND ;
        dbms_output.put_line(r.empno || ' ' || r.ename || ' ' || r.sal);
    END LOOP;
END;
```
`FOR r IN emp_cursor`에서 자동으로 `OPEN`되고 `r`에 자동으로 `FETCH`, `END LOOP`에서 자동 `CLOSE` 되는 것이지 이 과정 자체가 사라진 건 아니다.


 
### 묵시적 커서

`DECLARE` 블럭에서 따로 커서 선언 없이 자동으로 만들어지는 커서.  

~~사실 여러행을 저장하는 커서 외에 한행만 저장하는 자료형도 커서라 볼 수있다.~~   
~~SELECT 쿼리로 가져오는 결과를 저장하는 모든 변수를 묵시적 커서라 말할 수 있다. 헷갈린다.... 그냥 알고만있자...~~  

```sql
DECLARE 
BEGIN 
    FOR emp_rec IN(
      SELECT *
      FROM emp
      WHERE deptno = 10
    )
    LOOP
        dbms_output.put_line(
        '>deptno = ' || emp_rec.deptno || ', ' ||
        'ename = ' || emp_rec.ename || ', ' ||
        'job = ' || emp_rec.job || ', ' ||
        'sal = ' || emp_rec.sal || ', ' ||
        'comm = ' || emp_rec.comm || ', ' ||
        'hiredate = ' || emp_rec.hiredate
        );
    END LOOP;
END;
```

`emp_rec`를 자동으로 **커서(묵시적 커서)로 인식**한다.  
명시적 커서와 크게 다른점은 없다.  
그저 CURSOR 선언도 생략되고 FOR문쪽으로 내려갔을뿐...




### CURSOR(Subquery)

SELECT문으로 받아온 자료는 여러ROW 값이다.
이 **여러 ROW값을 하나의 자료형으로 받아올 수 있다.**

2차원 배열을 생각하면 좀 이해가 갈 듯 하다.

```sql
SELECT dname, CURSOR(
SELECT empno, ename, sal, comm
FROM emp
WHERE deptno = d.deptno
)
FROM dept d
ORDER BY dname asc;
```
CURSOR가 여러 레코드를 저장한 작업공간을 가리키는 변수이니 해당 작업공간 데이터 자체를 한 레코드에 모두 쑤셔 넣는다.  

출력 결과   
```
ACCOUNTING	{<EMPNO=7782,ENAME=CLARK,SAL=2450,COMM=null>,<EMPNO=7839,ENAME=KING,SAL=5000,COMM=null>,<EMPNO=7934,ENAME=MILLER,SAL=1300,COMM=null>,}
OPERATIONS	{}
RESEARCH	{<EMPNO=7369,ENAME=SMITH,SAL=800,COMM=null>,<EMPNO=7566,ENAME=JONES,SAL=2975,COMM=null>,<EMPNO=7902,ENAME=FORD,SAL=3000,COMM=null>,}
SALES	{<EMPNO=7499,ENAME=ALLEN,SAL=1600,COMM=300>,<EMPNO=7521,ENAME=WARD,SAL=1250,COMM=500>,<EMPNO=7654,ENAME=MARTIN,SAL=1250,COMM=1400>,<EMPNO=7698,ENAME=BLAKE,SAL=2850,COMM=null>,<EMPNO=7844,ENAME=TURNER,SAL=1500,COMM=0>,<EMPNO=7900,ENAME=JAMES,SAL=950,COMM=null>,}
```

직업별 2차원 배열안에 여러명의 사원 정보가 배열이 들어가듯이 결과가 출력된다!

데이터를 범위로 묶어서 관리할 때 편할 듯 하다.  

웹에서 테이블형식으로 부서별, 직업별 사원 정보를 출력하고 싶다면  
서브쿼리와 CURSOR를 사용해서 수월하게 처리 가능하다.  



---

## STORED PROCEDURE (저장 프로시저)

PL/SQL 종류 6가지중 두번째!


PL/SQL 언어 중에서 **가장 대표적인 구조**이며, 개발자가 자주 실행해야 하는 업무 흐름을 이 문법에 의해 미리 작성하여 데이터베이스 내에 저장해 두었다가 **필요할 때마다 호출하여 실행할 수 있다.**

사실 쿼리는 내부적으로 복잡한 과정을 거쳐 사용자에게 출력물을 제공한다.  
구문 분석 -> (옵티마이징 -> 컴파일) -> 실행 -> 결과 출력  

하지만 저장 프로시저(이하 SP)를 사용하면 옵티마이징과 컴파일 과정은 DB에 캐싱되어 저장되서 다시 할 필요가 없다.  

즉 SP를 사용하면 최적화 구문을 바로 수행한다. (이미 저장해 놓았으니까!) SP를 여러번 호출할 때 많은 성능향상이 있다.   

![image22](/assets/DB/days14/image15.png){: .shadow}  

출처: https://genesis8.tistory.com/183



### 형식

```sql
CREATE [OR REPLACE] PROCEDURE [프로시저이름]
    (argument1 [mode] data_type1,
    argument2 [mode] data_type2,
     ...............
IS [AS]
BEGIN
    ......
EXCEPTION
    ......
END;
```
- CREATE PROCEDURE (외부로 부터 받을 파라미터 정의)  
- IS (SP안에서 사용할 변수 정의, 선언, 초기화)  
- BEGIN (실행문)   
- EXCEPTION (예외처리문)  
4개 블록으로 나뉜다.  

### 삭제형식
```sql
DROP PROCEDURE [프로시져이름];
``` 

**프로시저이름**|**데이터베이스내에 저장될 프로시저 이름**
:-----|:-----
argument|운영체제에서 프로시저 내로 어떤 값을 전달할 때의 변수
mode|IN, OUT, IN OUT
data_type|argument변수의 데이터 타입
begin ... end|실행하려는 처리절차 블록

mode는 프로시저로 값을 집어넣을건지, 빼낼껀지, 둘다할건지 인듯...

하나씩 알아보자....

```sql
CREATE OR REPLACE PROCEDURE up_insertscore
IS
BEGIN
    INSERT INTO tbl_score(num, name, kor, eng, mat) 
    VALUES(1011, '고길동', 100, 100, 100);
    commit; --commit 중요!
--EXCEPTION
END;
```
`OR REPLACE`을 붙이면 `view` 생성 때 처럼 해당 이름의 SP가 이미 존재하더라도 수정된 SP로 다시 저장된다.
 

이제 `up_insertscore` SP를 호출해서 고길동 학생의 점수를 tbl_score테이블에 집어넣어 보자.



### STORED PROCEDURE 호출방법

SP호출방법은 3가지나 있다...

-	EXECUTE에 의한 실행  
  `EXECUTE up_insertscore;`  

-	anonymous procedure에서 호출에 의한 실행  
```sql
BEGIN
    up_insertscore;
END;
```

-	하나의 stored procedure에서 호출에 의한 실행  
  저장 프로시저 안에서 다른 저장 프로시저를 호출  

1번과 2번 방법을 통해 `up_insertscore` 수행  
![image18](/assets/DB/days14/image18.png){: .shadow}  


하지만 위의 프로시저는 고길동만 넣을 수 이 있다.  
당연히 변수로 작성해서 이름, 국, 영, 수 성적을 자유롭게 바꿀 수 있어야 한다.

`argument` 를 사용해서 밖에서 프로시저로 값을 집어넣어야 한다.
> argument 정읠할 때 타입설정만 해야한다. 만약 크기 설정시 오류난다.  

`CREATE PROCEDURE` 블럭의 괄호 안의 입력받을 `argument` 정의하는 곳이다.  
여러가지 방식으로 데이터 타입 설정이 가능하다.  

```sql
CREATE or REPLACE PROCEDURE up_insertscore(
    pnum IN NUMBER,
    pname VARCHAR2,
    pkor tbl_score.kor%type,
    peng NUMBER, --IN생략가능
    pmat IN NUMBER := 0
)
IS
BEGIN
    INSERT INTO tbl_score( num, name, kor, eng, mat)
    VALUES(pnum, pname, pkor, peng, pmat);
    commit; --commit 중요!
END;


EXECUTE up_insertscore(1012, '김길동', 100, 100, 100);
```
![image19](/assets/DB/days14/image19.png){: .shadow}  



### SP예제 - total, avg, grade까지 자동으로 계산해서 집어넣어 보자.  

```sql
CREATE or REPLACE PROCEDURE up_insertscore(
    pnum IN NUMBER,
    pname VARCHAR2,
    pkor tbl_score.kor%type,
    peng NUMBER, --IN생략가능
    pmat IN NUMBER := 0
)
IS
    vtot tbl_score.tot%type;
    vavg tbl_score.avg%type;
    vgrade tbl_score.grade%type;
BEGIN
    vtot := pkor + peng + pmat;
    vavg := vtot/3;
    CASE WHEN (pkor<40 OR peng<40 OR pmat <40) THEN vgrade := '과락';
         WHEN (vavg>= 60 AND pkor>=40 AND peng>=40 AND pmat>=40) THEN vgrade := '합격';
         ELSE vgrade := '불합격';
    END CASE;
    
    INSERT INTO tbl_score( num, name, kor, eng, mat, tot, avg, grade)
    VALUES(pnum, pname, pkor, peng, pmat, vtot, vavg, vgrade);
    commit; --commit 중요!
END;
```

기존 데이터를 삭제하고 다시 데이터 삽입  
```sql
DELETE FROM tbl_score WHERE num >=1011;

EXECUTE up_insertscore(1013, '장길동', 54, 59, 65);
```
![image20](/assets/DB/days14/image20.png){: .shadow}  




### SP예제 - rnk칼럼을 만들고 등수를 매기는 STORED PROCEDURE를 작성해보자.


```sql
ALTER TABLE tbl_score
ADD (rnk NUMBER(2));
```
```sql
CREATE OR REPLACE PROCEDURE up_makerank
IS
    tmprank NUMBER;
    CURSOR tots IS --SELECT한 결과물을 c1이라는 커서에 저장
    SELECT tot
    FROM tbl_score;
BEGIN
    FOR r IN (SELECT * FROM tbl_score)
    LOOP
        SELECT COUNT(*)+1 
            INTO tmprank
        FROM tbl_score 
        WHERE tot > r.tot;
        
        UPDATE tbl_score
        SET rnk = tmprank
        WHERE num = r.num;
    END LOOP;
END; 


EXECUTE up_makerank;
```
![image21](/assets/DB/days14/image21.png){: .shadow}  

 


## STORED PROCEDURE (저장 프로시저)2

## Stored Procedure & INSERT, DELETE

dept테이블에 부서를 INSERT하는 SP를 작성해보자  

먼저 부서 생성시마다 10씩 증가하는 시퀀스 생성

```sql
CREATE SEQUENCE seq_dept
    INCREMENT BY 10
    START WITH 50
    NOCACHE;
``` 

SP 작성
```sql
CREATE OR REPLACE PROCEDURE up_insertdept
(
    pdname VARCHAR2 := NULL ,
    ploc VARCHAR2 := NULL
)
IS
BEGIN
    INSERT INTO dept (deptno, dname, loc)
    VALUES(seq_dept.nextval, pdname, ploc);
    COMMIT:
END;
```
```sql
exec up_insertdept('영업부', '서울');
exec up_insertdept(pdname=>'생산부');
exec up_insertdept(ploc=>'부산');
```
SP의 어떤 파라미터에 어떤값을 넣을지 지정 가능하다.

![image1](/assets/DB/days15/image1.png){: .shadow}  

`NOT NULL` 설정이 없기때문에 `NULL`로 채워진다.  


부서 삭제

```sql
CREATE OR REPLACE PROCEDURE up_deletedept
(
    pdeptno NUMBER
)
IS
BEGIN
    DELETE FROM dept
    WHERE deptno = pdeptno;
    COMMIT;
END;


exec up_deletedept(70)
```
![image2](/assets/DB/days15/image2.png){: .shadow}  

70번 부서가 삭제됬다.  

이번엔 없는 부서를 한번 삭제해보자  
```sql
exec up_deletedept(90)
```
` PL/SQL 프로시저가 성공적으로 완료되었습니다.`

90번 부서는 없는데도 오류코드 없이 성공적 완료했다고 출력된다.  
(나중에 오류메세지가 뜨도록 고쳐야한다.)


---
 
## Stored Procedure & UPDATE

14일차의 Score를 `UPDATE`하는 SP 작성  

학생 이름, 국, 영, 수를 입력받고 총점, 평균, 결과를 자동으로 `UPDATE`한다.  

```sql
CREATE OR REPLACE PROCEDURE up_updatescore
(
    pnum IN NUMBER,
    pname tbl_score.name%type ,
    pkor IN NUMBER ,
    peng IN NUMBER ,
    pmat IN NUMBER
)
IS
    vtot tbl_score.tot%type;
    vavg tbl_score.avg%type;
    vgrade tbl_score.grade%type;
BEGIN
    vtot := pkor + peng + pmat;
    vavg := vtot/3;
    CASE WHEN (pkor<40 OR peng<40 OR pmat <40) THEN vgrade := '과락';
         WHEN (vavg>= 60 AND pkor>=40 AND peng>=40 AND pmat>=40) THEN vgrade := '합격';
         ELSE vgrade := '불합격';
    END CASE;
    
    UPDATE tbl_score
    SET name = pname, kor = pkor, eng = peng, mat = pmat, tot = vtot, avg = vavg, grade = vgrade
    WHERE num = pnum;
    
    COMMIT;
END;



exec up_updatescore(1007, '황길동', 89, 77, 100);
exec up_makerank;
SELECT * FROM tbl_score;
```
![image3](/assets/DB/days15/image3.png){: .shadow}  

1007의 정보가 황길동으로 업데이트!



이번엔 dept테이블의 부서정보를 UPDATE하자, 단 일부의 정보만 수정하면
수정안된 정보는 기존의 값을 사용하도록 설정.  


```sql
CREATE OR REPLACE PROCEDURE up_updatedept
(
   pdeptno dept.deptno%type
   , pdname dept.dname%type := NULL
   , ploc dept.loc%type default NULL
)
IS
   vdname dept.dname%type;
   vloc dept.loc%type;
BEGIN
    SELECT dname, loc 
        INTO vdname, vloc
    FROM dept
    WHERE deptno = pdeptno;
  
    UPDATE dept
    SET dname = CASE
                    WHEN pdname IS NULL THEN vdname
                    ELSE pdname
                END
        ,loc =  CASE
                    WHEN ploc IS NULL THEN vloc
                    ELSE ploc
                END
    WHERE deptno = pdeptno;
    COMMIT;
END;
```

SELECT로 기존의 정보를 `IS`블록에서 정의한 `vdname`, `vloc`에 저장해놓고 만약 입력 파라미터로 들어오지 않았다면 기존값을 적용한다.  

```sql
exec up_updatedept(60, pdname=> '관리부');
SELECT * FROM dept; 
```
![image4](/assets/DB/days15/image4.png){: .shadow}  

기존의 생산부였던 dname이 관리부로 변경되었다.  

### SP 내에서 정의한 매개변수 mode

`IS`블록에서 생략했던 `argument`의 `mode`에 대해서 알아보자.


**MODE**|**설명**
:-----:|:-----:
IN |운영체제상에서 정의한 값을 프로시져 내부로 전달할 때, 사용하는 IN 모드 매개변수임,<br>매개변수 이름과 함께 모드, 데이터 타입만 선언부에서 선언하면 됨 
OUT |프로시져 내에서 산출된 값을 운영체제상으로 전달할 때 사용하는 OUT 모드 매개변수임<br>매개변수 이름과 함께 모드, 데이터 타입만 선언부에서 선언하면 됨 
IN OUT |매개변수 용도가 IN과 OUT 모드의 2가지 모드로 사용될 경우에 정의됨 

운영체제에서(밖에서) 프로시저 파라미터로 값을 전달할때 IN을 쓰고  
프로시저에서(안에서) 운영체제로 값을 전달할때 OUT을 쓰고  
IN OUT은 둘의 역할을 모두 수행하는 mode이다.  

밑에서 설명할 `VARIABLE` 변수와 같이 알아보자.  

---

## VARIABLE 변수

VARIABLE 변수를 이용하면 **세션이 유지되는 동안** PL/SQL 코드에서 이용할 수 있는 **바인드 변수(bind variable)**를 만들 수 있다.

세선이 살아있는동안 사용할 수 있는 result라는 `variable을` 생성!
```sql
variable result NUMBER;
``` 
뒤에 **타입명**을 주어야한다.  

`variable;`
![image5](/assets/DB/days15/image5.png){: .shadow}  

현재 세션에서 살아있는 `variable`을  확인 가능  

세션을 끊고 다시 실행하면 검색하면  
`SP2-0568: No bind variables declared`  오류난다.


```sql
CREATE OR REPLACE PROCEDURE up_outtest
(
    pin1 IN NUMBER,
    pin2    NUMBER,
    pout OUT NUMBER --출력용 매개변수
)
IS
BEGIN
    pout :=  pin1 + pin2;
END;
```
`pout` 변수는 프로시저 밖으로 값을 전달하기 위해 `OUT mode`로 선언되었다.  
`pin1`과 `pin2`를 입력받아서 계산한 `pout`을 밖으로 전달해보자.  

```sql
exec up_outtest (100, 200, :result);
print result;
```
![image6](/assets/DB/days15/image6.png){: .shadow}  


이번엔 **익명 프로시저**를 사용해 VARIABLE 변수에 값을 대입해보자.  

바인드 변수 생성  
`VARIABLE va NUMBER;`  

익명 프로시저로 데이터 집어넣고
```sql
BEGIN
    :va := 55;
END;

print va;
```
![image7](/assets/DB/days15/image7.png){: .shadow}  

바인드 변수를 쓸땐 항상 앞에 `:`을 붙여 바인드 변수임을 명시해야 한다.  

>tip: SQL Developer에서 `ctrl+enter`또는 `F9`로 프로시저 실행시 입력창이 뜨는데 `F5`를 사용해서 스크립트 출력을 해야 제대로 수행된다.
>출처: https://stackoverrun.com/ko/q/1117034
 


입출력용 매개변수 `IN OUT mode`를 사용해보자.  

먼저 바인드 변수 `pnum` 생성
```sql
VARIABLE pnum VARCHAR2(15);

BEGIN
    :pnum := '010-1234-5678';
END;

print pnum;
```
![image8](/assets/DB/days15/image8.png){: .shadow}  

그리고 `IN OUT` 매개변수 `pphonnumber`선언  
`up_inouttest` SP는 `pphonnumber`의 앞글자 3개를 잘라서 다시 `pphonnumber`에 저장한다.  

```sql
CREATE OR REPLACE PROCEDURE up_inouttest
(
    pphonnumber IN OUT VARCHAR2
)
IS
BEGIN 
    pphonnumber := SUBSTR(pphonnumber , 0, 3);
end up_inouttest;
```

up_inouttest를 수행하고 다시 출력
```sql
exec up_inouttest(:pphonnumber);
print pphonnumber;
```
![image9](/assets/DB/days15/image9.png){: .shadow}  

`IN OUT`모드이기 때문에 입력된값을 바꿔서 다시 반환한다.

---

## Stored Function

PL/SQL 언어 중에서 `Stored function`은 `Stored procedure`와 개념이 동일하며, 동일한 기능을 가지고 있다.   
한가지 **차이점**은 stored procedure는 로직을 처리만 하고 끝내지만, `stored function`**은 그 처리 결과를 사용자에게 반환**하는 기능을 가지고 있는 점이 다르다.

즉 저장 프로시저와 저장 펑션의 차이는 반환값이 있고 없고...


### 형식

```sql
create [or replace] function [함수명](
    argument1 [mode] date_type1,
    argument2 [mode] date_type2,
    .........
    return data_type;
IS [AS]
BEGIN
    ..........
    return(변수);
EXCEPTION
    .........
END;
```

삭제 형식  
```sql
DROP function [함수명];
```



### 연습문제

주민등록번호를 넣으면 성별반환하는 함수를 만들자  

```sql
CREATE OR REPLACE FUNCTION fn_getGender(
    pssn VARCHAR2
)
RETURN VARCHAR2
IS
    vgender VARCHAR2(6) := '여자';
BEGIN
    IF MOD(SUBSTR(pssn, 8, 1), 2) = 1 THEN
        vgender := '남자';
    END IF;
    RETURN vgender;
END;
```

```sql
SELECT num, name, ssn, fn_getGender(ssn)
FROM insa
WHERE num < 1010;
```
SELECT 쿼리에서 정의한 `Stored Function` 사용!  
![image10](/assets/DB/days15/image10.png){: .shadow}  



**정수 2개를 입력받아 사이값을 합해서 반환하는 함수**  

```sql
CREATE OR REPLACE FUNCTION fn_sumN
(
    pnum1 NUMBER ,
    pnum2 NUMBER
)
RETURN NUMBER
IS
    vsum NUMBER := 0;
    vmax NUMBER := 0;
    vmin NUMBER := 0;
BEGIN
    IF (pnum1 >= pnum2) THEN
        vmax := pnum1;
        vmin := pnum2;
    ELSE
        vmax := pnum2;
        vmin := pnum1;
    END IF;
    
    FOR i IN vmin .. vmax
    LOOP
        vsum := vsum + i;
    END LOOP;
    RETURN vsum;
END;

SELECT fn_sumN(10, 3), fn_sumN(4, 10)
FROM dual;
```

![image11](/assets/DB/days15/image11.png){: .shadow}  


 
insa테이블에서 주민번호를 사용해 age와 birth를 구하는 함수를 만들어 보자.  

```sql
SELECT name, ssn, fn_getAge(ssn), fn_getBirth(ssn)
FROM insa;
```

**birth구하기**  

```sql
CREATE OR REPLACE FUNCTION fn_getBirth
(
    pssn insa.ssn%type
)
RETURN VARCHAR2
IS
    vcentury NUMBER;
    vgender NUMBER := SUBSTR(pssn, 8, 1);
    vbirth VARCHAR2(1000);
BEGIN
    vcentury := CASE – 첫 뒷자리가 1, 또는 2이면 1900년도
                    WHEN vgender IN (1, 2, 5, 6) THEN 19
                    WHEN vgender IN (3, 4, 7, 8) THEN 20
                    ELSE 18
                END;
    vbirth := vcentury || SUBSTR(pssn, 1, 6);
    vbirth := TO_CHAR(TO_DATE(vbirth, 'YYYYMMDD'), 'YYYY.MM.DD (DAY)');
    RETURN vbirth;
END;

SELECT name, fn_getBirth(ssn)
FROM insa;
```
![image12](/assets/DB/days15/image12.png){: .shadow}  


 
**나이 구하기**  

```sql
CREATE OR REPLACE FUNCTION fn_getAge
(
    pssn insa.ssn%type
)
RETURN NUMBER
IS
    vage NUMBER;
BEGIN
    vage := TO_CHAR(sysdate, 'YYYY') - SUBSTR(fn_getbirth(pssn), 0, 4);
    IF(TRUNC(sysdate) - TO_DATE(SUBSTR(pssn, 3, 4), 'MMDD')) <0 THEN
        vage := vage - 1;
    END IF;
    RETURN vage;
END;

만약 생일이 지났다면 기존 나이에 +1 한 만 나이를 구하자.

SELECT name, fn_getBirth(ssn), fn_getAge(ssn)
FROM insa;
```

![image13](/assets/DB/days15/image13.png){: .shadow}  

 
 

## PL/SQL 예외처리


지금까지 PL/SQL작성하며 `EXCEPTION` 블록을 한번도 사용한적 없는데 어떤 역할을 하는건지 알아보자.  

PL/SQL 블럭 내에서 SQL문을 정상적으로 처리하지 못하여 **발생하는 오류는 프로그램내에 에러를 직접 처리**해 주어야 한다.  
PL/SQL 블럭 내에 사용된 **SQL문의 에러 처리**는 `EXCEPTION`절에 정의하면 된다.  



예외처리 방법은 다음 4가지로 나뉜다.

- 미리정의된 에러처리방법 
- 미리 정의되지 않은 에러 처리방법 
- 사용자가 정의한 에러 처리방법 
- 예외 trapping 함수


### 미리정의된 에러처리방법 


```sql
DECLARE
    vnum NUMBER := 0;
BEGIN
    vnum := 10 / 0;
    dbms_output.put_line('success!!');
END;
```

예상대로 0으로 나누면 예외가 발생하면서 `ZERO_DEVIDE`오류를 반환한다.  
예외처리 블록을 사용해서 오류처리를 해보자.  
 
![image1](/assets/DB/days17/image1.png){: .shadow}  


오라클에서 제공하는 예측하여 이미 정의한 오류 목록은 다음과 같다.

**항목**|**에러 코드**|**설명**
:-----:|:-----:|:-----
NO_DATE_FOUND |ORA-01403 |SQL문에 의한 검색조건을 만족하는 결과가 전혀 없는 조건의 경우 
NOT_LOGGED_ON |ORA-01012 |데이터베이스에 연결되지 않은 상태에서 SQL문 실행하려는 경우 
TOO_MANY_ROWS |ORA-01422 |SQL문의 실행결과가 여러 개의 행을 반환하는 경우, 스칼라 변수에 저장하려고 할 때 발생 
VALUE_ERROR |ORA-06502 |PL/SQL 블럭 내에 정의된 변수의 길이보다 큰 값을 저장하는 경우 
ZERO_DEVIDE |ORA-01476 |SQL문의 실행에서 컬럼의 값을 0으로 나누는 경우에 발생 
INVALID_CURSOR |ORA-01001 |잘못 선언된 커서에 대해 연산이 발생하는 경우 
DUP_VAL_ON_INDEX |ORA-00001 |이미 입력되어 있는 컬럼 값을 다시 입력하려는 경우에 발생

위에서 발생했던 `ZERO_DEVIDE` 예외도 이미 정의된 오류이다.
앞으로 자주 접할 오류는 오라클에서 만들어 주었다....   
`no_data_found`, `too_many_rows`, 등등....  

`WHEN 오류코드 THEN` 형식으로 각 오류에 따른 처리 코드를 따로따로 작성 가능하다.  

```sql
CREATE OR REPLACE PROCEDURE test
(v_sal IN emp.sal%TYPE)
IS
  v_ename  emp.ename%TYPE;
BEGIN
  SELECT ename INTO v_ename FROM emp WHERE sal=v_sal;
  dbms_output.put_line('He id ' || v_ename || '!!!!');
EXCEPTION
  WHEN no_data_found THEN
   raise_application_error(-20002,'Data not found....');

  WHEN too_many_rows THEN
   raise_application_error(-20003,'Too Many Rows....');

  WHEN others THEN
   raise_application_error(-20004,'Others Error....');
END;
```
`test` SP는 단순히 sal를 입력받아서 해당 봉급을 받는 사원을 출력하는 SP이다.  
아무도 받지않는 봉급을 검색.  
`exec test(9999);`  
![image2](/assets/DB/days17/image2.png){: .shadow}  


2명 이상의 사원이 받는 봉급을 검색
`exec test(1250);`  
![image3](/assets/DB/days17/image3.png){: .shadow}  

 
 
### 미리 정의되지 않은 에러 처리방법 

**사용자가 직접** 에러 처리에 대한 논리적 흐름을 구현할 수 있다.  
`[PRAGMA EXCEPTION]`절은 오라클 서버에서 **어떤 에러 코드가 발생할 때** 정의한 **조건명을 지정**할 것인지를 정의하는 절이다.  

```sql
INSERT INTO emp(empno, ename, deptno)
VALUES (8888, 'hong', 90);
```
![image4](/assets/DB/days17/image4.png){: .shadow}  

90번 부서는 없기 때문에 참조무결성 위배로 에러가 발생한다.  
에러 코드는 `-02291` 이 정의되지 않은 예외를 처리해보자.   

```sql
CREATE OR REPLACE PROCEDURE hire_emp(
    v_emp_num     IN emp.empno%type,
    v_emp_name    IN emp.ename%type,
    v_dept_no     IN emp.deptno%type)
IS
    e_invalid_dept EXCEPTION; --사용자가 정의한 예외 객체
    PRAGMA exception_init (e_invalid_dept, -02291); --FK 관련 오류코드
BEGIN
    INSERT INTO emp (empno, ename, deptno)
    VALUES(v_emp_num, v_emp_name, v_dept_no);
    COMMIT;
EXCEPTION
    WHEN e_invalid_dept THEN
    raise_application_error(-20201, 'Deptno is not a valid department.');
END;
```
`e_invalid_dept`라는 예외객체를 **사용자가 직접 정의**하고 `-02291` 에러코드를 정의한 `e_invalid_dept` 예외객체에 지정한다.  

> `-20000~-20999` 까지 사용자가 임의로 지정할 수 있다  



### 사용자가 정의한 에러 처리방법 

**사용자가 미리 에러에 대한 정의**를 하는 경우이며,  
`EXCEPTION` 키워드에 의해 에러 조건명을 정의하고 `RAISE` 명령어에 의해 에러가 발생되면 `EXCEPTION` 절에서 에러가 처리된다.  

```sql
CREATE OR REPLACE PROCEDURE test5
(v_salIN emp.sal%TYPE)
IS
v_low_sal      emp.sal%type := v_sal - 100;
v_high_sal     emp.sal%type := v_sal + 100;
v_no_emp       number(7,2);

--사용자 정의 예외
e_no_emp_returned 	exception;
e_more_than_one_emp 	exception;

begin
select count(ename) into v_no_emp from emp
where sal between (v_sal - 100) and (v_sal + 100);
if v_no_emp = 0 then
raise e_no_emp_returned;
elsif v_no_emp > 0 then
raise e_more_than_one_emp;
end if;

exception
when e_no_emp_returned then
dbms_output.put_line('There is no employee salary...');
when e_more_than_one_emp then
dbms_output.put_line('There is a row employee....');
when others then
dbms_output.put_line('Any other error occurred......');
end;
```


### 예외 trapping 함수

이 방법은 사용자가 실행한 SQL 문이 실행될 때 **어떤 에러 코드와 에러 메시지가 발생하는지**를 **사용자가 직접 참조**하여 처리하는 방법이다.  
SQL 문을 실행한 후, SQLCODE 함수를 참조해 보면 SQL문의 실행 결과를 알 수 있다.


SQL문을 실행하면 정상적으로 실행되거나 문제가 생기거나 코드를 반환한다. 

**코드**|**설명**
:-----:|:-----
0 |에러 없이 정상적으로 실행되었음을 의미 
1 |사용자가 정의한 에러가 발생했음을 의미 
+100 |조건을 만족하는 행이 없음을 의미 
양수값 |다른 오라클 에러가 발생했음을 의미

```sql
CREATE OR REPLACE PROCEDURE test(
    p_sal  IN emp.sal%type
)
IS
    v_ename        emp.ename%type;
    v_err_code     number;
    v_err_message  varchar(255);

begin
    select ename into v_ename from emp
    where sal = p_sal;
    dbms_output.put_line('He is '|| v_ename  || '....');

exception
    WHEN no_data_found THEN
    v_err_code    := SQLCODE;
    v_err_message := SQLERRM; --SQL 에러 메세지
    dbms_output.put_line(v_err_code || '   ' || v_err_message);
    
    WHEN too_many_rows THEN
    raise_application_error(-20003, 'Too Many Rows...');
    WHEN others THEN
    raise_application_error(-20004, 'Others Error...');
END;

--sal와 같은 봉급을 받는 사원을 검색. 
exec test(1);
exec test(5000);
exec test(1250);
END;
```
`SQLCODE` 함수와 `SQLERRM` 함수를 사용해서 에러코드와 에러메세지를 받을 수 있다. `no_date_found`의 경우엔 에러를 발생하지 않고 dbms에 그냥 출력.  

사용자가 직접 `raise_application_error` 함수를 사용해서 에러를 발생시킨다.  

sal와 같은 봉급을 받는 사원을 검색하는데 결과는 다음과 같다.  

dbms 출력창  
```
100   ORA-01403: no data found

He is KING....
```

스크립트 출력창  
```
명령의 28 행에서 시작하는 중 오류 발생 -
BEGIN test(1250); END;
오류 보고 -
ORA-20003: Too Many Rows...
ORA-06512: at "SCOTT.TEST", line 21
ORA-06512: at line 1
```



## 콜렉션 (COLLECTION)

프로시저에서 배열처럼 사용할수 있는 변수를 찾아다니다가 콜렉션이란 걸 알게되었다.  

https://sites.google.com/site/smcgbu/home/gongbu-iyagi/plsqluiguseong-yoso

그중 `nested table` 이란 콜렉션이 내가 원하는 구조였고
간단하게 쓰기 위해 남기는 글

```
TYPE 타입명 IS TABBLE OF 요소데이터타입 [NOT NULL];
```

선언은 위와같이 하면 된다.


```sql
type arr_table is table of NUMBER(11);
numberlist arr_table := arr_table();
```
선언과 초기화는 별도 과정으로 각각 해주어야 한다.  
특히 초기화 안했다고 뜨는 오류때문에 처음에 많이 당황했다.  

```sql
ORA-06531: Reference to uninitialized collection
```
컴파일은 잘 되지만 실제 프로시저를 실행하면 위와같은 오류가 발생..  
초기화는 선언과 동시에 해주자...


`nested tabled`의 특징은 크기를 지정해줄 필요가 없다는것.  
원하는 만큼 나중에 늘릴 수 있다.

보통 FOR문을 통해 동적으로 크기가 결정될 때 가 많은데 `nested table`을 사용하면 편하다. (java의 arraylist같은)

`numberlist.extend;` 이런식으로 1개 공간만큼 늘릴 수 도 있고  
`numberlist.extend(3)` 한꺼번에 늘릴 수 도 있다.

FOR문을 돌며 한개늘리고 한개 집어넣고를 반복하면 된다.  

```sql
loop
    FETCH cur_loc INTO vcode;
    EXIT WHEN cur_loc%notfound;
    vnum := vnum+1;
    namelist.extend;
    namelist(vnum) := vcode;
end loop;
```

넣었으면 그만큼 FOR문을 돌며 출력하거나 값을 조작해야 하는데 `namelist.COUNT` 를 통해 얼만큼의 공간이 할당됐는지 알 수 있음.  

1 부터 시작함으로 `namelist(1)` 이런식으로 수를 늘려가며 출력하면 된다.  


나의 경우엔 읽어온 배열안에 해당 숫자가 포함되는지 구해야 하는 문제에 맞닥뜨려서 다음과 같은 쿼리를 날려야 했다.
```sql
SELECT * FROM test
WHERE num IN (numberlist);
```
당연히 오류가 났다....  
```
ORA-22905: cannot access rows from a non-nested table item
PLS-00642: local collection types not allowed in SQL statements
```
SQL문에선 Collection type이 안된다나 뭐래나....  또 찾아서 돌아다니다 보니 해결법을 알려준 사람이 많다.

type으로 정의하고 사용하면 된다고 함  
~~지금까지 type정의는 한번도 해본적이...~~  

```sql
CREATE OR REPLACE TYPE num_arr AS OBJECT
(testNumber NUMBER(11));

CREATE OR REPLACE TYPE numlist IS TABLE OF num_arr;
```

정의를 했으면 아래처럼 선언하고 초기화해서 사용하면 된다.

```sql
testlist numlist := numlist();
...
LOOP
  testlist(testlist.last) := N;
END LOOP;
```

collection이름.last하면 마지막위치 수를 반환한다.  
위처럼 하면 또 에러난다.....  
```
“ORA-06530: Reference to uninitialized composite” error
```

진짜 선언도 하고 초기화도 다 해줬는데 왜 오류나는지 기초가 없으니 알 수 가 없다...

type으로 정의한 collection을 사용할 때에는 아무리 안에 들어가는 자료형이 NUMBER라도 위처럼 초기화하면 안된다...

`testlist(testlist.last) := num_arr(N);` 요런식으로 Element를 초기화해서 집어넣어야 오류가 나지 않는다....

사실 패키지를 사용하면 이런식으로 복잡한 Collection을 사용하지 않아도 내가 원하는 기능을 구현 가능하다 하지만.... 패키지 배우는게 더 힘들거 같아서...

### 예제) 지역정보 기반 게시글 출력 프로시저


도로명 주소 개발자 센터에서 제공하는 DB를 사용한  
반경 10km 위치의 게시글 출력 프로시저  

> <a href="http://www.juso.go.kr/addrlink/addressBuildDevNew.do?menu=geodata">http://www.juso.go.kr/addrlink/addressBuildDevNew.do?menu=geodata</a>

`nested table Collection`을 위한 type정의    
![image21](/assets/project/dbproject/image21.png){: .shadow}  

검색 기준 위치를 같는 `Collection` 객체 생성  
![image22](/assets/project/dbproject/image22.png){: .shadow}  
![image24](/assets/project/dbproject/image24.png){: .shadow}  

조회한 정보를 `Collection` 객체에 저장 및 출력  
![image25](/assets/project/dbproject/image25.png){: .shadow}  
![image26](/assets/project/dbproject/image26.png){: .shadow}  
![image27](/assets/project/dbproject/image27.png){: .shadow}  

## 트리거(Trigger)

- trigger란 어떤 작업 전, 또는 작업 후 trigger에 정의한 로직을 실행시키는 PL/SQL 블럭이다.  
- trigger란 테이블에 미리 지정한 어떤 이벤트가 발생할 때 활동하도록 한 객체를 의미한다.  

**임의의 테이블에 대해 SQL 문장이 실행될 때 임의의 조건을 만족하는 경우 해당되는 명령을 처리하는 방식으로 사용된다.**  

트리거로 특정 작업의 행동을 **제한**할 수도 있다.  

개발자가 EMP 테이블에 대하여 월요일∼금요일 사이에 발생하는 테이블 변경 작업 이외에 주말에는 누군가에 의해 변경되는 것을 방지하기 위하여 `check_salary`라는 트리거를 생성하였다고 한다면 

데이터베이스 내에서 트리거가 가지는 조건의 테이블인 EMP에 어떤 이벤트(`update, insert, delete`)가 발생할 때마다 트리거가 생성될 때 정의된 `BEGIN ∼ END` 사이의 문장을 먼저 처리하게 된다.  

만약 어떤 사용자가 토요일에 EMP 테이블을 `UPDATE`하려고 한다면 그 `UPDATE`는 실행되지 않고 사용자의 화면에 지정된 메시지가 보이게 된다  


 
### TRIGGER의 구성

트리거의 **유형, 동작시기, 이벤트**의 종류에 따라 다음과 같이 분류된다.  

**구성요소**|**가능한 값**|**기능**
:-----:|:-----|:-----
트리거 유형 |문장 레벨의 트리거<br>행 레벨의 트리거 |트리거 몸체의 내용이 몇번이나 실행되는지
트리거 동작시기 |before<br>after |사용자가 트리거 이벤트를 유발시킬 때 언제실행할 것인지
트리거 이벤트 |insert<br>update<br>delete |테이블에 어떤 데이터 조작 연산이 트리거를 발생시키는지
트리거 몸체 |PL/SQL 블럭으로 begin ∼ end절 안에 정의 |어떤 이벤트가 발생하면 어떤 작업이 수행되는지..
트리거 조건 |when [조건] |사용자의 트리거 이벤트 중에 조건을 만족하는 데이터만 트리거 함

		



실행 시점과 범위를 조합하여 트리거는 다음 4가지로 분류한다.   

**실행시점**|**실행범위**|**내용**
:-----:|:-----:|:-----:
BEFORE|문장 레벨|SQL 문이 실행되기 전에 그 문장에 대해 한번 실행
BEFORE|행 레벨|DML 작업하기 전에 각 행에 대해 한번씩 실행
AFTER|문장 레벨|SQL 문이 실행된 후 그 문장에 대해 한번 실행
AFTER|행 레벨|DML 작업한 후 각 행에 대해 한번씩 실행


`BEFORE`와 `AFTER`의 차이는 해당 이벤트 **실행 후에 트리거를 작동**할 건지, **실행 전에 트리거를 작동**할 건지  

### 형식
```sql
CREATE [OR REPLACE] TRIGGER 트리거명 [BEFORE ¦ AFTER]
    trigger_event ON 테이블명
    [FOR EACH ROW [WHEN TRIGGER 조건]] --행 트리거 사용
DECLARE
    선언문
BEGIN
    PL/SQL 코드
END;
```
트리거의 블록은 `CREATE`, `DECLARE`, `BEGIN`, `END` 4가지로 나뉜다.  

>`SELECT * FROM user_triggers;`로 생성된 트리거 확인 가능하다.  
 

**예약어**|**설명**
:-----:|:-----:
BEFORE |구문을 실행하기 전에 트리거를 시작 
AFTER |구문을 실행한 후에 트리거를 시작
FOR EACH ROW |행 트리거임을 알림
REFERENCING |영향받는 행의 값을 참조
:OLD |참조 전 열의 값
:NEW |참조 후 열의 값


### 문장 레벨 트리거, 행 레벨 트리거

 
#### 문장 레벨 트리거

먼저 `tbl_exam1`, `tbl_exam2` 2개의 테이블 생성  

`tbl_exam1`에 레코드 `INSERT`, 자동으로 `tbl_exam2`에 로그를 기록하는 트리거 작성해보자.  

```sql
CREATE TABLE tbl_exam1(
      id NUMBER PRIMARY KEY
    , name VARCHAR2(20)
);


CREATE TABLE tbl_exam2(
      log VARCHAR2(100)
    , regdate date DEFAULT sysdate
);


CREATE OR REPLACE TRIGGER tri_insertExam2
AFTER
    INSERT ON tbl_exam1
BEGIN
    INSERT INTO tbl_exam2(log)
    VALUES('추가작업 - 로그');
END;
```

`AFTER` 예약어로 `INSERT` 이벤트가 발생하면 그 후에 `tbl_exam2`의 log칼럼에 **해당 문자열을 `INSERT`**한다.  

트리거는 자동으로 `BEGIN`블록에서 수행한 DML을 `COMMIT`하기 때문에 따로 작성할 필요가 없다..  
```sql
INSERT INTO tbl_exam1
VALUES(1000, 'admin');
```
`Tbl_exam1`에 값을 집어넣으면 다음과 같이 `tbl_exam2`에도 트리거에 의해 지정한 값이 들어간다.  

`SELECT * FROM tbl_exam1;`  

![image4](/assets/DB/days16/image4.png){: .shadow}  

`SELECT * FROM tbl_exam2;`  

![image5](/assets/DB/days16/image5.png){: .shadow}  

 
항상 추가작업(`INSERT`)만 주구장창 써넣을 순 없으니 `INSERT`, `DELETE`, `UPDATE` 별로 로그내용을 달리해보자  

```sql
CREATE OR REPLACE TRIGGER tri_insertExam2
AFTER
INSERT OR UPDATE OR DELETE ON tbl_exam1
DECLARE
  vmessage VARCHAR2(100);
BEGIN
   IF INSERTING THEN
     vmessage := '> 추가 작업 - 로그';
   ELSIF UPDATING THEN
     vmessage := '> 수정 작업 - 로그';
   ELSIF DELETING THEN
     vmessage := '> 삭제 작업 - 로그';
   END IF; 
   
   INSERT INTO tbl_exam2 ( log ) 
   VALUES ( vmessage );
END;
```


`AFTER`블럭 뒤에 3가지 작업 모두 추가  
`INSERT OR UPDATE OR DELETE ON tbl_exam1`  

`IF`문에서 쓰이는 `INSERTING`, `UPDATING`, `DELETING` **예약어** 기억하자.  
해당 작업이 일어날 때 키워드와 IF문으로 이벤트별 수행할 코드를 지정할 수 있다.  

```sql
INSERT INTO tbl_exam1 VALUES ( 1000, 'admin' );
UPDATE tbl_exam1 SET name = '김길동' WHERE id = 1000;
DELETE FROM tbl_exam1 WHERE id = 1000;
```

`Tbl_exam2` 테이블을 조회해보면 다음과같이 트리거에 의해 값이 `INSERT`되어있다.  
![image6](/assets/DB/days16/image6.png){: .shadow}  

 
특정 조건이 성립되면 트리거에 의해 **해당 작업을 수행 못하도록** 할 수 있다.  

근무시간에만 `tbl_exam1`에 DML문을 작성할 수 있도록 트리거 작성해보자.   

먼저 오라클에서 제공하는 오류를 발생시키는 프로시저를 알아야 한다.  
`raise_application_error();`

오라클에서 제공하는 프로시저로 **특정 조건을 충족하면 에러를 강제로 발생시킨다.**  

에러코드를 `-20000~-20999` 까지 사용자가 임의로 지정할 수 있다.  


```sql
raise_application_error(-20001, 'test - error message');
```
![image7](/assets/DB/days16/image7.png){: .shadow}  


트리거를 사용해서 진행중이던 작업을 중단시킬 방법도 알았으니 작업을 제한하는 트리거를 작성해보자  

```sql
CREATE OR REPLACE TRIGGER tri_stopWork
    BEFORE -- 해당 작업이 수행되기 전에 막기위해 BEFORE 예약어를 사용
    INSERT OR UPDATE OR DELETE ON tbl_exam1
BEGIN
    IF(TO_CHAR(sysdate, 'DY') IN ('토','일') 
    OR TO_CHAR( sysdate , 'HH24') < 12
    OR TO_CHAR( sysdate , 'HH24') > 18 
    ) THEN
        raise_application_error(-20001, '지금은 근무시간이 아닙니다.');
    END IF;
END;

INSERT INTO tbl_exam1
VALUES(1004, '황길동');
```
![image8](/assets/DB/days16/image8.png){: .shadow}  

12~18시 외에 시간에 값을 집어넣으면 다음과 같이 오류를 반환한다.  


 
#### 행 레벨 트리거

행트리거와 문장트리거의 차이는 다음과 같다.

한 테이블에 DELETE문으로 5개의 ROW를 삭제할 때 행트리거는 5번 트리거가 발생하고  
한 테이블에 DELETE문으로 5개의 ROW를 삭제할 때 문자 트리거는 한번 트리거가 발생한다.  

즉 DML에 영향받는 ROW 개수만큼 행트리거는 작동한다.  

또한 단순히 지정한 테이블에 DML이 일어나는걸 확인하는 문장 트리거와는 달리 행드리거는 DML로 인해 어떠한 값이 추가, 삭제, 변경되었는지 확인 가능하다.  


행 레벨 트리거는 처음 블럭에 `FOR EACH ROW` 예약어가 사용되고   
`:new`, `:old` 예약어를 사용해서 DML로 인해 어떤 값이 추가, 삭제, 변경되었는지 구할 수 있다.  

행 레벨 트리거에서 컬럼의 실제 데이터값을 제어하는데 사용하는 연산자는 `:OLD`와 `:NEW`이다.  
이 연산자와 함께 컬럼명을 함께 기술한다.  
예를 들어, 컬럼명이 `sal`이라고 하면, 변경전의 값은 `:OLD.sal`이고 변경 후의 값은 `:NEW.sal`처럼 표기한다.  

`detp` 테이블이 변할때마다 정보를 저장할 `dept_same` 테이블 생성  

```sql
create table dept_same(
    deptno     number(2),
    dname      varchar2(14),
    loc        varchar2(10),
    o_deptno   number(2),
    o_dname    varchar2(14),
    o_loc      varchar2(10),
    gubun      varchar2(10),
    chk_date   date default sysdate
);
```

어떠한 값이 입력됐고, 수정됐고, 삭제됐는지 기록하는 `행 레벨 트리거` 작성  

```sql
CREATE OR REPLACE TRIGGER test2_trigger
AFTER
    INSERT OR DELETE OR UPDATE IN dept
    FOR EACH ROW -- 행트리거 필수 선언
BEGIN
    IF INSERTING THEN
        INSERT INTO dept_same(deptno, dname, loc, gubun)
        VALUES(:new.deptno,:new.dname,:new.loc, '입력');
    ELSIF UPDATING THEN
        INSERT INTO dept_same(deptno,dname,loc,o_deptno,o_dname,o_loc,gubun)
        VALUES(:new.deptno,:new.dname,:new.loc, :old.deptno,:old.dname,:old.loc, '수정');
    ELSE DELETING THEN
        INSERT INTO dept_same(deptno,dname,loc,gubun)
        VALUES(:old.deptno,:old.dname,:old.loc, '삭제');
    END IF;
END;
```

```sql

INSERT INTO dept
VALUES(90, 'XXXX', 'YYYY');

UPDATE dept
SET dname = 'ZZZZ', loc = 'QQQQ'
WHERE deptno = 90;

DELETE FROM dept WHERE deptno = 90;
```

![image9](/assets/DB/days16/image9.png){: .shadow}  


`INSERT`할 때 들어간 첫번째 행의 `:old.deptno`, `:old.dname`, `:old.loc` 는 애초에 집어넣지도 않았다.  
`INSERT`하는데 그전에 있는 값이 있을리가 없기 때문.  

`DELETE`또한 삭제할 때 새로 집어넣을 값이 없기 때문에 `new` 값이 생기지 않는다.
 
반면 `UPDATE`는 새로 집어넣은값이 `new`로 들어가고 기존에 있던 값이 `old`로 들어간다.  

 
15일차에 학사 관리 테이블과 SP를 만들었었다.  

이름이 들어가면 자동으로 합계, 평균도 구해서 테이블에 `INSERT`하는 SP를 작성하였는데  
이번엔 트리거를 사용해서 국,영,수 점수가 들어가면 자동으로 총합, 평균이 있는 테이블로 `UPDATE`되도록 트리거를 설정해보자.  


학번, 이름, 국,영,수 를 저장할 `rowTrigger01` 테이블 생성  

```sql
CREATE TABLE tbl_rowTrigger01(
      hak VARCHAR2(10) PRIMARY KEY
    , name VARCHAR(20)
    , kor NUMBER(3)
    , eng NUMBER(3)
    , mat NUMBER(3)
);
```

학번, 총점, 평균을 저장할 `rowTrigger02` 테이블 생성.

```sql
CREATE TABLE tbl_rowTrigger02(
      hak VARCHAR2(10) PRIMARY KEY
    , tot NUMBER(3)
    , avg NUMBER(5,2)
    ,
    constraint fk_tbl_hak foreign key(hak) 
    references tbl_rowTrigger01(hak)
)
```

`rowTrigger01`테이블에 `INSERT`, `UPDATE`, `DELETE` 작업이 일어나면 총점, 합계를 구해서 `rowTrigger02`에 자동 삽입.

```sql
CREATE OR REPLACE TRIGGER tri_score_insert
    AFTER
    INSERT OR UPDATE OR DELETE ON tbl_rowTrigger01
    FOR EACH ROW
DECLARE
    vtot NUMBER(3);
    vavg NUMBER(5,2);
BEGIN
    vtot := :NEW.kor + :NEW.eng + :NEW.mat;
    vavg := vtot / 3;
    IF INSERTING THEN
        INSERT INTO tbl_rowTrigger02
        VALUES(:NEW.hak, vtot, vavg);
        
    ELSIF UPDATING THEN
        UPDATE tbl_rowTrigger02
        SET tot = vtot, avg=vavg
        WHERE hak = :OLD.hak;
        
    ELSIF DELETING THEN
        DELETE FROM tbl_rowTrigger02
        WHERE hak = :OLD.hak;
    END IF; 
END;
```



```sql
INSERT INTO tbl_rowTrigger01
VALUES(1, 'aaa', 10, 20, 30);

INSERT INTO tbl_rowTrigger01
VALUES(2, 'bbb', 41, 46, 12);
```
![image10](/assets/DB/days16/image10.png){: .shadow}  

트리거에 의해 `tbl_rowTrigger02` 테이블에 자동으로 값이 `INSERT`되었다.  

```sql
UPDATE tbl_rowTrigger01
SET kor = 100 , eng= 100, mat =100
WHERE hak=1;

DELETE FROM tbl_rowTrigger01
WHERE hak=2;
```
![image11](/assets/DB/days16/image11.png){: .shadow}  
`UPDATE`, `DELETE` 역시 트리거에 의해 `tbl_rowTrigger02` 테이블에 자동 반영된다.  
 
```SQL
procedure print_ename(p_empno number) is 
    l_ename emp.ename%type; 
  begin 
    select ename 
      into l_ename 
      from emp 
      where empno = p_empno; 
     dbms_output.put_line(l_ename); 
   exception 
     when NO_DATA_FOUND then 
       dbms_output.put_line('Invalid employee number'); 
   end print_ename; 

 procedure print_sal(p_empno number) is 
   l_sal emp.sal%type; 
 begin 
   select sal 
     into l_sal 
     from emp 
     where empno = p_empno; 
   dbms_output.put_line(l_sal); 
 exception 
   when NO_DATA_FOUND then 
     dbms_output.put_line('Invalid employee number'); 
 end print_sal; 

 end employee_pkg; 
```


## 패키지(Package), 동적쿼리

### package

PL/SQL의 패키지는 관계되는 `타입`, 프로그램 `객체`, `서브프로그램(procedure, function)`을 **논리적으로 묶어 놓은 것**은 의미한다.  

오라클에서 기본적으로 제공하는 패키지가 있으며, 우리가 전에 사용하면 dbms_output또한 패키지의 일종이다.  

오라클에서 제공하는 페키지의 사용법을 익혀두면 편할듯.....

패키지는 `specification`과 `body` 부분으로 되어 있으며, 

-	specification 부분은 type, constant, variable, exception, cursor, subprogram이 선언된다.  

-	body 부분은 cursor, subprogram 따위가 존재한다.  

호출할 때 `패키지_이름.프로시저_이름` 형식의 참조를 이용해야 한다.  

패키지를 정의해서 사용하는 이유는 자바의 패키지 사용이유와 비슷하다.  
묶어두고 편리하게 사용도 가능하고 패키지를 사용함으로써 구현 가능한 기능도 여럿 있다. ~~나중에 DB일을 하게되면 공부하자..~~

#### 패키지 명세(specification)부분 정의

밑의 2가지 서브프로그램(Procedure)이 정의되어있는 패키지임을 알림  

```sql
CREATE OR REPLACE PACKAGE employee_pkg as 
    procedure print_ename(p_empno number); 
    procedure print_sal(p_empno number); 
end employee_pkg; 
```

<br><br>

#### 패키지 몸체(body) 정의

```sql
CREATE OR REPLACE PACKAGE BODY employee_pkg as 
    procedure print_ename(p_empno number) 
    is 
    l_ename emp.ename%type; 
    begin 
        select ename 
        into l_ename 
        from emp 
        where empno = p_empno; 
        dbms_output.put_line(l_ename); 
        exception 
        when NO_DATA_FOUND then 
        dbms_output.put_line('Invalid employee number'); 
    end print_ename; 
    

    procedure print_sal(p_empno number) 
    is 
        l_sal emp.sal%type; 
    begin 
        select sal 
        into l_sal 
        from emp 
        where empno = p_empno; 
        dbms_output.put_line(l_sal); 
    exception 
        when NO_DATA_FOUND then 
        dbms_output.put_line('Invalid employee number'); 
    end print_sal; 
end employee_pkg; 
```

몸체에선 명세부분에서 선언했던 프로시저, 각종 타입에 대한 정의를 해주면 된다.  
정의 방법은 우리가 지금까지 프로시저 만들 때와 똑같지만 `CERATE [OR REPLACE] PROCEDURE` 가 아닌 그냥 `PROCEDURE`만 앞부분에 쓰면 된다.

`print_ename`은 사원번호를 입력하면 이름을 출력하고 해당 사번의 이름이 없다면 해당 사번이 없다고 출력하는 간단한 프로시저.  

`print_sal`은 이름이 아닌 salary를 출력한다.  

```sql
exec employee_pkg.print_ename(7369);
exec employee_pkg.print_sal(7369);
```

DBMS출력  
```
SMITH

800
```
![image2](/assets/DB/days18/image2.png){: .shadow}  
 
### 동적(Dynamic) SQL

응용프로그램에서 자주 실행되는 SQL문들이 여러번 반복적으로 쓰일 때 반복적으로 작성하여 실행해야 한다.  

즉 사용자가 사용하는 순간에 쿼리를 생성해서 실행하는것.  


다나와에서 제공하는 검색 조건이다
![image6](/assets/DB/days18/image6.png){: .shadow}  

체크하는 옵션에 따라 SELECT에 들어가는 조건문이 계속 변경될 것이다.

그럼 체크의 가지수만큼 쿼리를 만들어 놔야 할까?  

동적쿼리를 사용하면 하나만 만들어도 된다.

#### 동적쿼리가 필요할 때

1.	컴파일시에 SQL확정이 되지 않은 경우  
  위와 같은 경우  

2.	PL/SQL 블록상에 DDL문을 사용하는 경우  
  게시글 쓸 때 카테고리 나눌 때가 있다. 그럴때 사용함


3.	PL/SQL 블록상에서 ALTER SYSTEM/SESSION 명령어를 실행할 경우  
  DBA가 주로 하지만 알아만 두자

#### 동적SQL 사용하는 방법
1.	원시적 동적 SQL (Native Dynamic SQL NDS)
~~2.	dbms_sql 패키지 사용~~ (패키지는 잘 모름으로 생략....)


```sql
DECLARE
    vsql VARCHAR2(1000); 
    vcondition NUMBER(1) := 1;
    vdeptno emp.deptno%type;
    vename emp.ename%type;
    vjob emp.job%type;
BEGIN
    vsql := ' SELECT deptno, ename, job ';
    vsql := vsql || ' FROM emp ';
    IF vcondition = 1 THEN
        vsql := vsql || ' WHERE empno = 7369 ';
    
    ELSIF vcondition = 2 THEN
        vsql := vsql || ' WHERE ename = ''ALLEN''' ;
    END IF;
    execute immediate vsql 
    INTO vdeptno, vename, vjob;
    dbms_output.put_line(vdeptno||', '|| vename||', '|| vjob);
END;
```
문법을 익히기 위해 익명프로시저로 동적쿼리를 작성해보자.  

`vcondition`의 값에 따라서 사번으로 검색할지 이름으로 검색할지 정할 수 있다.
동적으로 쿼리가 작성된다.  

동적쿼리 작성시 주의할점은 홀따옴표 안에 **공백이 무조건 앞 또는 뒤에 하나씩 있어야한다**. 붙여 쓰면 실행될 sql문 에러가 발생한다(`SELECT*FROMemp`이런식으로 작성됨).

그냥 앞뒤로 공백 하나씩 주는게 맘 편하다.

`execute immediate`로 정의한 동적쿼리를 실행한다. 실행되서 나온 결과값은 `INTO`예약어로 변수에 집어넣을 수 있음.  

DBMS출력
```
vcondition이 1일때
20, SMITH, CLERK 

vcondition이 2일때
30, ALLEN, SALESMAN
```

---

위처럼 사번, 이름을 고정시켜 사용할 수는 없음으로 아래처럼 입력받는다는 가정하에 동적쿼리를 작성.  

```sql
DECLARE
    vsql VARCHAR2(1000); 
    --동적으로 작성될 쿼리가
    vcondition NUMBER(1) := 2;
    --경우를 판별할 숫자 경우에 따라서 이름이, 사번이 붙을 수 있다.
    vdeptno emp.deptno%type;
    vename emp.ename%type;
    vjob emp.job%type;
    psearchWord varchar2(20) := :sword;
BEGIN
    vsql := 'SELECT deptno, ename, job ';
    vsql := vsql || 'FROM emp ';
    IF vcondition = 1 THEN
        vsql := vsql || 'WHERE empno = '||psearchWord ;
    
    ELSIF vcondition = 2 THEN
        vsql := vsql || 'WHERE ename = '''||psearchWord||'''' ;
    END IF;
    dbms_output.put_line(vsql);
    execute immediate vsql 
    INTO vdeptno, vename, vjob;
    dbms_output.put_line(vdeptno||', '|| vename||', '|| vjob);
END;
```
sword 바인드 변수에 입력된 값에 따라 정의되는 동적쿼리도 달라진다.  
숫자인 empno같은 경우 검색조건에 홀따옴표가 필요 없지만 문자형인 ename같은 경우 검색조건에 홀따옴표가 필요하다.  

DBMS출력
```
SELECT deptno, ename, job FROM emp WHERE ename = 'SMITH'
20, SMITH, CLERK
```
생성된 동적쿼리를 출력하면 위와같다.  
솔직히 홀따옴표 사용하는거 너무 헷갈리고 힘들다....

USING문을 사용하면 홀따옴표 사용이 좀 수월해진다!

```sql
DECLARE
    vsql VARCHAR2(1000); 
    --동적으로 작성될 쿼리가
    vcondition NUMBER(1) := 2;
    --경우를 판별할 숫자 경우에 따라서 이름이, 사번이 붙을 수 있다.
    vdeptno emp.deptno%type;
    vename emp.ename%type;
    vjob emp.job%type;
    psearchWord varchar2(20) := :sword;
BEGIN
    vsql := 'SELECT deptno, ename, job ';
    vsql := vsql || 'FROM emp ';
    IF vcondition = 1 THEN
        vsql := vsql || 'WHERE empno = :a';
    
    ELSIF vcondition = 2 THEN
        vsql := vsql || 'WHERE ename = :a' ;
    END IF;
    dbms_output.put_line(vsql);
    execute immediate vsql 
    INTO vdeptno, vename, vjob
    USING psearchWord;
    dbms_output.put_line(vdeptno||', '|| vename||', '|| vjob);
END;
```

DBMS출력
```
SELECT deptno, ename, job FROM emp WHERE ename = :a
20, SMITH, CLERK
```
:a는 `execute immediate` 실행시 결정된다. 문자형, 숫자형 상관없이 USING문 쓰면 실수할 확률이 줄어든다!  

---

동적쿼리는 다음과 같이 SELECT문 뿐만 아니라 각종 DML문에도 적용될 수 있다.  

```sql
CREATE OR REPLACE PROCEDURE up_insert_dept(
    pdname dept.dname%type,
    ploc dept.loc%type
)
IS 
    vsql VARCHAR(1000);
    vdeptno dept.deptno%type;
BEGIN
    SELECT NVL(MAX(deptno), 0) + 10
        INTO vdeptno --시퀀스 역할
    FROM dept;
    vsql := 'INSERT INTO dept (deptno, dname, loc) ';
    vsql := ' VALUES (:deptno, :dname, :loc) ';
    execute immediate vsql
        using vdeptno, pdname, ploc;
END;

exec up_insert_dept('작업팀', '서울');
```

동적쿼리를 사용하면 지정하지 않아도 알아서 INSERT도 편하게 할 수 있다.

----

여러개의 Record가 반환될때도 동적쿼리를 사용해도 된다.  
`INTO`가 아닌 `CURSOR`에 결과물을 담아야 하는데 방법은 2가지다.  

1. ref cursor  
2. sys_refcursor  

sys_refcursor가 오라클 9i에 들어오면서 생긴 방법이고 ref cursor는 예전에 쓰던 방법이다.  

정의부분에서 약간 차이가 있고 사용법은 다르지 않다.  

- ref cursor 사용 cursor 생성  
```sql
DECLARE
   type query_pysicit is ref cursor;
   vcursor query_pysicit;
   ...
```

- sys_refcursor 사용 cursor 생성  
```sql
DECLARE
    vcursor sys_refcursor;
    ...
```


```sql
DECLARE
    vcursor sys_refcursor;
    vsql VARCHAR2(1000);
    vrow emp%rowtype;
    pdeptno dept.deptno%type := 10;
BEGIN
    vsql := ' SELECT * ';
    vsql := vsql|| ' FROM emp ';
    vsql := vsql|| ' WHERE deptno = :pdeptno';
    OPEN vcursor FOR vsql    --execute 대신 for가 들어갔따
    USING pdeptno;
    
    LOOP
        FETCH vcursor INTO vrow;
        EXIT WHEN vcursor%notfound;
        dbms_output.put_line(vrow.empno || ', '||vrow.ename);
    END LOOP;
    CLOSE vcursor;
END;
```

`OPEN vcursor FOR vsql` 를 통해 동정쿼리를 실행하고 결과를 커서가 가리킬 수 있다.  