---
title:  "DB 트랜잭션!"
# classes: wide
header:
read_time: false
share: false
author_profile: false

categories:
  - DataBase

toc: true
toc_sticky: true

---

## 트랜잭션

트랜잭션은 **작업의 완전성**을 보장한다.  

DB ACID 즉 논리적인 작업 셋을 모두 완벽하게 처리하거나, 작업의 일부만 적용되는 현상(Partial update)이 발생하지 않는것을 보장하는 기능이다.  

트랜잭션을 상당히 골치아픈 기능으로 생각하지만, 그만큼 애플리케이션 개발에서 고민해야 할 문제를 줄여주는 필수적 DBMS 기능이다.  

### ACID

> 출처: 위키

ACID(원자성, 일관성, 고립성, 지속성)는 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질을 가리키는 약어이다.

**원자성(Atomicity)**  
트랜잭션 내 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장하는 능력이다.  
트랜잭션의 중간단계까지 실행되고 실패하는 일이 없도록 하는 것이다.  

**일관성(Consistency)**  
트랜잭션이 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미한다. DB 내에 무결성 제약이 모든 계좌는 잔고가 있어야 한다면 이를 위반하는 트랜잭션은 중단된다.

**독립성(Isolation)**  
`트랜잭션A` 수행 시 다른 `트랜잭션B` 가 끼어들지 못하도록 보장하는 것을 의미한다.  
이것은 트랜잭션 밖에 있는 어떤 연산도 중간 단계의 데이터를 볼 수 없음을 의미한다.  

**지속성(Durability)**  
트랜잭션이 성공적으로 완료하면 영원히 반영되어야 함을 의미한다.  
전형적으로 모든 트랜잭션은 로그로 남고 시스템 장애 발생 전 상태로 되돌릴 수 있다. 트랜잭션은 로그에 모든 것이 저장된 후에만 commit 상태로 간주될 수 있다.

### 스케줄 serializable

> 자세한 설명: <https://www.youtube.com/watch?v=DwRN24nWbEc>

`serializable` 두개의 트랜잭션이 동일한 시간대에 실행될 경우  
`read/write` 요청이 섞이더라도 모두 동일한 결과값을 요하는 성질이다.  

DB 가 트랜잭션을 받게되면 아래 2가지 방식으로 수행될 수 있다.  

- Serial Shcedule  
- Nonserial Schedule  

![image1](/assets/DB/db-transaction1.png)

모든 트랜잭션이 `serial shcedule` 으로 처리된다면 아래에서 알아볼 `[락, 격리]` 등은 알필요가 없다.  

하지만 대부분 DBMS 에선 성능때문에 트랜잭션을 `nonserial schedule` 으로 처리하고,  
ACID 요구사항을 만족시기 때문에 각종 제약조건을 통해 처리한다.  

제약조건의 목표는 `nonserial schedule` 의 두 트랜잭션이 `conflict serializable`(충돌직렬화) 조건을 만족하는 것이다.  

`conflict serializable` 은 `nonserial schedule` 의 두개 트랜잭션이 하나의 자원을 `read/write` 하는 순서가  
`serial shcedule` 에서 하나의 자원을 `read/write` 하는 순서가 동일함을 뜻한다.  

`read/write` 하는 순서가 동일할 경우 `serial schedule` `nonserial schedule` 상관없이 모두 동일한 결과가 출력된다.  

### 스케줄 recoverability

`recoverability` 는 스케줄이 `rollback` 되었을 때 복원성을 의미한다.  
여러개의 트랜잭션이 동시에 실행되다 특정 트랜잭션이 rollback 될 경우 정상적으로 복원되지 않을 경우가 있다.  

특이한 조건에서 `recoverability` 가 손상되는 상황을 알아보고  
아래 3가지 종류의 스케줄을 사용해 방지하는 방법을 알아본다.  

- recoverability schedule  
- cascadeless schedule  
- strict schedule  

#### recoverability schedule

트랜잭션의 의존관계를 파악하고, 부모 트랜잭션이 `commit/rollback` 되는것을 확인한 후 자식 트랜잭션도 `commit/rollback` 하는 스케줄을 `recoverability schedule`(보존 스케줄) 이라 한다.  

아래 그림처럼 스케줄 내에서 `commit` 된 트래잭션(T2)이 `rollback` 된 트랜잭션(T2)이 write 했던 데이터를 읽은 경우를 `unrecoverability schedule` 이라 한다.  

![image1](/assets/DB/db-transaction2.png)  

T2 가 읽은 R(A) 값은 T1 이 롤백하게되면서 부정확한 값이 되어버렸다.  

`recoverability schedule` 로 변경하려면 트랜잭션의 의존관계를 파악하고 부모 트랜잭션과 자식 트랜잭션을 연결해서 `commit/rollback` 해야한다. `cacading rollback` 이라 하는데 비용이 높아 사용하지 않는 기술이다.  

그래서 `cacading rollback` 기술을 사용하지 않으면서도 `recoverability` 를 확보하기 위해 `cascadeless schedule` 를 사용한다.  

#### cascadeless schedule  

데이터를 `write` 한 트랜잭션이 `commit/rollback` 되기 전까지는 `read` 를 제한하는 스케줄을 `cascadeless schedule`(비종속 스케줄) 이라 한다.

![image1](/assets/DB/db-transaction3.png)  

그림처럼 동일한 자원 X 를 건들이는 트랜잭션 3개가 있을 경우 `commit`(초록박스) 되기까지는 `read/write` 접근을 모두 막는다.  
트랜잭션의 종속관계를 원천차단함으로 `cacading rollback` 을 사용할 필요가 없다.  

`cascadeless schedule` 는 `read` 에 대해서만 접근제한하고 `wirte` 는 별도로 제한하지 않기 때문에,  
`write` 트랜잭션이 연속적으로 일어나는 환경에서 `rollback` 으로 인해 일부 `write` 트랜잭션들이 무시될 수 있다.  

#### strict schedule  

데이터를 `write` 한 트랜잭션이 `commit/rollback` 되기 전까지는 `read/write` 모두 제한하는 스케줄을 `strict schedule`(엄격한 스케줄) 이라 한다.

아래 그림과 같이 스케줄 다이어그램으로 구분할 수 있으며  
`strict schedule` 이 공유자원에 대해 가장 엄격하게 관리한다.  

![image1](/assets/DB/db-transaction4.png)  

앞으로 설명할 `[락, 격리레벨]` 등은 모두 트랜잭션의 `[serializable, recoverability]` 속성을 만족시키기 위해서다.  

## 락(Lock)  

락은 동시성을 제어하기 위한 기능  
트랜잭션은 데이터의 정합성을 보장하기 위한 기능.  

락은 개념적으로는 아래와 같이 두종류로 나눌 수 있다.  

- **Read Lock**  
  `Shared Lock(공유 락)` 이라고도 하며 다른 트랜잭션이 **read 하는것을 허용하고 write 하는것을 비허용**한다.  
- **Write Lock**  
  `Exclusive Lock(배타적 락)` 이라고도 하며 다른 트랜잭션이 **read/write 하는것을 모두 비허용**한다.  

락의 호환성은 아래와 같다.  

|            | Read Lock | Write Lock |
| ---------- | --------- | ---------- |
| Read Lock  | O         | X          |
| Write Lock | X         | X          |

### MySQL InnoDB Lock

MySQL 에서 기본적으로 제공하는 잠금은 아래와 같다.  

- **Global Lock**  
  MySQL 서버 전체 잠금을 설정, 백업시에 주로 사용.  
- **Table Lock**  
  개별 테이블 단위로 잠금을 설정  
- **Named Lock**  
  `GET_LOCK()` 함수를 통해 임의 문자열에 대해 잠금을 설정.  

`MySQL InnoDB` 에서 별도로 레코드 기반 잠금기능을 제공한다.  

- **Record Lock**  
  인덱스의 레코드를 잠근다. 기본키, 유니크 인덱스 관력 작업은 Record Lock 을 사용한다.  
- **Gap Lock**  
  레코드와 인접한 위 아래 간격을 잠근다. 레코드 사이 새로운 INSERT 를 제어한다.  
- **Next-Key Lock**  
  `Record Lock + Gap Lock` 형태의 잠금. 

![image1](/assets/DB/db-transaction10.png)  

MySQL InnoDB 에서 인덱스 기반으로 SELECT 요청을 할 경우 해당 인덱스의 레코드에 `Next-Key Lock` 이 발생한다.  

해당 인덱스를 수정/삭제 하거나, Gap 안에 새로운 레코드를 추가할 수 없다.  

만약 인덱스가 아닌 필드를 기반으로 SELECT 요청을 할 경우 테이블 전체에 락을 걸게 됨으로 철저한 인덱스 설계가 필요하다.  

### 2PL

2PL(two-phase locking) 은 트랜잭션에서 **모든 locking 명령이 최초의 unlock 명령보다 먼저 수행되도록 하는 방법**이다.  
락을 통해 트랜잭션의 `read/write` 순서를 강제하면서 자연스럽게 `serializable` 를 만족하게 된다.  
하지만 모든 트랜잭션이 자원을 공유하지 않기 위해 락을 흭득하게되면 데드락 상태가 발생하게 된다.  

#### Conservative 2PL

모든 Lock 을 취득한 다음 트랜잭션을 수행한다.  
모든 자원을 가져야 트랜잭션이 수행됨으로 데드락이 발생하지 않는다.  
하지만 모든 Lock 을 취득하기 위한 시간이 오래 걸림으로 성능이 떨어져 잘 사용하지 않는 방법이다.  

```sql
read_lock(X)
write_lock(Y)
write_lock(Z)
...
unlock(X)
...
unlock(Y)
unlock(Z)
commit
```

#### Strict 2PL

`strict schedule` 을 보장하는 2PL, `Write Lock` 은 `commit/rollback` 이후에 해제한다.  

```sql
read_lock(X)
write_lock(Y)
write_lock(Z)
...
unlock(X)
...
commit
unlock(Y)
unlock(Z)
```

#### Strong Strict 2PL(SS2PL)

`strict schedule` 을 보장하는 2PL, `Write Lock`, `Read Lock` 모두 `commit/rollback` 이후에 해제한다.  

```sql
read_lock(X)
write_lock(Y)
write_lock(Z)
...
...
commit
unlock(X)
unlock(Y)
unlock(Z)
```

## 트랜잭션 격리

**트랜잭션 격리** 는 트랜잭션 처리 과정에서 두개 이상의 트랜젝션이 **동시에 같은 공유 자원 접근시(Race Condition)** 발생하는 문제를 처리하기 위한 제약조건이다.  

위에서 설명한 트랜잭션의 `[serializable, recoverability]` 속성을 만족시키기 위한 제약조건이기도 하다.  

여러개의 트랜잭션이 하나의 자원에 접근할 때 별도의 제약조건 없이 `read/write` 할 수 있도록 풀어줄경우 아래와 같은 이상한 상황이 발생할 수 있다.  

- Dirty Read  
- Nonrepeatable Read  
- Phantom Read  

### Dirty Read  

![image1](/assets/DB/db-transaction5.png)  

`READ_UNCOMMITED` 가능할 경우 `commit` 되기전 정보를 `read` 할 수 있다.  
이 과정에서 오류가 발생되어 읽어온 정보가 `rollback` 된다면 `read` 된 정보는 잘못된 정보가 되어버린다.  

이렇게 잘못된 정보를 읽는 것을 `Dirty read` 라 한다.  

`READ_COMMITTED` 으록 설정하면 `Dirty Read` 가 발생하지 않는다.  

### Nonrepeatable Read

![image1](/assets/DB/db-transaction6.png)  

한 트랜잭션에서 별도의 쓰기작업 없이 처음 읽어드린 값과 두번째 읽어드린 값이 다른 상황을 `Nonrepeatable Read` 이라한다.  

### Phantom Read

![image1](/assets/DB/db-transaction7.png)  

여러개의 레코드를 `read` 하는 경우에서 발생하는 이슈로 처음 읽었을 때 와의 레코드개수와 두번째 읽었을 때 레코드 개수가 다른 경우를 `Phantom Read` 라 한다.  

### 격리레벨(isolation level)  

위와 같은 문제를 해결하기 위해 하나의 트랜잭션을 격리하기 위한 제약조건을 level 로 표현했다.  

| **격리레벨**        | **DR** | **NR** | **PR** |
| ------------------- | ------ | ------ | ------ |
| **READ_UNCOMMITED** | O      | O      | O      |
| **READ_COMMITTED**  | X      | O      | O      |
| **REPEATABLE_READ** | X      | X      | O      |
| **SERIALIZABLE**    | X      | X      | X      |

- **READ_UNCOMMITED**  
  다른 트랜잭션에서 커밋하지 않은 데이터 `read` 가능.  
- **READ_COMMITTED**  
  다른 트랜잭션에 의해 커밋된 데이터만 `read` 가능.  
- **REPEATABLE_READ**  
  DBMC 별로 구현방법이 다름, 스냅샷과 같은 방식으로 트랜잭션들을 격리함.  
- **SERIALIZABLE**
  선점한 트랜잭션이 수행줄일 때 `write` 할 수 없다.  

높은 레벨일수록 고립도가 높아지며 성능이 떨어진다.  
어플리케이션 형태에 따라 격리레벨을 설정하여 최적화 해야한다.  

> `PostgreSQL` 을 포함한 대부분 DBMS 는 기본적으로 `READ_COMMITTED` 을 사용한다.  
> `MySQL` 은 기본적으로 `REPEATABLE_READ` 을 사용한다.  
> `MySQL InnoDB` 에선 `SELECT` 시 `Next-Key Lock` 으로 인해 `REPEATABLE_READ` 격리레벨에서도 `Phantom Read` 가 발생하지 않는다.  

### SNAPSHOT 격리레벨  

위 4가지 격리레벨 외에 일부 DBMS 에서 `SNAPSHOT` 격리레벨을 제공한다.  

트랜잭션의 수행을 형상으로 관리하고 `commit` 시점에 관리하던 형상을 한번에 뭉쳐 `write` 명령을 DB 에 전달한다.  

만약 트랜잭션의 `start-commit` 사이에 다른 트랜잭션이 먼저 `commit` 했다면 후에 `commit` 되는 트랜잭션은 abort 된다.  

그래서 `first-commiter win` 이라는 이름으로 불리기도 한다.  

> `PostgreSQL` 의 `REPEATABLE_READ` 가 `snapshot isolation` 처럼 동작한다.  

### 추가이상현상

위에서는 3가지 이상현상인 `[Dirty Read, Nonrepeatable Read, Phantom Read]` 만 소개했는데  
사실 3가지 이외에도 격리레벨마다 추가이상현상이 존재한다.  

> 사실상 위 3가지 이상현상에 의해 파생되는 추가이상현이다.  

**READ_UNCOMMITED 추가이상현상 - Diirt Write**  
`commit` 되지 않는 데이터를 `write` 할 때 발생한다.  
연달아서 write 만 하는 트랜잭션이 트랜잭션 스케줄이 있을 경우, 첫번째 트랜잰셕이 rollback 되면서 두번째 트랜잭션의 반영사항이 무시될 수 있다.  

**READ_COMMITTED 추가이상현상 - Lost Update**  
`Shared Lock` 이 없을 때 두번째 `commit` 이 첫번째 `commit` 을 덮어 씌우는 경우이다.  
`Dirty Read` 한 후 해당 데이터로 `write` 하고 `commit` 하는 것이다.  

> 이 외에도 **read skew, write skew** 가 존재하는데, 어플리케이션 레벨에서 값에 대한 제약조건을 `if` 로 구성해 놔도 `Dirty Read` 통과되어 버리는 오류이다.  

### MVCC

> 출처: Real MySQL

락 기반의 `Concurrency Control` 의 경우 `Read Lock` 만 공유되기에 성능에서 떨어진다.  

특히 `[READ_COMMITTED, REPEATABLE_READ]` 를 락 기반으로 구현할 경우 다량의 `Read Lock` 이 발생하고 심한 고립성을 가지게 된다.  
그래서 대부분 DBMS 가 락 기반 `Concurrency Control` 을 하지 않고 `MVCC(Multiversion Concurrency Control)` 기법을 사용한다.  

DBMS 별로 다양한 `MVCC` 구현방법이 있는데, `MySQL InnoDB` 의 `MVCC` 는 특정 시점의 변경정보를 `version` 으로 기록하기 위해 `Undo Log` 를 사용한다.  

아래 그림과 같이 실제 디스크에 바로 `write` 되지 않고 `Buffer Pool` 에 일정시간 저장되어 있다가 백그라운드 스레드에 의해 디스크에 기록된다.  

![image1](/assets/DB/db-transaction8.png)  

`READ_UNCOMMITTED` 의 경우 `Buffer Pool` 에서 데이터를 읽어서 반환하고  
`READ_COMMITTED` 혹은 그 이상의 격리레벨의 경우 `Undo Log` 에서 데이터를 읽어 반환한다.  

`Undo Log` 에서 락에 의한 제한 없이 값을 읽을 수 있고 **Non-Locking Consistent Read(잠금 없는 일관된 읽기)** 라 부른다.  

이 일련의 과정을 `MySQL` 에서 `MVCC` 라 표현한다.  

![image1](/assets/DB/db-transaction9.png)  

그림처럼 4번 index row 는 `Buffer Pool` 과 `Undo Log` 2가지 `version` 으로 관리된다.  

#### MVCC 문제점

`Undo Log` 를 사용해서 `Non-Locking Consistent Read` 하는 것은 좋지만, `read` 에 대해 제약조건 없이 접근을 허용할 경우 `Dirty Read` 가 발생할 수 밖에 없다.  

> 위 그림만 봐도 실제 값은 `경기` 인데 읽어드린 값은 `서울` 이다.  

여기서의 `Dirty Read` 는 위에서 설명한 `rollback` 으로 인한 `Dirty Read` 와는 결이 다르다.  
순서 차이일 뿐 정상적인 `read` 로 `Undo Log` 로부터 값을 읽어왔기 때문에 `Dirty Read` 가 아니라고 볼수 있지만, 대다수의 아티클에서 업데이트 되기 직전의 옜날 값을 읽어왔음으로 해당 상황도 `Dirty Read` 에 포함시켜야 한다고 주장하고 있다.  

만약 해당 방식으로 `Dirty Read` 한 값을 기반으로 `write` 를 수행하면ㅋ `Lost Update` 까지 이어진다.  

`MySQL MVCC` 에서 기본 격리레벨인 `REPEATABLE_READ` 는 별도의 락 없이 동작하기 때문에 `Dirty Read - Lost Update` 가 충분히 발생할 수 있다.  

따라서 `read/write` 가 복잡하게 얽힌 비즈니스 로직과 높은 동시성 제어가 필요한 트랜잭션이라면 `read` 요청에도 베타적 설정을 지정해줘야 한다.  

```sql
-- Locking Read
SELECT balance FROM account WHERE id = '1' FOR UPDATE; -- WRITE LOCK
SELECT balance FROM account WHERE id = '1' FOR SHARE; -- READ LOCK
```

**이런 형태의 락을 `Locking Read` 라 하고 `read` 요청이지만 `Write Lock` 을 요구한다.**  
그리고 `Locking Read` 는 값을 읽어올 때 가장 최근 `commit` 된 정보를 읽어온다.  

동시에 실행되는 두 트랜잭션의 `read` 요청을 `Locking Read` 로 수행할 경우 `Dirty Read` 가 발생하지 않는다.  
사실상 락 기반 베타적으로 실행되는 `Concurrency Control` 이랑 다름없다.  

하지만 대부분의 트랜잭션이 읽기 작업만 수행함으로 `MVCC` 방식을 사용하는 것이 효과적이다.   

#### PostgreSQL MVCC 문제점    

`PostgreSQL` 의 `MVCC` 에서도 별도의 `Read Lock` 을 사용하지 않기 때문에 기본 격리레벨인 `READ_COMMITTED` 을 사용할 경우 `Dirty Read-Lost Update` 가 발생한다.  

따라서 `Concurrency Control` 가 필요한 데이터를 접근할 때에는 격리레벨을 `REPEATABLE_READ` 로 설정해야 한다.  

`PostgreSQL` 의 `MVCC` 에서 `REPEATABLE_READ` 을 사용하면 트랜잭션 시작과 `write` 요청 사이에 해당 데이터에 `commit` 된 기록이 있다면 해당 트랜잭션을 abort 시킨다.  

마치 `first-commit` 만 성공시키는 `SNAPSHOT` 격리레벨처럼 동작한다.  

참고로 `PostgreSQL` 의 경우 격리레벨을 `READ_COMMITTED` 설정하고 `[FOR UPDATE, FOR SHARE]` 구문을 사용해도 된다.  
`REPEATABLE_READ` 와 동일하게 `write` 요청 사이에 `commit` 된 기록이 `abort` 한다.  

