---
title:  "DB 1일차!"

header:
  overlay_image: /assets/DB/dbimage.jpg
  caption: "Photo credit: [**oracle**](https://www.oracle.com)"

read_time: false
share: false
author_profile: false
# classes: wide

categories:
  - DataBase
---

## DB 개요

자료(data) 와 저장소(base)를 합친 말.  
방대한 정보를 효과적으로 추출, 분류, 저장, 새로운 정보로 재사용 할 수 있는 자료집합  

**SQL (Structed Query Language: 구조화된 질의 언어)**  
클라이언트가 DB에게 데이터를 요청, 수정, 삭제, 조작할 때 사용하는 질의 언어.  
각 DB별로 질의 언어를 표준화 시켰는데 표준화된 SQL을 ANSI SQL이라한다.  

> 물론 DB별로 따로 사용하는 질의도 있음. (설정 질의 같은 거)  

### SQL 유형

1. **DQL(Data Query Language: 데이터 질의 언어)**  
   - SELECT  
2. **DML(Data Manipulation Language: 데이터 조작어)**  
   - INSERT  
   - UPDATE  
   - DELETE  
3. **DDL(Data Definition Language: 데이터 정의어)**  
   - CREATE  
   - ALTER  
   - DROP  
   - RENAME  
   - TRUNCATE  
4. **DCL (Data Control Language: 데이터 정의어)**  
   - GRANT  
   - REVOKE
5. **TCL (Transaction Control Language: 트랜잭션 처리어)**  
   - COMMIT  
   - ROLLBACK  
   - SAVEPOINT  

## SELECT 명령어

아래에 정의된 로부터 **데이터를 가져오는데 사용된다.**

- 테이블(table)  
- 객체 테이블(object table)  
- 뷰(view)  
- 객체 뷰(object view)  
- materialized view  

SELECT 질의문은 다음 7 개의 구문으로 구성되어 있다.  
질의문 작성시 위에서 아래 순서대로 구문을 구성해야한다.  
괄호 안에 있는 것들은 생략 가능하다.  

- **[ WITH ] - 1**  
- **SELECT - 6**  
- **FROM - 2**  
- **[ WHERE ] - 3**  
- **[ GROUP BY ] - 4**  
- **[ HAVING ] - 5**  
- **[ ORDER BY ] - 7**  

우측의 숫자는 실제 DB 가 구문을 실행시키는 순서이다.  
쿼리 최적화시 첫번 째 구문을 최적화 해야 이하 구문들도 최적화가 진행된다.  


```sql
SELECT empno, ename, sal, nvl(comm, 0) nvl_comm
FROM emp
WHERE nvl_comm != 0;**
```

오류가 나는 이유....
WHERE 실행순서가 SELECT보다 빠르기 때문  


## 트랜잭션

트랜잭션은 **논리적인 하나의 작업단위** 이다.

계좌시스템을 예로 들면 A가 B에게 입금하는 작업을 하나의 작업단위로 볼 수 있다.  
```
A가 B에게 돈을 입금하고 A의 보유금을 마이너스
B는 A에게 입금받은 돈은 보유금에서 플러스
```
위의 2작업이 한번에 이루어지는 `작업 단위`여야 한다.  
각각의 작업단위로 보게되면 A는 출금됬는데 B에게 입금되는 작업은 실패해서 A돈만 마이너스 되는 불상사가 발생....


이 과정이 성공하면 `COMMIT`하고 중간에 **어떠한 과정이라도 실패한게 있다면** `ROLLBACK`해야 한다.

> 트리거는 자동으로 트랜잭션으로 묶여 있기 때문에(하나의 작업단위로) 실패하면 바로 rollback 되어버린다.  


즉 `트랜잭션(Transaction)`이란 일의 처리가 완료되지 않은 중간 과정을 취소하여 일의 시작 전 단계로 되돌리는 기능이다.   
결과가 도출되기까지의 중간 단계에서 문제가 발생하였을 경우 모든 중간 과정을 무효화하여 작업의 처음 시작 전 단계로 되돌리는 것이라 할 수 있다.  

DML문을 실행하면 해당 트랜젝션에 의해 발생한 데이터가 **다른 사용자에 의해 변경이 발생하지 않도록** `LOCK(잠김현상)`을 발생한다.  

이 `lock`은 `commit` 또는 `rollback`문이 실행되면 해제된다.  

SYS계정에서 MILLER의 job을 검색한다.
```sql
SELECT ename, job
FROM scott.emp
WHERE ename = 'MILLER';
```
SYS계정에선 MILLER의 job이 CLERK라 출력된다.

그럼 SCOTT계정에서 MILLER의 job을 ARTIST로 바꾸고 각각의 계정에서 다시 SELECT해보자.  

SCOTT의 계정에서 실행
```sql
UPDATE emp
SET job = 'ARTIST'
WHERE ename = 'MILLER';

SELECT ename, job
FROM emp
WHERE ename = 'MILLER'; 
```

SYS의 계정에서 실행
```sql
SELECT ename, job
FROM scott.emp
WHERE ename = 'MILLER';
```
SYS가 빨간색이고 SCOTT이 파란색이다.  

![image3](/assets/DB/days18/image3.png){: .shadow}  

SCOTT세션에서만 변경되었기 때문에 SYS의 입장에서 MILLER의 job은 아직 CLERK이다.

 
그럼 이번에 SYS계정에서 MILLER의 job을 XXXX로 업데이트 해보자  
```sql
UPDATE scott.emp
SET job = 'XXXXX'
WHERE ename = 'MILLER';
```
![image4](/assets/DB/days18/image4.png){: .shadow}  


`LOCK`되어서 다음 상황으로 넘어가지 않는다...

아직 SCOTT이 UPDATE하고 COMMIT하지 않았기 때문.

SCOTT이 커밋하는 순간 SYS의 UPDATE도 LOCK이 풀리면서 실행된다.

![image5](/assets/DB/days18/image5.png){: .shadow}  

이젠 SYS에서 emp테이블에 LOCK을 걸었고 SCOTT은 SYS가 COMMIT해줄동안 emp테이블에 접속하지 못한다.

 
### 트랜젝션의 시작과 종료

**트랜젝션 시작**  
- 데이터베이스를 처음 접속했을 때
- 하나 또는 여러 개의 DML문이 실행된 후 commit 또는 rollback문이 실행된 직후 

**트랜젝션 종료**  
- commit 또는 rollback문이 실행 될 때
- DDL문 또는 DCL 문이 실행 될 때
- 정상적으로 데이터베이스를 종료할 때
- 비정상적으로 데이터베이스를 종료할 때


## 인덱스 개요

목차란 뜻으로 빠른 탐색을 위해 사용한다.  

400페이지가 넘는 책을 한장씩 펼처 원하는 페이지를 찾기보단 목차를 통해 찾느게 빠르듯,  
DB에서 어떤식으로 목차를 만들고 탐색을 하는지 알아보자.  

오라클 인덱스 내부구조는 `B * 트리(B star tree)` 형식으로 구성되어 있다.(버전에 따라 다를 수 있음)  

> 전산학에서 B-트리(B-tree)는 데이터베이스와 파일 시스템에서 널리 사용되는 트리 자료구조의 일종으로, 이진 트리를 확장해 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조이다.(위키)

**하나의 노드안에 여러개의 값이 들어있다.**  

방대한 양의 저장된 자료를 검색해야 하는 경우 일일이 노드안의 하나의 데이터를 일일히 비교하기 보단 뭉텅이로 관리하는게 효율적이다.(오버헤드 측면, 균형 재분배, 데이터 지역성에 의한 속도증가)  

![index1](/assets/DB/index1.png){: .shadow}  

`B Tree`의 종류에는 일반적인 `B Tree,` `B+ Tree`, `B* Tree`가 있는데 뒤의 2개가 인덱스에 주로 사용된다고 한다.  

### 인덱스 장단점

위의 설명대로 인덱스의 장점은 검색시 시스템 부하를 획기적으로 줄일 수 있다.  
트리 구조의 저장을 통해 `O(log n)`의 시간을 요구한다.  

단점은 인덱스(B * Tree)를 위한 저장공간, 별도의 연산과정이 필요하다.  
특히 추가/삭제 과정에서 균형이 무너질 수 있고 균형 재분배를 통해 다시 균형을 맞추는대 매우 큰 비용이 발생한다.  

따라서 추가/삭제가 빈번히 일어나는 경우 오히려 성능 저하 가능성이 있다.  

WHERE조건문에 자주 사용되는 칼럼,
JOIN이 많이 사용되고 NULL을 다수 포함하는 컬럼을 인덱스로 설정하면 좋다.  

물론 테이블 행 수가 적거나, 
INSERT/DELETE가 자주 일어나고,  
WHERE 조건으로 검색결과가 전체 데이터의 10~15% 이상이라면 인덱스를 설정하지 않는게 더 효율적일 수 있다.  

### 인덱스 생성/삭제

오라클의 경우 기본키, 유일키로 제약조건을 설정하면 자동으로 인엑스가 생성된다.  
그 외에 다른 칼럼을 인덱스로 생성하고 싶다면 `CREATE INDEX`를 통해 생성가능하다.  

```sql
CREATE INDEX index_board
ON tbl_board (b_inx);
```

삭제는 당연히 `DROP INDEX index_name` 로 가능하다.  

> 인덱스 생성중 비고유 인덱스 생성 쿼리이다.  

### 인덱스의 종류

1. 고유 인덱스(Unique Index)  
2. 비고유 인덱스(NonUnique Index)  
3. 단일 인덱스(Single Index)  
4. 결합 인덱스(Composite Index)  
5. 함수기반 인덱스(Function Index)


#### 고유/비고유 인덱스

이름 답게 고유 인덱스는 기본키, 유일키에 대한 칼럼에 대한 인덱스,  
비고유 인덱스는 중복값이 있는 칼럼에 대한 인덱스이다.  

**고유 인덱스 생성**  
```sql
CREATE UNIQUE INDEX index_board
ON tbl_board (b_idx)
```

**비고유 인덱스 생성**  
```sql
CREATE INDEX index_board
ON tbl_board (b_idx)
```

#### 단일/결합 인덱스

마찬가지로 이름답게 하나의 칼럼으로 구성된 인덱스는 단일 인덱스,  
복수개의 칼럼으로 구성된 인덱스를 결합 인덱스라 한다.  


**결합 인덱스 생성**  
```sql
CREATE UNIQUE INDEX index_board
ON tbl_board (b_idx, b_title)
```

칼럼명을 복수개 지정하면 된다.  

#### 함수기반 인덱스

칼럼의 일반적인 값이 아니라 특정 연산이후의 값을 인덱스로 만들고 싶을 때 함수기반 인덱스를 사용한다.  

SAL 칼럼이 인덱스가 있다 하더라도 조건문으로 `WHERE SAL * 12 = 3600` 을 사용해 검새쿼리를 수행할 때 인덱스를 사용하지 못한다.  

특정 연산을 수행한 인덱스를 함수기반 인덱스라 한다.  

**함수기반 인덱스 생성**  
```sql
CREATE UNIQUE INDEX index_sal_year
ON tbl_emp (sal*12)
```