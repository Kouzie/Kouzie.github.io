---
title:  "객체지향 - 기본개념!"

read_time: false
share: false
author_profile: false
classes: wide

categories:
  - 객체지향

tags:
  - 오브젝트


toc: true

---

## 상속(inheritance)

객체지향에서 상속은 매우 자주 나오는 용어로 코드 재사용을 위해 흔히 사용되는 개념이다.  

상속이란 언어 때문에 아래처럼 상속관계를 오해하기 쉽다.  

![object1]({{ "/assets/2019/object1.jpg" | absolute_url }})  

위 사진은 has-a 관계같이 상속관계와는 잘 어울리지 않는 모델이다.  

우리가 java에서 상속이라 표현하는 모델은 아래 사진과 더 유사하다.  

![object2]({{ "/assets/2019/object2.jpg" | absolute_url }})  

즉 상속은 **확장, 포함, 분류**의 개념이라 할 수 있다.  

java에서 `inheritance`키워드 대신 `extends`키워드를 사용하는 것이 이때문이다.  

> 흔히 상속을 `is-a` 관계라 표현하는데 좀더 명확한 표현은 `is a kind of`관계라 할 수 있다.  - Three Amigos

## 인터페이스  

다중상속이 안되는 java에서 좀더 효율적으로 코드 재사용을 하기 위해 나온것이 인터페이스  

인터페이스와 이를 구현하는 클래스와의 관계는 `is-a`관게도 `is a kind of`아닌 `is able to`관계이다.  

**즉 무엇을 할 수 있는 지**에 대한 명세가 인터페이스라 할 수 있다.  

> `Serializable`, `Cloneable`, `Comparable`, `Runnable` 등 java 기존의 여러 인터페이스 뒤에 able이란 스펠이 붙는 이유도 위와 같다.  

> 캡슐화, 추상화, 다형성에 대한 내용은 생략



## 결합도와 응집도

좋은 소프트웨어는 **낮은 결합도, 높은 응집도**를 요구한다.  

결합도는 객체간 의존정도를 나타내고 결합도를 낮추면 의존성도 줄어들고 객체의 재사용, 수정, 유지보수가 용이해진다.  

**SOLID**를 통해 어떻게 낮을 결합도, 높은 응집도를 구현하는지 알아보자.  

## SOLID - 객체지향 설계 5원칙

### SRP - (단일책임 원칙: Single Responsibility Principle)

> 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다. - 로버트 c 마틴

우리는 모두 책임을 가지고 생활한다.  
학생의 책임은 공부, 군인의 책임은 방호, 개발자의 책임은 개발이다.  

개발자 종류도 여러가지가 있다,  
`웹개발`, `시스템개발`, `모바일개발`, `임베디드개발` 등등...

위의 각종 개발을 모두 할 수 있는 개발자가 있을 수도 있지만 거의 없다.  

만약 `개발자`란 클래스를 만들 때 클래스 설계를 위의 **모든 개발을 할수 있도록 설계**할 것인가?  
아니면 각종 `종류별 개발자`클래스를 **각각 설계**할 것인가?  

당연히 후자가 좋다.  

`웹`, `시스템`, `모바일` 개발 함수를 모두 `한 개발자 클래스`안에 때려넣으면 각 함수에 문제가 생길때 마다 매번 `한 개발자 클래스`에 접근해야 한다.   
**클래스 변경 이유가 여러개가 되는것이다!**  

역할과 책임에 따라 `개발자` 클래스를 `웹개발자`, `시스템개발자`, `모바일개발자`, `임베디드개발자` 등으로 나누었다.  
SRP원칙은 지킬수 있겠지만 클래스가 4개로 쪼개지는 바람에 중복코드도 많이 발생하게 된다.  
개발자란 직업이 공통으로 가지는 기능, 예를 들어 `출근하기()`, `잠자기()` 같은 기본적인 기능들! 클래스마다 별도로 선언해야 하는가?

만약 `시스템 개발자` 중에서도 `리눅스 시스템 개발자`, `윈도우 시스템 개발자` 같은 또 다른 별도의 클래스를 설계해야 한다면?   
시스템 개발이다 보니 약간 차이가 있겠지만 대부분 `c/c++`을 사용할 것이다, 공통적으로 가지는 기능들이 매우 많을텐데 다시 그대로 정의해야 하는가?

만약 개발을 오래한 사람이라면 `윈도우 시스템 개발`도 하면서 `안드로이드 모바일 개발`도 할 수 있는 개발자가 있을 것이다.  
그렇다면 `윈도우 안드로이드 개발자` 클래스도 새로 정의해야 하는가?  

객체지향의 어려운점이 이것이다. 어디까지 추상화하고 어디서부터 구현해야 하는가이다.  
사실 위의 각종 `개발자` 클래스는 모두 **클래스로 설계하기 보단 인터페이스로 설계**하는 것이 옳다.  

~~`윈도우 20002 소켓 개발자` 정도는 구현 클래스로 해야하지 않을까?~~

> 앞으로 `interface`, `abstract class`, `class` 상관 없이 최소한의 책임을 가지는 엔티티로 설계하자.  

즉 객체지향 개발을 하려면 어느정도까지 추상화를 통해 인터페이스로 구현할 것인지,  
어디서 부턴 인터페이스들을 구현한 클래스를 설계할 것인지 효율적인 결정이 필요하다.  

또한 인터페이스로 구현하게된다면 아랫부분에 있는 `개발자`, `웹개발자`, `시스템개발자` 등은 변경이 힘들어진다.
메서드 삭제/추가, 반환값 변경 등 변화가 일어나게 되면 하위클래스를 모두 변경해야 하기 때문.  

따라서 기초가 거의 변하지 않는 클래스 외에는 인터페이스, 상속 보단 **의존객체**를 통해 코드 중복을 피한다.  


### OCP - (개방폐쇄 원칙: Open Close Principle)

> 소프트웨어 엔티티는 확장에 대해 열려있어야 하지만 변경에 대해서는 닫혀있어야 한다. - 로버트 c 마틴

OCP를 가장 잘 구현한 예는 `JDBC`이다.  

`Oracle`, `Mysql`, `MS-sql` 등 어떤 데이터 베이스 이던간에 Connection 부분만 별도의 라이브러리로 설정하고 연결하면  
그 뒤의 **sql문을 실행하고 결과값을 가져오는 과정**은 모두 똑같다.  

즉 OCP를 잘 구현하려면 **모든 엔티티가 기본적으로 가지고 있는 행위를 인터페이스로 구현**하는 것이 중요하다.  
인터페이스로 정의된 기본적 행위는 거의 변경되지 않는다, 즉 메서드 사용법이 변하지 않는다.  

또한 각종 운영체제에서 사용할 수 있도록 확장기능을 제공한다. 
물론 JVM 위에서 동작하다 보니 OS별 JDBC 코드 차이는 크지 않겠지만 세세한 부분에서 차별점을 요구할것이다.
평범한 개발자는 JDBC를 확장개발해놓은 코드를 사용해 OS구속없이 똑같은 사용법으로 DB connect가 가능하다.  


### LSP - (리스코브 치환의 원칙: The Liskov Substitution Principle)

> 서브타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다. - 로버트 c 마틴

`리스코브는 바바라 리스코프`란 사람이 만들었기 때문에 붙은 스펠이다.  

위에서 **상속과 인터페이스**는 `is a kind of`, `is able to`관계를 가져야 한다 말했는데  
위의 두 관계대로 프로그램 개발을 했다면 이미 LSP를 잘 구현한 것이다.  

자바에서의 다운 캐스팅, 업 캐스팅은 LSP를 기반으로 이루어진다.   

상위(부모) 클래스는 하위(자식)클래스인척 할 수 있다.  
하위(자식) 클래스는 상위(부모)클래스의 메서드를 호출할 수 있고 논리적으로 이상하지 않고 하위클래스에서 기능이 추가되지 삭제되진 않는다.  


### ISP - (인터페이스 분리 원칙: Interface Segregation Principle)

> 클라이언트 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다. - 로버트 c 마틴

ISP는 **인터페이스를 최소한의 기능을 가지도록 설계**하는 것을 뜻한다.  

객체지향에선 **상위(자식) 클래스**는 기능이 풍성할 수록 좋고, **인터페이스**는 작을 수록 좋다.  

먼저 클래스의 기능이 풍성해야 하는 이유를 알아보자.

```java
class 훈련병 {
  ...
  잠자기() {...}
  말하기() {...}
}
class 병사 extends 훈련병 {
  ...
  먹기() {...} //신규
  훈련하기() {...} //신규
}
``` 
위와 같은 클래스가 정의되어 있을때 `훈련병 홍길동 = new 병사();` 으로 **훈련병 인스턴스**를 생성하자.  

`홍길동` 객체를 통해서 호출할 수 있는건 `훈련병` 인터페이스에 정의된 추상메서드 `잠자기()` 뿐이다.  
만약 `먹기()`를 억지로 사용하려 한다면 억지로 형변환 과정이 필요하다. `((병사)홍길동).먹기();`  

사실 `먹기()`는 `훈련병` 클래스 정의되는게 맞다. 즉 클래스 정의할땐 의 책임안에서 최대한(풍성한)의 기능을 제공해야한다.  

이번엔 인터페이스의 기능을 최소화 해야 하는 이유를 알아보자.  

```java
interface 훈련병 {
  ...
  잠자기();
  먹기();
  말하기();
}
class 병사 implements 훈련병 {
  ...
  잠자기() {...} //구현
  먹기() {...} //구현
  말하기() {...} //구현
  훈련하기() {...} //신규
}
```

조금 억지이지만 `훈련병`은 꼭 사람만 될 수 있는가? 개도 될 수 있다 생각해보자.  
개는 말할 수 있는가? 항상 `is able to` 기준으로 인터페이스를 생성하고 역할에 충실한 최소한의 기능만 구현하자.

```java
interface 훈련병 {
  ...
  잠자기();
  먹기();
}
class 군견 implements 훈련병 {
  ...
  잠자기() {...} //구현
  먹기() {...} //구현
  짖기() {...} //신규
  훈련하기() {...} //신규
}
```

SRP에선 **클래스의 단일 책임**을,  
ISP에선 **인터페이스의 단일 책임**을 요구한다.  

만약 최소한의 기능이지만 많은 기능이 들어갈 수 밖에 없다면 인터페이스 보단 SRP를 따라 클래스로 만드는 것이 좋다.

즉 하나의 엔티티를 여러개의 엔티티로 쪼갤 수 있다면 ISP를  
하나의 엔티티를 쪼갤 수 없고, 쪼갠다 하더라도 많은 기능이 포함된다면 SRP이다.  

어디까지는 인터페이스로 설계하고 어디까지는 클래스로 설계하는 지에 대한 경계를 정할 수 있다!
(대부분이 SRP 로 진행된다.)

### DIP - (의존역전 원칙: Dependency Inversion Principle)

> 자신보다 변하기 쉬운것에 의존하지 마라

객체가 의존관계를 가질때 최대한 상위클래스, 추상클래스, 인터페이스와 같은 불변할 가능서이 높은 객체를 의존하도록 하는 법칙
상위 클래스일 수록 변할 가능성이 적기 때문에 의존관계를 갖는 객체또한 영향을 받는 가능성이 적어진다.  

만약 하위클래스를 의존하게 된다면 **하위클래스가 계속 변함에 따라 오히려 서로 의존하는 관계가 될 수 있다.**  
이를 의존 역전 원칙이라 한다.  

![image02]({{ "/assets/java/jdbc/days01/image2.png" | absolute_url }}){: .shadow}  

잠시 위의 jdbc 구성도를 확인하자, 오라클 DB에 연결하기 위한 JDBC 구성도이다.  

`프로그램 → DriverManager → JDBC인터페이스 → JDBC드라이버 → DB`  

프로그램은 `DriverManager`를 통해 `JDBC인터페이스`에 접근하고 `JDBC인터페이스`의 구현체인 `JDBC드라이버`를 통해 DB에 접근한다.

그림을 보면 4가지 `JDBC드라이버`가 존재하는데 만약 `JDBC인터페이스` 없이 바로 `JDBC드라이버`를 통해 DB에 접근한다 해보자.  

DB가 업데이트 되면서 기존의 `JDBC드라이버`의 메서드들 또한 업데이트 되었다. 프로그램은 당연히 오류를 내뿜고 `JDBC드라이버` 접근 코드를 모두 수정해야 한다. 나의 프로그램이 `JDBC드라이버` 를 의존하면서 발생한 불상사이다.

하지만 `JDBC인터페이스`를 통해 `JDBC드라이버`를 사용중이라면 오라클사가 개발한 `JDBC드라이버`만 새로운 버전으로 업데이트 하면 된다. (오라클사가 `JDBC인터페이스`를 기반으로 개발하는 가정하에)  

어쩃건 `JDBC인터페이스`는 모든 DB 밴더사가 불변한단 가정하에 개발해주기 때문에 신뢰하며 사용할 수 있는 객체이다.   

즉 의존관계가 필요할 경우 최대한 불변할 것 같은 객체(상위클래스, 인터페이스 등)을 의존관계로 두도록 하는것이 DIP 이다.
