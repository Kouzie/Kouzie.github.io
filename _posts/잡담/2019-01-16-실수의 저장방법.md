---
title:  "실수의 메모리 저장 방법!"
read_time: false
share: false
toc: true
author_profile: false
classes: wide

categories:
  - Java
tags:
  - Java
  - 문법
---

### 실수의 메모리 저장방법

**컴퓨터에선 지수와 가수로 표현하는 부동소수점방식을 사용해서 실수를 표시한다**

```	
float	1(s부호) 8(m지수) 23(e가수)     4byte

double	1(s부호) 11(m지수) 52(e가수)    8byte  
```
서로 크기가 다르기 때문에 저장되는 위치가 약간 달라지지만 같은 원칙으로, 부동소수점으로 저장된다   

일단 소수를 2진법으로 변환하는 과정을 알아보자  

0.625를 2진법으로 표시하는 방법    
```
0.625 * 2  = [1].25
0.25  * 2  = [0].5
0.5   * 2  = [1].0
```
**결과 0.101**   

0.625의 경우 **운좋게 끝자리가 다 떨어져서** `101`이란 2진법으로 표현 됬지만  
떨어지지 않는경우 끝없이 이어지면서 **무한소수**로 표시된다.      

그래서 컴퓨터에선 2진법으로 소수를 처리할때 떨어지지 않는다면 무한소수로 이루어지고 메모리 공간은 유한하기 때문에 뒤에 bit는 버리면서
오차가 새길 수 밖에 없다.  


`9.1234567`을 2진수로 표시하면 다음과 같다.    
`1001.000111111001101011001111.....`(끝없이 이어진다, 위처럼 딱 나누어지지 않으니까...)  

변수의 크기는 유한함으로 `float의 경우 4byte`, `double의 경우 8byte`만큼 저장된다.  

`float`의 경우 데이터를 저장할수 있는 실제 공간은 `32bit`중 `23bit`밖에 없는데(나머지는 부호와 지수) 10진수 7개자리정도의 숫자정도를 표시할 수 있다.  

어쨋든 `1001.000111111001101011001111`을 메모리에 저장하려면 정규화 과정이 필요한데 정규화 과정은 위 데이터를 지수와 가수로 나누는 것이다
`+-M * 2E`로 표기한다.  

`1001.000111111001101011001111`은 `1.001000111111001101011001111` X `2^3` 과 같다.  
여기서 `2^3`의 3이 지수로 들어간다.  

여기서 1을 제외한 `001000111111001101011001111` 데이터가 가수자리(`23bit`)로 들어가게 되고  
데이터는 `23bit`가 넘음으로 당연히 짤려서 저장된다, `23bit`인 `00100011111100110101100`만 저장된다.  
(정규화된 2진 실수는 무조건 1로 시작하니까 굳이 앞의 1을 넣어서 공간 차지할 필요 없음)

지수 3은 float의 기저 127(2비트로 `01111111`)에서 3을 더한 130(`10000010`)로 지수에 저장된다.  
결국 변환된 `9.1234567`은 다음과 같다.  
```
 0      10000010 	00100011111100110101110   모두 합쳐서 (32bit)
부호	  지수 		  가수
```