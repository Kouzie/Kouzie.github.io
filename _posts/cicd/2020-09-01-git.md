---
title:  "git cli!"

read_time: false
share: false
author_profile: false
toc: true
toc_sticky: true
# classes: wide

categories:
  - tools
---

## git

익숙하지 않은 git 명령어만 정리

### Reset

잘못 올린 커밋 원격 리포지토리에서도 취소하기  

```sh
git reset --hard "commit id"
git push -f
```

```sh
git reset --hard origin/master
git pull origin master
```

### Reflog

실수로 `reset` 한거 되돌리기 

```sh
git reflog
git reset --hard HEAD@{3}
```

### Rebase

> https://velog.io/@kwonh/Git-Rebase%EB%9E%80

짜잘하게 올린 git 통합하기

`head` 에서 2개 총 2개의 `commit` 을 합치기

```sh
git rebase -i HEAD~2
git push origin +<branch-name>
```

아래서부터가 최신, 위로 갈 수록 이전 이다.  

맨위의 `pick` 을 남기고 아래 `pick` 은 모두 `squash` 로 대채해준다.  
`pick` 밑의 여러개의 커밋에 `squash` 를 쓰면 해당 `commit` 은 `pick` 한 커밋 과 합쳐지게 된다.  
저장하고 나가면서 `commit message` 수정 인터페이스가 나오니 원하는 메세지로 대체하면 된다.(주석 빼고 다 메세지로 적용됨)

그냥 `push` 하면 이미 올라간 `history` 와 출동나서 `merge` 해야 함으로 브랜치명에 `+` 를 더해 강제로 덮어씌운다.

개인 브랜치에서 하지 않으면 충돌나기 때문에 공용으로 사용되는 공간에선 사용하면 안된다.  

### commit --amend

마지막 커밋 파일추가, 메세지 수정하기  

기존 커밋에 수정된 파일을 밀어넣고 메세지를 수정할 수 있다.  

```sh
git commit --amend
```

### commit --soft

마지막 커밋을 취소하고 변경된 파일을 다시 `stage` 로 돌리고 싶을때 사용.

`local commit` 만 사용하길 권장.

```sh
git reset --soft 97b88eb
git reset --soft HEAD^
```

### rm --cached 원격 저장소 파일 삭제  

```sh
git rm --cached .idea/modules.xml
git rm --cached -r .idea/
git commit -m "Fixed untracked files"
// 원격 저장소(origin)에 push
git push origin master
```

find . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch

### checkout

브랜치 전환, 파일체크아웃, head 변경 등에 사용되는 만능명령어

commit을 원하지 않은 파일을 rollback 하고싶을때 아래와 같이 사용

```sh
git checkout dev
git checkout -b new-dev # 새로운 branch 생성
git checkout 58f0ab9 # 특정 커밋으로 HEAD를 이동
git checkout {filename}
```

### switch

브랜치의 전환만을 위한 명령어

```sh
git switch dev
```

### merge reequest & pull request  

`gitlab` 에선 `merge request`  
`github` 에선 `pull request`  

### upstream

fork 한 프로젝트의 코드를 다른 위치에 원본 있는 프로젝트로부터 동기화해야 할 때 사용하는 명령어  

```sh
git remote add upstream https://github.com/Kouzie/test-repo
git remote -v                                                     
# origin  https://gitlab.my.company.com/demo-group/test-repo (fetch)
# origin  https://gitlab.my.company.com/demo-group/test-repo (push)
# upstream        https://github.com/Kouzie/test-repo (fetch)
# upstream        https://github.com/Kouzie/test-repo (push)

git remote fetch # 원격 데이터 fetch
git merge upstream/main # upstream 의 main 으로부터 merge

git remote rm upstream # 로컬에 연결된 remote upstream 삭제
```

### submodule

저장소 안에 또 다른 깃 저장소가 필요한 경우 사용.  
하나의 Git 저장소 내에서 다른 Git 저장소를 서브디렉토리로 포함시키는 방법.  

각 서브모듈은 독립된 Git 저장소로 관리되며, 상위 프로젝트와 별개로 버전 관리된다.

아래와 같이 3개의 repository 가 있을 때  

```sh
git clone https://gitlab.my.company.com/test-group/root-module
git clone https://gitlab.my.company.com/test-group/sub-module-a
git clone https://gitlab.my.company.com/test-group/sub-module-b
```

`root-module repository` 에  `sub-module repository` 2개 를 `submodule` 로 삽입한다.  

```sh
cd root-module
git submodule add https://gitlab.my.company.com/test-group/sub-module-a
git submodule add https://gitlab.my.company.com/test-group/sub-module-b

cat .gitmodules
# [submodule "sub-module-a"]
#   path = sub-module-a
#   url = https://gitlab.my.company.com/test-group/sub-module-a
# [submodule "sub-module-b"]
#   path = sub-module-b
#   url = https://gitlab.my.company.com/test-group/sub-module-b
```

![image26](/assets/기타/git-1.png)

각 디렉토리에는 별도의 `.git` 파일이 존재하고 `commit 버전`을 기준으로 연결시키기 때문에 별도의 pull 처리를 해줘야 버전을 따라갈 수 있다.  
또한 `root repository` 에서 어떤 `commit 버전`을 사용할지도 결정해줘야 한다.  

### subtree

subtree는 하나의 Git 저장소 내에서 다른 Git 저장소의 내용을 특정 디렉토리로 병합하는 방법입니다.
서브트리는 상위 프로젝트의 일부로 취급되며, 하나의 통합된 Git 기록을 가집니다.

```sh
git clone https://gitlab.my.company.com/test-group/root-tree
git clone https://gitlab.my.company.com/test-group/sub-tree-a
git clone https://gitlab.my.company.com/test-group/sub-tree-b

git subtree add --prefix=sub-tree-a https://gitlab.my.company.com/test-group/sub-tree-a main

git fetch https://gitlab.my.company.com/test-group/sub-tree-a main
# warning: redirecting to https://gitlab.my.company.com/test-group/sub-tree-a.git/
# remote: Enumerating objects: 3, done.
# remote: Counting objects: 100% (3/3), done.
# remote: Compressing objects: 100% (2/2), done.
# remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
# Unpacking objects: 100% (3/3), 2.79 KiB | 570.00 KiB/s, done.
# From https://gitlab.my.company.com/test-group/sub-tree-a
#  * branch            main       -> FETCH_HEAD
# Added dir 'sub-tree-a'

ls
# README.md  sub-tree-a
```

subtree 는 기존 git 의 history 를 보존하면서 두 repository 를 합칠 수 있다.  

```sh
git log
# 두 repository 의 로그가 모두 저장되어있는지 확인
```

subtree 에서 변경된 내용을 pull 해올 수 있고  
root 에서 subtress 의 내용을 변경하고 push 할 수 있다.  

```sh
git subtree pull --prefix=sub-tree-a https://gitlab.my.company.com/test-group/sub-tree-a main

# warning: redirecting to https://gitlab.my.company.com/test-group/sub-tree-a.git/
# remote: Enumerating objects: 4, done.
# remote: Counting objects: 100% (4/4), done.
# remote: Compressing objects: 100% (2/2), done.
# remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
# Unpacking objects: 100% (3/3), 258 bytes | 86.00 KiB/s, done.
# From https://gitlab.my.company.com/test-group/sub-tree-a
#  * branch            main       -> FETCH_HEAD
# Merge made by the 'ort' strategy.
#  sub-tree-a/testb.txt | 0
#  1 file changed, 0 insertions(+), 0 deletions(-)
#  create mode 100644 sub-tree-a/testb.txt
```

```sh
git add .
git commit -m "add test.txt at subtree"
# root main 에다 push
git push
# subtree 에다가 push
git subtree push --prefix=sub-tree-a https://gitlab.my.company.com/test-group/sub-tree-a main

git push using:  https://gitlab.my.company.com/test-group/sub-tree-a main
warning: redirecting to https://gitlab.my.company.com/test-group/sub-tree-a.git/
Enumerating objects: 3, done.
Counting objects: 100% (3/3), done.
Delta compression using up to 8 threads
Compressing objects: 100% (2/2), done.
Writing objects: 100% (2/2), 260 bytes | 260.00 KiB/s, done.
Total 2 (delta 1), reused 0 (delta 0), pack-reused 0
To https://gitlab.my.company.com/test-group/sub-tree-a
   373ffb7..c76ee34  c76ee34422e3dcb9ecfcbe9c60bf9f7bdb3d08cc -> main
```

#### 추가 옵션

subtree로 사용할 원격 저장소 추가

```sh
# git remote add <원격 저장소의 이름> <원격 저장소의 주소>
git remote add demo-lib https://gitlab.my.company.com/test-group/demo-lib

# demo-lib 라는 이름으로 새로운 원격 저장소가 추가되었다.
git remote
# origin
# demo-lib
```

새로운 원격 저장소의 브랜치를 서브트리로 추가

```sh
# git subtree add --prefix <클론할 폴더> <원격 저장소의 이름> <브랜치 이름>
git subtree add -P src/demo-lib https://gitlab.my.company.com/test-group/demo-lib main
```

### .gitignore

깃허브에 올리지 말아야할 정보(OS, IDE 시스템정보 등)를 git 에 올리는 것을 방지,  

대다수의 IDE 가 프로젝트 생성시 알아서 `.gitignore` 파일을 만들어 주지만  
특수한 상황에서 직접 `.gitignore` 만들어야 할 때 아래 사이트 추천  

> <https://www.gitignore.io/>
![image26](/assets/Spring/image26.png)

위와같이 현재 사용중인 시스템 정보를 삽입하면 아래와 같은 설정이 자동으로 생성된다.  

```conf
# Created by https://www.gitignore.io/api/git,java,maven,windows,eclipse
# Edit at https://www.gitignore.io/?templates=git,java,maven,windows,eclipse

### Eclipse ###
.metadata
bin/
tmp/
*.tmp
*.bak
*.swp
*~.nib
local.properties
.settings/
.loadpath
.recommenders

# sbteclipse plugin
.target

# Tern plugin
.tern-project

# TeXlipse plugin
.texlipse

# STS (Spring Tool Suite)
.springBeans
...
...
```

이파일 내용을 `.gitignore` 파일로 저장  