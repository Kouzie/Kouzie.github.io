---
title:  "Kotlin - 클래스!"

read_time: false
share: false
author_profile: false
toc: true
toc_sticky: true
# classes: wide

categories:
  - kotlin
---

## 클래스

`kotlin` 클래스는 `java` 와 상당부분 다름  
아래 처음보는 형식의 클래스 정의문을 하나씩 살펴보도록 한다.  

```kotlin
// 기본생성자 (primary constructor) constructor 키워드생략 가능
class Person (name: String) { 

    // 멤버변수
    private val firstProperty = "First property: $name"

    // 보조 생성자 (Secondary constructor)
    constructor(i: Int) : this(i.toString()) { 
        println("Secondary constructor block that prints $i")
    }

    // 생성자 초기화 init 블럭
    init { 
        println("First initializer block that pr-ints $name")
    }

    fun printName(): String = this.firstProperty
}
```

### 기본 생성자: Primary constructor

```kotlin
class Person constructor(name: String) {
    val name = name
    fun hello() {
        println("my name is ${name}")
    }
}
...
// 아래처럼 멤버변수 정의 생략 가능  
class Person (val name: String) {
    fun hello() {
        println("my name is ${name}")
    }
}
```

기본생성자에 initial 데이터를 추가하면 자동으로 입력값에 맞는 생성자를 여러개 생성함.  

```kotlin
class Person (val name: String = "kouzie") {
    fun hello() {
        println("my name is ${name}")
    }
}

fun main() {
    var human1 = Person("test")
    var human2 = Person()
    human1.hello() // my name is test
    human2.hello() // my name is kouzie
}
```

### 보조 생성자: Secondary constructor

```kotlin
class Person(val name: String = "kouzie") {

    // Secondary constructor
    constructor(name: String, age: Int) : this(name) {
        println("my name is ${name} and ${age} years old")
    }

    fun hello() {
        println("my name is ${name}")
    }
}
fun main() {
    var human = Person("test", 26) // my name is test and 26 years old
}
```

`c++` 의 생성자와 비슷하게 생겼는데 보조생성자는 항상 주 생성자에다 데이터를 전달하는 형식으로 정의된다.  

### init 블럭

생성하면서 특정 코드를 클래스 블럭 내부에서 실행하고 싶다면 `init` 블럭 사용  

```kotlin
class Person(val name: String = "kouzie") {
    
    constructor(name: String, age: Int) : this(name) {
        println("my name is ${name} and ${age} years old")
    }
    
    init {
        println("my name is ${name}")
    }

    fun hello() {
        println("my name is ${name}")
    }
}

fun main() {
    var human = Person("test", 26)
    // my name is test
    // my name is test and 26 years old
}
```

중요한점은 `init` 블록이 항상 먼저 실행된다는 점  
그리고 위와 같이 **기본생성자에 정의된 멤버변수**는 가져와서 사용할 수 있다.  

### property

`kotlin`은 모든 `property` 에 `public` 하게 접근 가능하다,  
다른 객체지향 언어의 캡슐화, 은닉 원칙을 무시하는 것처럼 보인다.  

사실 바이트 코드로 변경되면서 모든 필드는 `private` 에 **지원필드**인 `backing field(get, set)` 를 사용하는 코드로 변경된다.  

#### backing field

즉 `kotlin`에서 `property` 는 `private field + backing field` 가 모두 포함된 개념이라 할 수 있다.  

아래와 같이 2개의 `property` 를 정의  

```kotlin
class Task(val name: String) {
    var priority = 3
    fun print() {
        println("${this.name}, ${this.priority}")
    }
}
fun main() {
    var myTask = Task("kouzie")
    var myTask = Task("kouzie").apply { priority = 4 }
    myTask.print() // kouzie, 4
}
```

`name` 은 생성자에서, `priority` 는 바로 접근해서 초기화 가능하다.  
최상위 직접 접근해 초기화 가능하지만 직관적, 함축적인 이유로 `apply` 블록을 쓰는것을 권장한다.  

만약 특정 조건을 통해 `backing field` 정의를 해야한다면 **지원필드**인 `backing field` 를 재정의 하면 된다.  

예로 특정 필드의 값이 반드시 `1~5` 사이의 값이어야 할 경우 아래와 같이 지정한다.  

```kotlin
class Task(val name: String) {
    var priority = 3
        set(value) {
            field = value.coerceIn(1, 5)
        }

    fun print() {
        println("${this.name}, ${this.priority}")
    }
}

fun main() {
    var myTask = Task("kouzie")
    myTask.priority = 7
    myTask.print() // kouzie, 5
    myTask.apply { priority = -1 }
    myTask.print() // kouzie, 1
}
```

또한 실제 값이 설정되어 있지 않는 `property` 라 하더라도 `backing field` 정의가 가능하다.  

`val` 로 `property를` 지정하고 `get` 을 정의하면된다.  
실제 바이너리도 `getter` 함수만 정의되어 있다.  

> 원래 `val` 은 최상위 `property` 로 사용하려면 초기화를 해야하지만 `backing field` 로 사용할거면 상관없다.  

```kotlin
class Task(val name: String) {
    var priority = 3
        set(value) {
            field = value.coerceIn(1, 5)
        }

    val isLowPriority: Boolean
        get() {
            return priority < 3
        }

    fun print() {
        println("${this.name}, ${this.priority}, ${this.isLowPriority}")
    }
}

fun main() {
    var myTask = Task("kouzie")
    myTask.apply { priority = 1 }
    myTask.print() // kouzie, 1, true
}
```

> 실제 Byte 코드를 디컴파일하면 필드 없이 `getter` 함수만 정의됨을 알 수 있음  


### 가시성 - private, protected, internal, public

`kotlin` 의 모든 코드는 기본 `public` 이다.  

> `java` 에서 모든 필드를 `private` 으로 정의하고 `getter` 를 남발하며 구현하는 의미론적 은닉성을 제거하기 위한 조치로 보인다.  
> `kotlin` 에선 정말 은닉해야할 데이터만 별도로 `private` 키워드를 사용하고 나머지는 `public` 하게 사용할 수 있도록 한다.  
> `internal` 는 `kotlin` 만의 가시성 키워드로 같은 모듈에서만 접근가능하다.  

`java` 코드로 디컴파일하면 아래와 같다.  

```kotlin
open class TestClass {
    private val var1 = 100
    protected val var2 = 100
    internal val var3 = 100
    public val var4 = 100
    val var5 = 100
}
```

```java
public class TestClass {
    private final int var1 = 100;
    private final int var2 = 100;
    private final int var3 = 100;
    private final int var4 = 100;
    private final int var5 = 100;
    
    protected final int getVar2() { return this.var2; }
    
    public final int getVar3$kotlin_gradle() { return this.var3; }
    
    public final int getVar4() { return this.var4; }
    
    public final int getVar5() { return this.var5;}
}
```

`private` 키워드로 정의한 경우만 `getter` 가 생성되지 않는다.  
> 진정한 데이터 은닉을 제공한다.  

다음과 같은 지연로딩 비슷한 기능을 구현할 때 아래와 같이 사용할 수 있다.  

> 지연로딩은 `null` 처리를 하기위한 방법론

```kotlin
class Customer(val name: String) {
    private var _message: List<String>? = null

    val message: List<String>
        get() {
            if (_message == null) {
                _message = loadMessage()
            }
            return _message!!
        }

    private fun loadMessage(): List<String>? {
        return listOf(
            "Initial contact",
            "Convinced them to use Kotlin",
            "Sold training class. Sweet."
        ).also { println("Loaded messages") }
    }
}

fun main() {
    val c1 = Customer("kouzie").apply { messages } // Loaded messages, 지연로딩
    println(c1.messages) // [Initial contact, Convinced them to use Kotlin, Sold training class. Sweet.]
}
```

`backing field` 용 `val message: List<String>` 정의  
실 데이터는 `private var _message` 에 정의되어 있다.  

`apply` 키워드를 사용하면 `get` 을 사용하는것과 동일하다.  

### companion object(동반 객체), const

**컴파일타임에 정의되는 상수**와 메서드를 정의할 때 사용  

`const` 키워드를 사용해 상수를 생성한다.  

> `java` 의 `static final` 과 비슷
> kotlin 에선 `root 레벨` 블록이나 `companion object` 에서만 사용 가능  

```kotlin
interface IdProvider {
    fun getId(): Int
}

class Book private constructor(val id: Int, val name: String) {
    companion object BookFactory :IdProvider{
        const val myBook = "DEFAULT_BOOK"
        override fun getId(): Int {
            return 444
        }
        fun create(): Book = Book(getId(), "animal farm")
    }

    override fun toString(): String {
        return "Book(id=$id, name='$name')"
    }
}

fun main() {
    val book = Book.create();
    println(Book.BookFactory.myBook) // DEFAULT_BOOK
    println(Book.myBook) // DEFAULT_BOOK, 생략 가능
    println(book) // Book(id=444, name='animal farm')
}
```

`companion object` 도 클래스이기 때문에 이름을 지정하거나 `interface` 의 상속 및 구현 가능하다.  

### data class - dto 클래스

데이터를 담는 클래스로 사용, `toString`, `hashCode`, `equals`, `copy(얕은복사)` 등 데이터 처리용 함수들이 자동생성됨  

```kotlin
data class Product constructor(
    val name: String,
    val price: Double = 0.0,
    val desc: String? = null
)
```

> 필드에 실수타입 있다면 `closeTo` 함수를 사용해 비교한다.  

디스트럭쳐링 문법도 제공한다.

```kotlin
fun main() {
    val p1 = Product("product1", 2000.0, true)
    val (name, price) = p1;
    println("$name $price") // product1 2000.0
}
```

### object class - 싱글톤

일반적으로 싱글톤 패턴은 생성자를 private 으로 설정하고 static 으로 정의된 정적 팩토리 메서드를 사용해 구현한다.  

`object` 키워드로 클래스를 정의하면 별도 작업없이 싱글톤 클래스 정의가 가능하다.  

```kotlin
object ProductFactory {
    var products = mutableListOf<Product>()

    fun makeProduct(name: String, price: Double, onSale: Boolean): Product {
        val p = Product(name, price, onSale)
        products.add(p)
        return p
    }
}

fun main() {
    val pf = ProductFactory;
    var p1 = pf.makeProduct("pencil", 1000.0, false);
    println(p1) // Product(name=pencil, price=1000.0, onSale=false)
    println(pf.products) // [Product(name=pencil, price=1000.0, onSale=false)]
}
```

생성된 바이트코드를 디컴파일하면 아래와 같다.  

```kotlin
public final class ProductFactory {
   @NotNull
   private static List products;
   @NotNull
   public static final ProductFactory INSTANCE;

   @NotNull
   public final List getProducts() {
      return products;
   }

   public final void setProducts(@NotNull List var1) {
      Intrinsics.checkParameterIsNotNull(var1, "<set-?>");
      products = var1;
   }

   @NotNull
   public final Product makeProduct(@NotNull String name, double price, boolean onSale) {
      Intrinsics.checkParameterIsNotNull(name, "name");
      Product p = new Product(name, price, onSale);
      products.add(p);
      return p;
   }

   private ProductFactory() {
   }

   static {
      ProductFactory var0 = new ProductFactory();
      INSTANCE = var0;
      products = (List)(new ArrayList());
   }
}
```

내부적으론 바이트코드에서 생성한 `ProductFactory.INSTANCE` 를 사용한다.  

`object` 키워드가 편하긴 하지만 최초생성 시점을 지정할 수 없는 점  
그로인해 생성자에 인자를 넘길 수 없는 점 이 단점이다.  

### 내포클래스, 이너클래스, 지역클래스  

```kotlin
class Outer {
    val bar: Int = 1

    // 내포클래스
    class Nested {
        private val nestVar = 999
        fun foo(): Int {
            // return nestVar + bar // 내포클래스에선 외부클래스 접근 불가
            return nestVar
        }
    }

    // 이너클래스
    inner class Inner {
        private val innerVar = 999
        fun foo(): Int {
            return innerVar + bar
        }
    }
}

fun main() {
    println(Outer.Nested().foo()) // 999
    // 이너클래스는 내부맴버취급이기에 외부클래스 생성후 사용 가능하다.
    println(Outer().Inner().foo()) // 1000
}
```



```kotlin
fun localClasses() {
    open class Amphibian {
        open fun foo() = "foo"
    }

    class Frog : Amphibian() {
        override fun foo() = "bar"
    }

    val amphibian = Frog()
    println(amphibian.foo())
}


fun main() {
    localClasses()
}
```


## 클래스 상속  

`kotlin` 에서 `class` 는 항상 `final` 로 정의된다.  

따라서 다음처럼 `open` 키워드로 상속 클래스임을 알려야 한다.  

### Any, Unit, Nothing  

#### Any

`java` 에서 모든 객체의 최상위 부모객체가 `Object` 인것처럼  
`kotiln` 에선 최상위 부모객체가 `Any` 이다.  

```kotlin
public open class Any {
    public open operator fun equals(other: Any?): Boolean
    public open fun hashCode(): Int
    public open fun toString(): String
}

...

val str: Any = "Hello, World!"
```

`kotlin` 에서 클래스, 메서드는 기본적으로 `final` 이기 때문에  
상속하려면 `open` 키워드를 별도로 붙여야 한다.  

#### Unit

`kotlin` 에선 반환값이 없을때 `void` 대신 `Unit` 객체를 반환한다.  

```kotlin
// The type with only one value: the `Unit` object. This type corresponds to the `void` type in Java.
public object Unit {
    override fun toString() = "kotli.unit"
}

...

fun returnVoid(): Unit { // 명시적 반환 생략 가능  
    println("hello world")
    return
}
```

`Unit` 은 싱글톤 인스턴스로 `void` 를 포함한 모든 데이터를 객체로 표기하기 위한 `kotlin` 의 의지가 보이는 클래스이다.  

```kotlin
val u = returnVoid() // hello world
println(u) // kotlin.Unit
```

#### Nothihng & null

정말 반환하지 않는 함수를 표현하기 위해서는 `Nothing` 클래스를 사용한다.  
무한반복이나 `Exception` 이 발생할 경우 반환값이 `Nothing` 이 된다.  

```kotlin
fun doNothing(): Nothing {
    throw Exception("Nothing at all")
}
```

변수에 `null` 을 할당하면 `Nothing?` 타입으로 추론된다.  

```kotlin
val n = null // Nothing? type
println(n is Nothing?)
```

또한 `if...else` 문을 사용하여 아래와같이 반환할 때에도 `Nothing` 을 사용하며  
그다음 줄부턴 컴파일러가 해당 변수를 `String` 으로 추론한다.  

```kotlin
// true 일경우 문자열, false 일경우 Nothing 반환
val x = if (Random.nextBoolean()) "T" else throw Exception("F")
// 이후 코드부턴 String? 으로 추론 
println(x::class.simpleName)
```

### 클래스 합성(composition)

요새는 상속보다 대리자를 통해 **클래스 합성(composition)** 하는것이 대세  

아래와 같이 by 키워드로 인스턴스의 메서드들을 그대로 합성해서 사용할 수 있다.  

```kotlin
interface Dialable {
    fun dial(number: String): String
}

class Phone : Dialable {
    override fun dial(number: String) = "Dialing $number..."
}

interface Snappable {
    fun takePicture(): String
}

class Camera : Snappable {
    override fun takePicture() = "Taking picture..."
}

class SmartPhone(
    private val phone: Dialable = Phone(),
    private val camera: Snappable = Camera()
) : Dialable by phone, Snappable by camera

fun main() {
    val smartPhone: SmartPhone = SmartPhone()
    println(smartPhone.dial("555-1234")) // Dialing 555-1234...
    println(smartPhone.takePicture()) // Taking picture...
}
```

변환된 바이트코드를 보면 아래와 같다.  

```java
public final class SmartPhone implements Dialable, Snappable {
   private final Dialable phone;
   private final Snappable camera;

   public SmartPhone(@NotNull Dialable phone, @NotNull Snappable camera) {
      super();
      this.phone = phone;
      this.camera = camera;
   }
   ...
   public SmartPhone() {
      this((Dialable)(new Phone()), (Snappable)(new Camera()));
   }

   @NotNull
   public String dial(@NotNull String number) {
      Intrinsics.checkParameterIsNotNull(number, "number");
      return this.phone.dial(number);
   }

   @NotNull
   public String takePicture() {
      return this.camera.takePicture();
   }
}
```

객체 필드명과 map 의 key 값이 일치할 경우 다음과 같이 by 키워드로 적용 가능하다.  

```kotlin
data class Project(val map: MutableMap<String, Any?>) {
    val name: String by map
    var priority: Int by map
    var completed: Boolean by map
}

fun main() {
    var map: MutableMap<String, Any?> = mutableMapOf("name" to "Learn Kotlin", "priority" to 5, "completed" to true)
    var p = Project(map)
    println(p) // Project(map={name=Learn Kotlin, priority=5, completed=true})
}
```

## 클래스 대리자(class delegate)

`kotlin` 에선 `Delgate`(대리자) 클래스를 이용해 여러 편의기능을 지원한다.  

### lazy

`kotlin` 에선 `null` 처리를 좀더 효율적으로 하기 위한 `lazy` 대리자 키워드를 제공한다.  
접근이 일어날 때 `() -> T` 형식의 초기화 람다를

```kotlin
class Customer(val name: String) {
    val message: List<String> by lazy {
        mutableListOf("hi", "hello", "by")
            .also { println("initial complete") }
    }
}

fun main() {
    val c1 = Customer("kouzie")
    println(c1.message)
    // initial complete 
    // [hi, hello, by]
    println(c1.message) // [hi, hello, by]
}
```

`mode` 를 추가하여 `lazy` 코드의 락 처리가 가능하다.  

```kotlin
val message: List<String> by lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED, initializer = {
    mutableListOf("hi", "hello", "by")
        .also { println("initial complete") }
})
```

`SYNCHRONIZED(defaulit)`: 오직 하나의 스레드만 Lazy 인스턴스를 초기화할 수 있게 락을 사용
`PUBLICATION`: 초기화 함수가 여러 번 호출될 수 있지만 첫 번째 리턴값만 사용됨
`NONE`: 락이 사용되지 않음

### notNull

초기화 전에 접근시 예외를 발생시킨다.  

```kotlin
fun main() {
    var str1: String by Delegates.notNull()
    println(str1) // IllegalStateException at kotlin.properties.NotNullVar.getValue
}

fun main() {
    lateinit var str2: String
    println(str2) // UninitializedPropertyAccessException
}
```

비슷한 키워드로 `lateinit` 가 있으며 변환된 바이트코드는 아래와 같다.  

```java
public static final void main() {
    ReadWriteProperty var10000 = Delegates.INSTANCE.notNull();
    KProperty var1 = $$delegatedProperties[0];
    ReadWriteProperty str1 = var10000;
    Object var2 = str1.getValue((Object)null, var1);
    System.out.println(var2);
}

public static final void main() {
    String str2 = null;
    Intrinsics.throwUninitializedPropertyAccessException("str2");
    System.out.println(str2);
}
```

`notNull` 대리자의 경우 `ReadWriteProperty` 클래스로 한번 감싸기 때문에 `primitive type` 도 체크 가능하지만  
`lateinit` 의 경우 변수에 `null` 을 대입하기에 `primitive type`은 사용할 수 없다.  

```kotlin
var test:Int = null; // 컴파일 오류
lateinit var str2: Int // 컴파일 오류
```

```kotlin
public interface ReadWriteProperty<in R, T> {
    public operator fun getValue(thisRef: R, property: KProperty<*>): T
    public operator fun setValue(thisRef: R, property: KProperty<*>, value: T)
}
```

### observable, vetoable

변경 감지에는 `observable`  
변경 감지 + 적용 여부를 결정에는 `vetoable`  

```kotlin
fun main() {
    // init by 1
    var watched: Int by Delegates.observable(1) { prop, old, new ->
        println("${prop.name} changed from $old to $new")
    }

    // init by 0
    var checked: Int by Delegates.vetoable(2) { prop, old, new ->
        println("Trying to change ${prop.name} from $old to $new")
        new >= 0
    }

    watched = 10 // watched changed from 1 to 10
    checked = -10 // Trying to change checked from 2 to -10
    println(watched) // 10
    println(checked) // 2
}
```

`observable`, `vetoable` 도 `ObservableProperty` 래핑클래스로 관리되며 `primitive type` 도 체크 가능하다.  

```kotlin
public abstract class ObservableProperty<T>(initialValue: T) : ReadWriteProperty<Any?, T> {
    protected open fun beforeChange(property: KProperty<*>, oldValue: T, newValue: T): Boolean = true
    protected open fun afterChange(property: KProperty<*>, oldValue: T, newValue: T): Unit {}
    public override fun getValue(thisRef: Any?, property: KProperty<*>): T {
        return value
    }

    public override fun setValue(thisRef: Any?, property: KProperty<*>, value: T) {
        val oldValue = this.value
        if (!beforeChange(property, oldValue, value)) {
            return
        }
        this.value = value
        afterChange(property, oldValue, value)
    }
}
```

개발자가 정의한 람다식에 의해 `beforeChange`, `afterChange` 가 재정의 되는 구조이다.  

### 사용자 대리자  

`ReadWriteProperty` 혹은 `ReadOnlyProperty` 를 구현하는 클래스로 사용자 대리자 생성이 가능하다.  

```kotlin
object myReadDelegate : ReadOnlyProperty<Example, String> {
    override fun getValue(thisRef: Example, property: KProperty<*>): String {
        TODO("Not yet implemented")
    }
}

object myReadWriteDelegate : ReadWriteProperty<Example, String> {
    override fun getValue(thisRef: Example, property: KProperty<*>): String {
        TODO("Not yet implemented")
    }

    override fun setValue(thisRef: Example, property: KProperty<*>, value: String) {
        TODO("Not yet implemented")
    }
}

class Example {
    val readOnly: String by myReadDelegate
    var readWrite: String by myReadWriteDelegate
}


fun main() {
    val e = Example()
    println(e.readOnly)
    e.readWrite = "NEW"
}
```

> 사실 상속까진 필요없고 `getValue`, `setValue` 만 구현해도 상관없다.  

## scope 함수 - apply, also, with, let, run

객체 컨텍스트 안에서 코드 블록을 실행할 목적으로 만든 함수중 **영역(scope)함수**에 대해 설명  

아래 4가지 함수는 **모든 제너릭 타입 T 에 존재하는 확장함수**  

```kotlin
inline fun <T> T.apply(block: T.() -> Unit): T
inline fun <T> T.also( block: (T) -> Unit ): T
inline fun <T, R> T.let( block: (T) -> R ): R
inline fun <T, R> T.run(block: T.() -> R): R
```

```kotlin
fun <T, R> with(receiver: T, block: T.() -> R): R
```

> 내부 `block` 파라미터의 함수타입은 `Function literals with receiver` 함수타입  

### apply

생성자 인자만으로는 할 수 없는 초기화 작업 진행 가능  

`T.() -> Unit` 를 보면 `T` 를 `receiver` 로 받아 매개변수없이 `Unit` 을 반환한다(반환값이 따로없음).  

```kotlin
data class Person(
    var name: String = "kouzie",
    var age: Int = 0
)

fun main() {
    val person = Person().apply {
        this.name = "test"
        this.age = 29
    }
    println(person) // Person(name=test, age=29)
}
```

### also

코드 흐름을 방해하지 않고 메시지를 출력하거나 다른 부수 효과를 생성가능  

`(T) -> Unit` 을 보면 일반적인 `T` 의 람다함수

```kotlin
fun main() {
    val person = Person().apply {
        this.name = "test"
        this.age = 29
    }
        .also { ps -> println(ps) } // Person(name=test, age=29)
        .also { println(it) } // Person(name=test, age=29)
}
```

`also` 와 `apply` 구현을 보면 사실상 `this` 키워드를 사용할 수 있냐 없냐의 의미론적 차이가 있는듯 함.  

```kotlin
public inline fun <T> T.apply(block: T.() -> Unit): T {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
    block()
    return this
}

public inline fun <T> T.also(block: (T) -> Unit): T {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
    block(this)
    return this
}
```

### let

`apply`, `also` 와 다르게 **반환값을 다른타입으로 지정 가능하다.**  

> 일반 변수에서 실행하는 컬렉션의 `map` 같은 함수  

```kotlin
public inline fun <T, R> T.let(block: (T) -> R): R {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
    return block(this)
}
```

```kotlin
var v1 = "hello".let { it.length }
var v2 = "hi".let { it.length }
println(v1) // 5
println(v2) // 2
```

아래와 같이 엘비스 연산자와 `let` 을 같이 사용해 `null` 조건을 분리하여 처리할 수 있다.  

```kotlin
fun processString(str: String?): String = str?.let {
    when {
        it.isEmpty() -> "Empty"
        it.isBlank() -> "Blank"
        else -> it.capitalize()
    }
} ?: "Null"
```
