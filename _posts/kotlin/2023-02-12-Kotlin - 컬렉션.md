---
title:  "Kotlin - 컬렉션!"

read_time: false
share: false
author_profile: false
toc: true
toc_sticky: true
# classes: wide

categories:
  - kotlin
---


## 컬렉션  

### Array - 배열  

`java` 에서 배열을 사용하고 싶다면 아래와 같이 배열의 크기를 선언후 `index` 를 통해 요소에 접근한다.  

```java
String[] strings = new String[4];
strings[0] = "hello";
strings[1] = "world";
```

`kotlin` 에서 배열을 사용할땐 `Array` 클래스를 와 `arrayOf` 팩토리 메서드를 통해 배열을 생성한다.  

일반적인 배열과 동일하게 선언과 동시에 배열의 크기가 정해지며 크기 변경이 불가능하다.  

```kotlin
val array = arrayOf(1, 2, "three")
array[0] = -1;
println(array.contentToString()) // [-1, 2, three]
```

`null` 로 채워진 배열 생성은 `arrayOfNulls` 메서드 사용

```kotlin
var nullArray: Array<String?> = arrayOfNulls<String>(5)
```

> `arrayOfNulls` 의 경우 요소의 타입 정의 필수

`Array` 를 생성하는 함수는 이 외에도 오토박싱, 언박싱 비용을 방지할 수 있도록  
기본 타입의 `Array` 를 생성하는 함수가 정의되어 있다.  

- `booleanArrayOf`  
- `byteArrayOf`  
- `shortArrayOf`  
- `charArrayOf`  
- `intArrayOf`  
- `longArrayOf`  
- `floatArrayOf`  
- `doubleArrayOf`  

#### Array 생성자  

```kotlin
public class Array<T> {
    public inline constructor(size: Int, init: (Int) -> T)
    ...
}
```

`Array` 의 기본생성자는 한개뿐인데 `Int` 타입 변수,  
반환값이 `Int` 인 람다함수를 두 인자로 받는다.  

아래처럼 사용가능  

```kotlin
var array = Array(5) {i -> (i * i).toString()}
println(array.contentToString()) // [0, 1, 4, 9, 16]
```

#### withIndex

```kotlin
val strings = arrayOf("this", "is", "an", "array", "of", "strings")
for ((index, value) in strings.withIndex()) {
    println("Index: $index, value: $value")
}
/*
Index: 0, value: this
Index: 1, value: is
Index: 2, value: an
Index: 3, value: array
Index: 4, value: of
Index: 5, value: strings
*/
```

### List

`kotlin` 의 `Array` 는 index 를 통해 내부요소를 자유롭게 변경 가능하다.  

```kotlin
val array: Array<Int> = arrayOf(1, 2, 3)
array[0] = -1
```

`List` 는 **내부 요소의 값을 변경 불가능한 컬렉션**으로 생성수 변경할 수 없음  

```kotlin
val list: List<Int> = listOf(1, 2, 3)
// list[0] = -1
// 에러 발생, set 명령도 없음
```

### ArrayList, MutableList

내부 요소를 변경하고싶다면 `ArrayList` 컬렉션을 사용  

```kotlin
var arrayList: ArrayList<Int> = arrayListOf(1, 2, 3)
arrayList[0] = -1
arrayList.add(4)
println(arrayList) // [-1, 2, 3, 4]
```

#### fold  

배열 형태의 컬렉션을 순회하면서 연산하고 싶을때 사용  

```kotlin
public inline fun <R> IntArray.fold(initial: R, operation: (acc: R, Int) -> R): R { ... }
```

초기값과 순회하면서 처리할 함수를 지정한다.  

```kotlin
fun main() {
    val nums = intArrayOf(1, 2, 3, 4, 5)
    val result = nums.fold(0) { acc, i -> acc + i }
    println(result) // 15
}
```

#### reduce  

`fold` 와 동일한 기능을 수행하지만 초기값을 배열의 첫번째 값으로 사용한다.  

```kotlin
public inline fun IntArray.reduce(operation: (acc: Int, Int) -> Int): Int { ... }
```

```kotlin
fun main() {
    val nums = intArrayOf(1, 2, 3, 4, 5)
    val result = nums.reduce() { acc, i -> acc + i }
    println(result) // 15
}
```

### Set  

`kotlin` 에서 제공하는 각종 컬렉션 관련 함수 `setOf`

```kotlin
var numSet = setOf(3, 1, 4, 1, 5, 9)
println(numSet) // [3, 1, 4, 5, 9]
```



### Map & Pair

`mapOf` 및 `Pair` 클래스 를 알아보자.  

> `Pair` 는 `java` 의 `entry` 와 비슷  


```kotlin
val p1: Pair<String, Int> = "a" to 1
val p2: Pair<String, Int> = Pair("b", 2)
val m = mapOf(p1, p2, "c" to 3)
println(m) // {a=1, b=2, c=3}
```

> `"a" to 1` 또한 이미 내부적으로 `infix` 함수가 정의되어 있기 때문에 가능한 문법이다.  

```kotlin
infix fun <A, B> A.to(that: B): Pair<A, B> {
    return Pair(this, that)
}
```

#### associate  

컬렉션간의 결합을 통해 `Map` 컬렉션 생성이 가능하다.  

```kotlin
var keys: CharRange = 'a'..'f'
val map: Map<Char, String> = keys.associate { it to it.toString().repeat(5).capitalize() }
println(map) // {a=Aaaaa, b=Bbbbb, c=Ccccc, d=Ddddd, e=Eeeee, f=Fffff}
```

```kotlin
var keys: CharRange = 'a'..'f'
val map: Map<Char, Pair<Char, String>> = keys.associateWith { it to it.toString().repeat(5).capitalize() }
println(map) // {a=(a, Aaaaa), b=(b, Bbbbb), c=(c, Ccccc), d=(d, Ddddd), e=(e, Eeeee), f=(f, Fffff)}
```

### Mutable 컬렉션  

지금까지 생성한 `arrayOf`, `mapOf`, `setOf` 등 컬렉션 생성함수로 생성한 클래스들은 모두 `가변(mutable)` 가능한 컬렉션 들이다.  

예로 `mapOf` 메서드 내부를 보면 아래와 같은데 `LinkHashMap` 은 `MutableMap` 의 구현체이다.  

```kotlin
public fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> =
    if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()

...

expect class LinkedHashMap<K, V> : MutableMap<K, V> {
    constructor()
    ...
}
```

`Mutable` 으로부터 읽기 전용 클래스를 가져오려면 `toSet`, `toList` 메서드를 사용한다.  

```kotlin
val ms = mutableSetOf(1, 2, 3)
var s: Set<Int> = ms.toSet();
val ml = mutableListOf(1, 2, 3)
var l: List<Int> = ml.toList()
```

## 스트림 메서드

`java` 에서 각종 스트림 함수를 통해 컬렉션을 다루었던 것 처럼  
`kotlin` 에서도 웬만한 메서드를 모두 제공한다.  

### chucked, windowed

컬렉션을 아래와 같이 **윈도우 단위**로 컬렉션을 분할하는 기능  

```kotlin
val range: IntRange = 0..10
val chucked: List<List<Int>> = range.chunked(3)
println(chucked) // [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10]]
```

사실 `chucked` 는 `windowed` 함수를 추상화 한 것  

```kotlin
val range: IntRange = 0..10
// size, step, partialWindows
val chucked: List<List<Int>> = range.windowed(3, 3, true)
println(chucked) // [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10]]
```

`size`: 각 윈도우 원소 수
`step`: 전진할 윈도우 개수 (default 1)
`partialWindows`: size 로 나누어 떨어지지 않을때 버림 여부 (deafult false 버림)

### 디스트럭쳐링  

`List` 에 기본적으로 `component1` ~ `component5` 함수가 정의되어 있는데  
아래 사용처럼 디스트럭처링 문법 사용이 가능하다.  

```kotlin
val range: CharRange = 'a'..'g'
val (a, b, c, d, e) = range.toList();
println("$a $b $c $d $e") // a b c d e
// val (a1, b1, c1, d1, e1, f1) = range.toList(); 에러 발생 component6 가 없기 때문
```

`Pair` 클래스 디스트럭처링 문법도 제공한다.  

```kotlin
val p1: Pair<String, Int> = "a" to 1
val (a, b) = p1
println("${a}, ${b}") // a, 1
```

### filter, map, joinToString

```kotlin
data class Product(
    val name: String,
    val price: Double,
    val onSale: Boolean = false
)

fun generateList(): List<Product> {
    val product1 = Product("product1", 2000.0, true)
    val product2 = Product("product2", 1000.0, false)
    val product3 = Product("product3", 3000.0, true)
    return listOf(product1, product2, product3)
}
```

위 `Product` 클래스로 사용법 확인  

```kotlin
fun main() {
    var products: List<Product> = generateList();
    var result: String = products
        .filter { it.onSale }
        .map { it.name }
        .joinToString(separator = ", ")
    println(result) // product1, product3
}
```

### ifEmpty, ifBlank

```kotlin
fun generateList(): List<Product> {
    val product1 = Product("product1", 2000.0, onSale = false)
    val product2 = Product("product2", 1000.0, onSale = false)
    val product3 = Product("product3", 3000.0, onSale = false)
    return listOf(product1, product2, product3)
}

fun namesOfProductsOnSale1(products: List<Product>) =
    products.filter { it.onSale }
        .map { it.name }
        .ifEmpty { listOf("none") }
        .joinToString(separator = ", ")

fun namesOfProductsOnSale2(products: List<Product>) =
    products.filter { it.onSale }
        .map { it.name }
        .joinToString(separator = ", ")
        .ifEmpty { "none" }

fun main() {
    var products: List<Product> = generateList();
    var result1 = namesOfProductsOnSale1(products)
    var result2 = namesOfProductsOnSale2(products)
    println(result1) // none
    println(result2) // none
}
```

### sortedWith, compareBy

요소 정렬을 위한 스트림 메서드  

```kotlin
fun main() {
    var products: List<Product> = generateList();
    products = products.sortedWith(compareBy({ it.price }, { it.name }))
    println(products) 
    // [Product(name=product2, price=1000.0, onSale=false), Product(name=product1, price=2000.0, onSale=true), Product(name=product3, price=3000.0, onSale=true)]
}
```

### filterIsInstance, filterIsInstanceTo

`List<Any>` 형식의 컬렉션을 필터링할 때에는 아래와 같은 문제가 발생할 수 있다.  

```kotlin
fun main() {
    val list: List<Any> = listOf("a", LocalDate.now(), 3, 1, 4, "b")
    val strings: List<Any> = list.filter { it is String }
    for (str in strings) {
        str.length // error, Any 타입에는 length 가 없음
    }
}
```

`filterIsInstance` 를 사용해 해당 요소만 뽑아내어 타입을 지정할 수 있다.  

```kotlin
val list: List<Any> = listOf("a", LocalDate.now(), 3, 1, 4, "b")
val all: List<Any> = list.filterIsInstance<Any>()
val strings: List<String> = list.filterIsInstance<String>()
val ints: List<Int> = list.filterIsInstance<Int>()
val dates: List<LocalDate> = list.filterIsInstance(LocalDate::class.java)
```

사실 `filterIsInstance` 은 `filterIsInstanceTo` 함수를 구현한 함수이며  
`filterIsInstanceTo` 를 사용하면 어떤 인스턴스에 해당 요소를 집어넣을지 지정 가능하다.  

```kotlin
val list: List<Any> = listOf("a", LocalDate.now(), 3, 1, 4, "b")
val all: MutableList<Any> = list.filterIsInstanceTo(mutableListOf())
val strings: MutableList<String> = list.filterIsInstanceTo(mutableListOf<String>())
val ints: MutableList<Int> = list.filterIsInstanceTo(mutableListOf<Int>())
val dates: MutableList<LocalDate> = list.filterIsInstanceTo(mutableListOf<LocalDate>())
```

## Iterable 클래스  

기본적으로 컬렉션은 순회가능한 `Iterable` 클래스이다.  

> `Iterable` 인터페이스 구현  

```kotlin
data class Player(val name: String)

class Team(
    val name: String,
    val players: MutableList<Player> = mutableListOf()
) : Iterable<Player> {
    fun addPlayers(vararg people: Player) = players.addAll(people)

    override fun iterator(): Iterator<Player> = players.iterator()
}

fun main() {
    val team = Team("Warriors")
    team.addPlayers(
        Player("Curry"),
        Player("Thompson")
    )

    for (player in team) {
        println(player)
        // Player(name=Curry)
        // Player(name=Thompson)
    }
}
```

다음과 같이 `operator` 키워드로 `iterator` 함수만 재정의하면 Iterator 구현 없이 `for...each` 문을 실행할 수 있다.  

```kotlin
class Team(
    val name: String,
    val players: MutableList<Player> = mutableListOf()
) {
    fun addPlayers(vararg people: Player) = players.addAll(people)
}

operator fun Team.iterator(): Iterator<Player> = players.iterator()
```

## 시퀀스

`kotlin` 시퀀스는 `java stream` 과 비슷한 기능  

`kotlin` 시퀀스는 의 경우 컬렉션에 기본적인 확장함수들이 정의되어 있지만, 해당 함수들은 즉시 처리되어 모든원소에 접근한다.  
이런점 때문에 `first` 와 같은 함수를 사용할 경우 비효율적으로 구성할 수 있다.  

```kotlin
var result1: Int = (100..200).map { it * 2 }.filter { println("filter1: $it"); it % 3 == 0 }.first();
/* 
filter1: 200
filter1: 201
... 201 ~ 399 까지 출력
filter1: 400 
*/
var result2: Int = (100..200).map { it * 2 }.first { println("filter2: $it"); it % 3 == 0 };
/* 
filter2: 200
filter2: 202
filter2: 204 
*/

println(result1) // 204
println(result2) // 204
```

`first` 에 조건을 부여하지 못할경우 `asSequence()` 함수를 사용하면 동일하게 효율적으로 빠져나올 수 있다.  

```kotlin
var result1: Int = (100..200).asSequence().map { it * 2 }.filter { println("filter1: $it"); it % 3 == 0 }.first();
println(result1)
/*
filter1: 200
filter1: 202
filter1: 204
204
*/
```

시퀀스 연산은 **중간연산**과 **최종연산**으로 나뉘며 최종연산까지 작성하여야 전체파이프라인이 구성되며 시퀀스가 동작한다.  

`map`, `filter` 와 같은것을 중간연산,  
`first`, `toList` 같은함수를 최종연산이라 한다.  

> 시퀀스 최종값이 비어있을경우 `first` 는 예외를 발생함으로 `firstOrNull` 사용을 추천

### 시퀀스 생성 - sequenceOf, asSequence, generateSequence

원소는 `sequenceOf`, `iterable` 객체는 `asSequence`  

```kotlin
val numSequence1 = sequenceOf(3, 1, 4, 1, 5, 9)
val numSequence2 = listOf(3, 1, 4, 1, 5, 9).asSequence()
```

`generateSequence` 는 초기값과 다음값을 생성할 함수를 인자로 받아 시퀀스를 생성한다.  
`nextFunction` 으로 전달한 함수에서 값을 반환하면 무한시퀀스가 생성된다.  

> 내부적으로 재귀형식으로 함수가 구성됨

```kotlin
public fun <T : Any> generateSequence(seed: T?, nextFunction: (T) -> T?): Sequence<T> =
    if (seed == null)
        EmptySequence
    else
        GeneratorSequence({ seed }, nextFunction)
```

단순이 1씩 증가시키는 함수를 `nextFunction` 으로 지정, `take` 최종연산으로 값을 출력한다.  

```kotlin
val buffer = StringBuffer();
var joinResult = generateSequence(1) { it + 1 }
    .take(10)
    .joinTo(buffer, ",")
println(joinResult) // 1,2,3,4,5,6,7,8,9,10
```

아래처럼 탈출조건을 삽입해도 된다.  

```kotlin
val buffer = StringBuffer();
generateSequence(1) { if (it > 10) null else it + 1 }
    .joinTo(buffer, ",")
println(buffer) // 1,2,3,4,5,6,7,8,9,10,11
```

탈출한다 해도 해당요소까지 시퀀스에 포함됨으로 아래처럼 직관적인 `takeWhile` 문을 사용하는것을 권장

```kotlin
val buffer = StringBuffer();
generateSequence(1) { it + 1 }
    .takeWhile { it < 10 }
    .joinTo(buffer, ",")
println(buffer) // 1,2,3,4,5,6,7,8,9
```

### 시퀀스 생성 - sequence, yield

`sequence` 와 `yield` 함수를 사용해  시퀀스를 생성가능하다.  

```kotlin
public fun <T> sequence(@BuilderInference block: suspend SequenceScope<T>.() -> Unit): Sequence<T> = Sequence { iterator(block) }
```

```kotlin
fun fibonacciSequence() = sequence {
    var terms = Pair(0, 1)
    while (true) {
        yield(terms.first) // stop & return
        terms = terms.second to terms.first + terms.second
    }
}

fun main() {
    val fibs = fibonacciSequence()
        .take(10)
        .toList()
    println(fibs) // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
}
```

다른언어의 `yield` 와 마찬가지로 `stop interrupt`를 발생시키며 값을 반환하는 함수  
해당 `yield` 는 `SequenceScope` 내부에 정의된 함수로 아래 정의 참고  

```kotlin
public abstract class SequenceScope<in T> internal constructor() {
    public abstract suspend fun yield(value: T)
    public abstract suspend fun yieldAll(iterator: Iterator<T>)
}
```

## rangeTo

범위클래스를 상속하면 `..` 키워드를 사용해 범위타입 클래스인 `ClosedRange` 을 사용할 수 있다.  

```kotlin
val range1: CharRange = 'a'..'f'
val range2: CharRange = 'a'.rangeTo('f')
```

범위클래스로 `CharRange` 외에도 `IntRange`, `LongRange` 등이 있으며 모두 `ClosedRange` 를 구현하고 있다.  

`ClosedRange` 의 `contains` 메서드를 보면 `infix` 연산자로 비교문만 정의하면  
아래와 같이 in 키워드를 사용할 수 있다.  

```kotlin
public interface ClosedRange<T: Comparable<T>> {
    // The minimum value in the range.
    public val start: T
    // The maximum value in the range (inclusive).
    public val endInclusive: T
    // Checks whether the specified [value] belongs to the range.
    public operator fun contains(value: T): Boolean = value >= start && value <= endInclusive
    // Checks whether the range is empty.
    public fun isEmpty(): Boolean = start > endInclusive
}
```

```kotlin
val startDate = LocalDate.now()
val midDate = startDate.plusDays(3)
val endDate = startDate.plusDays(5)
val overDate = startDate.plusDays(6)

val dateRange: ClosedRange<LocalDate> = startDate..endDate
println(startDate in dateRange) // true
println(midDate in dateRange) // true
println(endDate in dateRange) // true
println(overDate in dateRange) // false
```

### Progression(수열, 연속)

`ClosedRange<LocalDate>` 타입이 수열처럼 연속된 값의 나열은 아니기 때문에 `for...each` 사용은 불가능하다.  

```kotlin
public class CharRange(start: Char, endInclusive: Char) : CharProgression(start, endInclusive, 1), ClosedRange<Char> {...}
public class IntRange(start : Int, endInclusive: Int) : IntProgression(start, endInclusive, 1), ClosedRange<Int> { ... }
public class LongRange(start: Long, endInclusive: Long) : LongProgression(start, endInclusive, 1), ClosedRange<Long> { ... }
```

`CharRange`, `IntRange`, `LongRange` 처럼 `Iterable` 인터페이스를 구현한 `CharProgression`, `IntProgression`, `LongProgression` 과 같은 클래스를 상속받아야 한다.  

```kotlin
class LocalDateProgression(
    override val start: LocalDate,
    override val endInclusive: LocalDate,
    val step: Long = 1 // 1day
) : Iterable<LocalDate>, ClosedRange<LocalDate> {

    override fun iterator(): Iterator<LocalDate> = LocalDateProgressionIterator(start, endInclusive, step)

    infix fun step(days: Long) = LocalDateProgression(start, endInclusive, days)

    internal class LocalDateProgressionIterator(
        var current: LocalDate,
        val endInclusive: LocalDate,
        val step: Long
    ) : Iterator<LocalDate> {

        override fun hasNext() = current <= endInclusive

        override fun next(): LocalDate {
            val next = current
            current = current.plusDays(step)
            return next
        }
    }
}

operator fun LocalDate.rangeTo(other: LocalDate) = LocalDateProgression(this, other, 1)

fun main() {

    val startDate = LocalDate.now()
    val midDate = startDate.plusDays(3)
    val endDate = startDate.plusDays(5)
    val overDate = startDate.plusDays(6)

    val dateRange = startDate..endDate
    for (date in dateRange) {
        println(date)
        // 2023-02-20
        // 2023-02-21
        // 2023-02-22
        // 2023-02-23
        // 2023-02-24
        // 2023-02-25
    }
}
```

