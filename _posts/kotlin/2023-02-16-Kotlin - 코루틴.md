---
title:  "Kotlin - coroutine!"

read_time: false
share: false
author_profile: false
toc: true
toc_sticky: true
# classes: wide

categories:
  - kotlin
---

## coroutine

> `coroutine`: `Co(together)+routine` 의 합성어, 상호 연계 프로그램을 일컫는다  
> 다른 언어들에도 많은 라이브러리들이 해당 기능을 지원한다.  

코틀린에서 가장 인기 있는 기능으로 `kotlin coroutine` 이 있음.  

다른언어에서 지원하는 콜백메서드, `java` 의 `reactive stream` 과 비교했을 때 좀더 쉽게 동시적 코드를 작성가능하다.  

`reactive stream` 의 구현체인 `RxJava`, `Reactor` 와 다르게 **협력형 멀티태스킹** 개념이 있으며  
스레드 변경없이 동시적 코드를 지원한다.  

> 내부적으로 yield, suspend 키워드를 사용하지 않을까 예상...

```java
implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.5")
```

### suspend 함수 (일시중단함수)

`java` 의 `Thread.sleep` 과 다르게 스레드를 블락하지 않는다.  
시작하고 멈추고 다시 시작할 수 있는 함수, **비동기 실행을 위한 중단 지점의 의미하는 키워드**.  

`suspend` 함수를 맞닥뜨리면 스레드는 작업이 완료될 동안 다른작업을 수행한다  
`kotlin` 에서 제공하는 대표적인 `suspend` 함수로 `delay` 가 있음  

> `suspend` 함수는 반드시 코루틴 내부 혹은 다른 `suspend` 함수에서 수행되어야 한다.  

스레드 하나짜리 스레드풀을 사용해 테스트해본 결과를 비교해보면 아래와 같다.  

```kotlin
fun noSuspendReturnOne(): Int {
    println("noSuspendReturnOne ${Thread.currentThread().name}")
    Thread.sleep(3000L)
    return 1
}

fun noSuspendReturnTwo(): Int {
    println("noSuspendReturnTwo ${Thread.currentThread().name}")
    Thread.sleep(1000L)
    return 2
}

fun main() {
    val singleThreadDispatcher = newSingleThreadContext("Single Thread ThreadPool")
    var time = measureTimeMillis {
        runBlocking(singleThreadDispatcher) {
            var result1 = async { noSuspendReturnOne() }
            // 병렬로 2개 함수 실행
            var result2 = async { noSuspendReturnTwo() }
            println(result1.await() + result2.await())
        }
    }
    println(time)
}
/*
noSuspendReturnOne Single Thread ThreadPool
noSuspendReturnTwo Single Thread ThreadPool
3
4039
*/
```

`Thread.sleep` 함수를 사용했고 예상대로 총 4초가 소요된다.  

해당 함수를 `suspend + delay` 조합으로 변경  

```kotlin
suspend fun suspendReturnOne(): Int {
    println("suspendReturnOne ${Thread.currentThread().name}")
    delay(3000L)
    return 1
}

suspend fun suspendReturnTwo(): Int {
    println("suspendReturnTwo ${Thread.currentThread().name}")
    delay(1000L)
    return 2
}

fun main() {
    val singleThreadDispatcher = newSingleThreadContext("Single Thread ThreadPool")
    var time = measureTimeMillis {
        runBlocking(singleThreadDispatcher) {
            var result1 = async { suspendReturnOne() }
            // 병렬로 2개 함수 실행
            var result2 = async { suspendReturnTwo() }
            println(result1.await() + result2.await())
        }
    }
    println(time)
}
/*
suspendReturnOne Single Thread ThreadPool
suspendReturnTwo Single Thread ThreadPool
3
3036
*/
```

비동기 실행시점인 suspend 키워드를 사용해 함수를 정의하였고 delay 를 만나는 순간 바로 다른 작업을 하러가기 때문에 총 3초를 소요하게된다.  

## coroutine 생성  

`kotlin coroutine` 에는 `scope`, `context`, `builder`, `dispatcher` 등의 동시성 프로그래밍 개념이 존재

`kotlin corutine` 빌더함수는 아래 3가지

- `runBlokcing`  
- `coroutineScope`  
- `launch`  
- `async`  

`launch`, `async` 는 `CoroutineScope` 의 확장함수라 단독으로 사용할 수 없기에  
실제로 `kotlin corutine` 를 생성할 수 있는 함수는 `runBlokcing`, `coroutineScope` 2가지  

정의된 영역 안에 코루틴을 사용해야 한다는 코루틴 사용 기본 원칙 중 하나다.

> 디버깅시 `-Dkotlinx.coroutines.debug` 플래그를 사용해서 실행하면 추가 정보를 얻을 수 있음  

### runBlocking

`runBlocking` 은 **검증 또는 테스트에 유용**, 현재 스레드를 모든 내부 `corutine` 이 종료될 때 까지 블록한다.  

메인스레드를 블록하기 때문에 실제 운용시에는 사용하지 않는다.  

```kotlin
public fun <T> runBlocking(
    context: CoroutineContext = EmptyCoroutineContext, 
    block: suspend CoroutineScope.() -> T
): T { ... }
```

```kotlin
fun test1() {
    println("Before creating coroutine")
    runBlocking {
        print("Hello, ")
        delay(4000L)
        println("World!")
    }
    println("After coroutine is finished")
}
```

`Hello,` 문자열이 출력되고 4초뒤에 이후 문자열들이 출력된다  

### coroutineScope

`coroutineScope` 역시 `runBlocking` 과 마찬가지로 종료 전 모든 `coroutine` 이 완료될 때까지 기다리는 함수이지만 `suspend` 함수이다.  

스레드를 블락시키진 않음으로 `runBlocking` 보다 효율적이다.  

```kotlin
public suspend fun <R> coroutineScope(block: suspend CoroutineScope.() -> R): R { ... }
```

아래와 같이 `delay` 함수에도 바로 다음코드를 실행하다보니 순서대로 출력되지 않는다.  

### CoroutineScope.launch

`CoroutineScope.launch` 는 반환값을 받을 필요가 없을경우 사용  
독립된 프로세스를 실행하고 도중에 취소가능한 `Job` 인스턴스를 반환한다  

`CoroutineScope` 의 확장함수로 `CoroutineScope` 이 사용 가능한 경우에만 사용할 수 있다  

```kotlin
public fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> Unit
): Job
```

```kotlin
fun main() {
    println("Before runBlocking")
    runBlocking {
        println("Before launch")
        launch {
            delay(2000L)
            println("Hello, World!")
        }
        println("After launch")
    }
    println("After runBlocking")
}
/* 
Before runBlocking
Before launch
After launch
Hello, World!
After runBlocking
*/
```

`After launch` 가 먼저 찍힌것을 확인

### CoroutineScope.async

`async` 는 값을 리턴해야 하는 경우에 사용  
`launch` 와 마찬가지로 `CoroutineScope` 의 확장함수  

```kotlin
public fun <T> CoroutineScope.async(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> T
): Deferred<T>
```

`Deferred` 인스턴스를 반환하며 `java8` 의 `Future` 와 비슷한 클래스  

```kotlin
suspend fun add(x: Int, y: Int): Int {
    delay(Random.nextLong(1000L))
    return x + y
}

suspend fun main() {
    var time = measureTimeMillis {
        coroutineScope {
            val firstSum: Deferred<Int> = async {
                println(Thread.currentThread().name)
                add(2, 2)
            }
            val secondSum: Deferred<Int> = async {
                println(Thread.currentThread().name)
                add(3, 4)
            }
            println("Awaiting concurrent sums...")
            val total = firstSum.await() + secondSum.await()
            println("Total is $total")
        }
    }
    println("time=$time") // time=1008
}
/*
DefaultDispatcher-worker-1
Awaiting concurrent sums...
DefaultDispatcher-worker-2
Total is 11
time=1008
*/
```

### withContext

`async/await` 조합을 `withContext` 로 변경가능하다.  
> `async/await` 을 연속으로 사용하는 코드는 `withContext` 로 변경하도록 권장함  

```kotlin
public suspend fun <T> withContext(
    context: CoroutineContext,
    block: suspend CoroutineScope.() -> T
): T
```

`async` 에서 사용했던 코드를 `withContext` 로 변경  

```kotlin
suspend fun main() {
    var time = measureTimeMillis {
         runBlocking {
            val firstSum: Int = withContext(Dispatchers.IO) {
                println(Thread.currentThread().name)
                add(2, 2)
            }
            val secondSum: Int = withContext(Dispatchers.IO) {
                println(Thread.currentThread().name)
                add(3, 4)
            }
            println("Awaiting concurrent sums...")
            val total = firstSum + secondSum
            println("Total is $total")
        }
    }
    println("time=$time") // time=1008
}
/* 
DefaultDispatcher-worker-1
DefaultDispatcher-worker-1
Awaiting concurrent sums...
Total is 11
time=909
*/
```

### coroutine Job 

`launch`, `withTimeout`, `withTimeoutOrNull` 등의 함수가 리턴하는 `Job` 클래스를 사용해 실행중인 `coroutine` 을 정지하거나 취소할 수 있다.  

## CoroutineContext 스레드풀

`coroutine` 이 어떤 스레드 풀에서 실행될지 결정한다.  
`coroutine` 표준 라이브러리에는 아래 내장 `CoroutineDispatcher` 클래스가 포함되어 있음  

- `Dispatchers.Default`  
- `Dispatchers.IO`  
- `Dispatchers.Unconfined`  

필요에 따라 `launch`, `async`, `withContext` 함수의 인자로 추가하여 사용한다.  

만약 커스텀한 `Dispatcher`(스레드풀)를 사용해야 한다면 `ExecutorService` 로부터 스레드풀을 직접 만들어 사용가능하다.  

```kotlin
val dispatcher: ExecutorCoroutineDispatcher = Executors.newFixedThreadPool(10)
    .asCoroutineDispatcher()
...
...
dispatcher.close()
```

`close` 함수를 호출하지 않으면 메인함수가 종료되지 않음으로 호출 필수

`ExecutorService` 를 패키징한 `coroutine` 표준 라이브러리 함수도 있음  

```kotlin
val singleThreadDispatcher = newSingleThreadContext("Single Thread ThreadPool")
val multiThreadDispatcher = newFixedThreadPoolContext(10, "Multi Thread ThreadTool")
```
