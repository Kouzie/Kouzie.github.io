---
title:  "Kotlin - start!"

read_time: false
share: false
author_profile: false
toc: true
toc_sticky: true
# classes: wide

categories:
  - kotlin
---


## 개요

> <https://kotlinlang.org/docs/command-line.html#install-the-compiler>

```sh
brew install kotlin
kotlin -version
Kotlin version 1.6.10-release-923 (JRE 11.0.10+8-jvmci-21.0-b06)
```

```sh
vi hello.kr
```

```kotlin
fun main() {
    println("Hello, World!")
}
```

```sh
kotlinc-jvm hello.kt
kotlin HelloKt
Hello, World!
```

`kotlinc-jvm` 대신에 `kotlinc`(Kotlin compiler) 사용 가능  

```sh
kotlinc hello.kt -include-runtime -d hello.jar
java -jar hello.jar

Hello, World!
```

```sh
kotlinc

Welcome to Kotlin version 1.6.10 (JRE 11.0.10+8-jvmci-21.0-b06)
Type :help for help, :quit for quit
>>> println("hello world")
hello world
>>> var name = "test"
>>> println("hello $name")
hello test
>>> :help
Available commands:
:help                   show this help
:quit                   exit the interpreter
:dump bytecode          dump classes to terminal
:load <file>            load script from specified file
>>> :quit
```

### kotlin 스크립트

아래처럼 `main` 이 없는 코드를 나열하고 JVM 상에서 스크립트 형식으로 실행  

```kotlin
import java.time.*

val instant = Instant.now()
val southPole = instant.atZone(ZoneId.of("Antarctica/South_Pole"))
val dst = southPole.zone.rules.isDaylightSavings(instant)
println("It is ${southPole.toLocalTime()} (UTC${southPole.offset}) at the south Pole")
println("The south Pole ${if (dst) "is" else "is not"} on Daylight Savings Time")
```


```sh
kotlinc -script southpole.kts

It is 20:50:43.486781 (UTC+13:00) at the south Pole
The south Pole is on Daylight Savings Time
```

## 연산자

### 동등 연산자(====)

`equals`, `hasCode`, `toString`, `copy`(얕은복사) 가 미리 재정의되는 `data class` 를 사용하여 동등 비교  

```kotlin
data class Product(
    val name: String,
    val price: Double,
    val onSale: Boolean = false
)

fun main() {
    val p1 = Product("product1", 2000.0, true)
    val p2 = p1.copy(price = 2000.0)
    println(p1.equals(p2)) // true
    println(p1 === p2) // false
}
```

`====` 연산자는 참조가 같은지를 확인한다.  

### 삼항연산자

`kotlin` 에는 `?, :` 를 사용한 삼항연산자가 없고 `if, else` 로 구성할 수 있다.  

```kotlin
fun main() {
    val num = 11
    val result1 = if (num > 10) "it's true" else "it's false"
    val result2 = if (num > 10) {
        5 + 5
    } else {
        100 + 100
    }
    println(result1) // it's true
    println(result2) // 10    
}
```

### when  

`switch` 에 해당하는 연산자  

```kotlin
fun checkName(score: Int) {
    when(score) {
        0 -> println("zero")
        1 -> println("one")
        2,3 -> println("two or three")
        else -> println("unknown") // else 생략해도 컴파일 가능
    }
}
```

다른언어의 `swtich` 와 다르게 단순 코드블럭을 실행하는 것이 아닌 **값을 반환할 수 있다**(단 `else` 를 강요)

```kotlin
fun getName(score: Int): String {
    val result: String = when (score) {
        0 -> "zero"
        1 -> "one"
        2, 3 -> "two or three"
        else -> "unknown"
    }
    return result
}
```

`in` 키워드로 범위를 지정할 수 있다.  

```kotlin
fun getName(score: Int): String {
    val result: String = when (score) {
        in 0..10 -> "zero"
        in 10..90 -> "one"
        in 90..100 -> "two or three"
        else -> "unknown"
    }
    return result
}
```

위 `if, else` 삼항연산 대신 확장해서 사용가능하다.  

### for  

```kotlin
val list = listOf("a", "b", "c", "d")
for ((index, name) in list.withIndex()) {
    println("${index}:${name}")
    // 0:a
    // 1:b
    // 2:c
    // 3:d
}

val array = arrayOf(1, 2, 3)
for (i in array) {
    print(i) // 123
}
for (i in 1..10 step 2) {
    println(i) // 13579
}
for (i in 10 downTo 1) {
    println(i) // 10987654321
}
for (i in 1 until 10) { // 10 은 포함하지 않음
    println(i) // 123456789
}
```

### val, var 변수선언

`val`은 **변경할 수 없는 속성(immutable)**   
할당된 이후 값을 변경하게 되면 컴파일 에러가 발생, 변수를 생성시 반드시 **타입을 명시** 해줘야 한다.  

> `java` 에서는 `final`과 같다  

```kotlin
val num1 = 42
val num2: Int = 45
val num3: Int
// val num4 에러 발생, 타입 지정 필수
// num1 = 1; 재정의 에러 발생
```


`var`은 **변경할 수 있는 속성(mutable)**  
초기화 후 값을 변경이 가능하다.

> 일반적인 변수선언 방식  

### nullable(?) 연산자

코틀린은 기본적으로 필드에 `null` 사용이 불가능한데 `?` nullable 키워드를 사용하면 필드에 null 값 지정이 가능하다.  

```kotlin
class Person(
    val first: String,
    val middle: String?,
    val last: String
)
```

`String?` 과 `String` 은 `null` 허용 여부만 결정하는 것 처럼 보이지만  
컴파일시 아예 다른 기능의 변수처럼 동작한다.  

> `java` 의 `Optional` 과 유사

nullable 를 사용하면 아래와 같이 내부 필드나 함수를 호출할 때 `?` 를 체인형식으로 사용해야한다.  

```kotlin
class Person(
    val first: String,
    val middle: String?,
    val last: String
) {
    fun printMiddleNameLength() {
        // println(middle.length); nullable 에러 발생
        println(middle?.length) // null 출력
    }
}

fun main() {
    val p1 = Person("ko", null, "e")
    p1.printMiddleNameLength();
}
```

컴파일 단계에서 **null point 발생 가능한 경우를 원천 차단**한다.  

### smart cast

예를 들어 아래와 같이 `if` 문을 통해 해당 변수가 `null` 이 아님을 확인한다면 `if` 블럭 내부에선 `?` 가 없이 사용 가능하다.  


```kotlin
class Person(
    val first: String,
    val middle: String?,
    val last: String
) {
    fun printMiddleNameLength() {
        if (middle != null) // smart cast
            println(middle.length) // null 출력
    }
}

fun main() {
    val p1 = Person("ko", null, "e")
    p1.printMiddleNameLength();
}
```

`smart cast` 는 **컴파일 단계에서 null point 이슈가 해결되었다면 더이상 컴파일 에러를 발생시키지 않는다.**  

`p1.middle` 이 `null` 이 아님을 확신할수 있기에 `String?` 이 아닌 `String` 타입으로 인식한다.  

> 만약 `val` 이 아닌 `var` 로 선언할경우 언제든 `null` 로 재정의될 수 있다.  
> 따라서 `smart cast` 가 동작하지 않는다.  

### 단언 연산자(!!)

기존 `val` 로 정의되었던 필드를 `var` 로 변경

```kotlin
class Person(
    var first: String,
    var middle: String?,
    var last: String
)
```

`var` 로 정의된이상 `smart cast` 가 동작하지 않으며 `String?` 타입에서 벗어날 수 없다.  

하지만 단언연산자(`!!`) 를 사용하면 강제로 `String` 타입으로 변경가능하다.  
하지만 `NullPointException` 이 발생할 수 있다.  

```kotlin
class Person(
    var first: String,
    var middle: String?,
    var last: String
) {
    fun printMiddleNameLength() {
        println(middle!!.length) // KotlinNullPointerException 예외 발생
    }
}

fun main() {
    val p1 = Person("ko", null, "e")
    p1.printMiddleNameLength();
}
```

`val` 로 변수를 정의하고 `!!` 키워드를 피하는것을 권장한다.  

> 안전호출 연산자(`?.`) 를 통해 값을 겨저오는 것을 권장한다.  

### 엘비스 연산자(`?:`)

엘비스 연산자(`?:`) 역시 nullable 변수를 다루기 위한 연산자.  

> null 체크하는 삼항연산자와 같은 기능  

```kotlin
class Person(
    var first: String,
    var middle: String?,
    var last: String
) {
    fun printMiddleNameLength() {
        println(middle?.length ?: 0) // null 이라면 0 반환
    }
}

fun main() {
    val p1 = Person("ko", null, "e")
    p1.printMiddleNameLength();
}
```

`middle?.length` 은 `Int?` 를 반환하고 `null` 이 아니라면 정상적으로 `length` 를 반환

null 로 반환되었다면 엘비스 연산자(`?:`)를 통해 최종적으로 `0`을 반환한다.  

### 안전타입 변환연산자(`as?`)

마찬가지로 nullable 변수를 다루기 위한 연산자.  

```kotlin
val p1 = null
val p2 = p1 as? Person
```

변수 `p1` 의 타입을 `Person` 으로 변환  
안전타입 변환연산자(`as?`) 를 통해 `Person?` 으로 변환된다.  

사실상 아래 코드와 같다.  

```kotlin
val p2:Person? = p1 as? Person
```

### ?.let

**not null 일경우동작하는 코드블럭**를 정의한다 보면 된다.  

```kotlin
val email : String ?="test@test.com"
email?.let {
    println(it) // test@test.com
}
```

`?.let` 키워드로 `null` 이 아닐경우만 `let` 블록을 실행할 수 있도록 설정  
내부에선 `it` 키워드를 사용함  

### 타입변환  

`java` 와 다르게 `Int -> Long` 자동승격하지 않는다  
`toLong`, `toInt` 함수를 사용해야 한다.  

```kotlin
fun main() {
    val i: Int = 3
    // val l: Long = i // error 발생
    val l: Long = i.toLong();
}
```

아래와 같은 타입변환 함수 지원  

- `toByte`  
- `toChar`  
- `toShort`  
- `toInt`  
- `toLong`  
- `toFloat`  
- `toDouble`  


### 비트연산  

`Byte`, `Short`, `Int`, `Long` 에 한하여 진법출력 함수 `toString(radix: Int)` 가 있음  

```kotlin
fun main() {
    val i: Int = 10
    println(i.toString(2)) // 1010 
}
```

`and`, `or`, `xor`, `inv(not)` 비트 연산자를 제공한다.  

```kotlin
fun main() {
    var b1: Int = 0b0001_1111
    var b2: Int = 0b0001_0000
    println(b1 and b2)  // 16 
    println(b1 or b2)   // 31
    println(b1 xor b2)  // 15 
    println(b2.inv())   // -17
}
```

시프트연산으로 아래 3가지 제공  

- `shl`: `signed left shift`
- `shr`: `signed right shift`
- `ushr`: `unsigned left shift`

## 함수

`kotlin` 의 기본적인 함수정의는 아래와 같다.  

```kotlin
fun add(a: Int, b: Int): Int {
    return a + b
}

fun add2(a: Int, b: Int) = a + b
```

중괄호를 쓸경우 반환타입을 지정해야하고  
한줄로 끝날경우 중괄호와 반환타입 모두 생략해도 된다.  

### 람다함수

`java` 에서 람다는 함수형 인터페이스를 구현하는 형식으로 아래의 `lambda` 를 정의한다.  

```java
// java 의 lambda
BiConsumer<Integer, String> labmda = (Integer age, String name) -> {
    System.out.println("my name is " + name + "and my age is " + age);
};
```

`kotlin` 에서는 아래처럼 `입력Type`, `반환Type` 을 미리 작성하여 추론없이 바로 사용하거나  
`arg` 에 `입력Type` 을 정의하고 반환값은 자동으로 추론되도록 한다.  

```kotlin
// kotiln 의 lambda
val funName: (입력Type) -> (반환Type) = {arg -> body}   // 1
val funName = {arg: 입력Type -> body}                   // 2
```

> 개인적으로 2번 방법이 더 깔끔하고 가독성이 좋아보인다.  
> 람다함수는 한줄로 정의되는 경우가 많기에 반환Type 생략이 더 깔끔해 보임  

```kotlin
fun main() {
    val square1: (Int) -> (Int) = { number -> number * number } // 1
    val square2 = { number: Int -> number * number } // 2
    println(square1(2)) // 4
    println(square2(2)) // 4
}
```

`square1` 함수는 `입력Type`, `반환Type` 모두 정의  
`square2` 는 `입력Type` 만 정의하고 `반환Type`은 추론되도록 설정

람다를 파라미터로 받을땐 아래와 같이 작성한다.  

```kotlin
// 람다를 파라미터로 받음
fun callLambda(lambda: (String) -> Int): Int {
    return lambda("hello world")
}

fun main() {
    // 람다 변수 정의
    val lambda = { str: String -> str.length }
    var result1 = callLambda(lambda)
    println(result1) // 11

    // 리터럴 람다, 매개변수 타입이 람다함수 1개일 경우 사용 가능  
    val result2 = callLambda { it.length }
    println(result2) // 11
}
```

일반적으로 람다를 매개변수로 받는 함수들은 추가 매개변수가 없어서  
**리터럴 람다** 형식을 사용할 수 있다.  

### 확장함수

**확장함수**를 정의해서 기존 **클래스 재정의 없이 메서드를 확장할 수 있는 방법**을 소개함.  

```kotlin
fun main() {
    println("helloWorld!".addInteger1(1)) // helloWorld! extends String 1
    println("helloWorld!".addInteger2(2)) // helloWorld! extends String 2
}

// 람다형식 확장함수
val addInteger1: String.(Int) -> (String) = {
    "${this} extends String ${it}"
}

// 확장함수 정의
fun String.addInteger2(num: Int): String {
    return "${this} extends String ${num}"
}
```

`String` 에 대한 확장함수를 정의한다.  

사실 **람다형식 확장함수 는 함수 정의가 아닌 함수 참조 property 를 추가하는 것**  

**fun 키워드 확장함수** 는 일반적인 함수를 추가로 정의하는 문법,  
만약 매개변수가 하나가 아닌 여러개라면 **fun 키워드 확장함수**를  사용하길 권장  

기존에 `Double` 타입에서만 존재하던 `pow` 함수를 `Int` 타입에서도 사용할 수 있도록 설정  

```kotlin
// 확장함수
fun Int.pow(x: Int) = toDouble().pow(x).toInt()

fun main() {
    var a = 3;
    var b = a.pow(2);
    println(b) // 9
}
```

### infix 키워드 - 연산자 오버로딩(중위표기 함수)

**연산자 오버로딩**과 비슷한 역할  
`infix` 키워드를 사용해 변수간 중위표기 방식을 구현한다.  

`^` 연산자로 누승을 하는 `infix` 함수 정의  

```kotlin
infix fun Int.^(i: Int): Int {
    return toDouble().pow(i).toInt()
}

fun main() {
    var a: Int = 2 ^ 2;
    println(a) // 4
}
```

`Int.'^'`: `Int 타입` 에 `infix` 함수 추가  
`(i: Int): Int`: 피연산자 `Int 타입`, 출력값 `Int 타입`  

`infix` 함수로 일반 문자열을 사용할땐 백탭을 쓰지 않아도 되지만 특수문자를 사용할땐 백탭으로 감싼다.  

아래와 같이 `Point` 클래스를 정의후 `+` 연산자 오버로딩을 통해 덧셈과 비슷한 연산자를 추가 가능하다.  

```kotlin
class Point(val x: Int, val y: Int) {
    override fun toString(): String {
        return "x:${x} y:${y}";
    }
}

infix fun Point.`+`(p: Point): Point {
    return Point(x + p.x, y + p.y);
}

fun main() {
    val p1 = Point(1, 2)
    val p2 = Point(2, 3)
    val p3 = p1 `+` p2
    print(p3) // x:3 y:5
}
```

### inline 키워드 - 고차함수 

> <https://codechacha.com/ko/kotlin-inline-functions/>

**인자값으로 함수를 전달받거나 반환하는 함수를 고차함수라 한다.**  
이 고차함수를 효율적으로 사용하기 위한 키워드가 `inline` 이다.  

고차함수 내부에서 전달받은 람다함수를 구현하는 클래스를 자동생성하게 된다.  
이때 추가적인 메모리 할당 및 함수호출로 `Runtime overhead` 가 발생하는데  

`inline` 키워드로 함수를 정의할 경우 **함수 자체내용을 호출되는 위치에 복사**하여 오버헤드를 방지한다.  

```kotlin
inline fun someMethod(a: Int, func: () -> Unit):Int {
    func()
    return 2 * a
}

fun main(args: Array<String>) {
    var result = someMethod(2, { println("Just some dummy function") })
    println(result)
}
```

위와 같이 고차함수 를 매개변수로 받는 함수에다 `inline` 키워드를 사용하면  

컴파일 처리 과정에서 메인함수의 코드는 아래와 같이 변하게 된다.  

```kotlin
...
@JvmStatic
public static final void main(@NotNull String[] args) {
    int a = 2;
    int var5 = false;
    String var6 = "Just some dummy function";
    System.out.println(var6);
    int result = 2 * a;
    System.out.println(result);
}
...
```

`inline` 함수의 코드부분이 그대로 이동하게 되며 추가적인 클래스 생성을 방지한다.  

하지만, `inline functions` 는 내부적으로 코드를 복사하기 때문에,  
`inline` 함수에서 인자로 전달받은 고차함수를 변수화 해서 다시 다른 함수로 전달하거나 참조시킬 수 없다.  

코드 양이 많은 함수를 `inline` 처리하면 되려 byte code 가 더 많아질 수 있음으로  
`inline keyword`는 1~3줄 정도 길이의 함수에 사용하는 것이 효과적이다.  

### noinline

`noinline` 키워드를 붙이면 해당 인자는 `inline` 조건에서 제외된다
`noinline` 키워드가 붙은 함수인자는 다른 함수의 인자로 전달하는 것이 가능해진다.  

```kotlin
inline fun newMethod(a: Int, func: () -> Unit, noinline func2: () -> Unit) {
    func()
    someMethod(10, func2)
}

fun someMethod(a: Int, func: () -> Unit):Int {
    func()
    return 2*a
}
```

### Function literals with receiver

일반적으로 `(B) -> C` 형식의 람다함수 타입이 익숙하다.  

`kotlin` 에선 `Function literals with receiver` 를 제공한다.  

`A.(B) -> C` 형식의 **함수 타입**, `receiver` 타입을 가지는 특이한 함수  

`A` 를 `receiver` 라 하며 `.` 앞에 명시, 함수 호출을 위한 사전타입이라 할 수 있다.  
`B` 는 매개변수, `C` 는 반환타입이다.  

```kotlin
fun main() {
    val sum: Long.(Int) -> String = { other -> (this + other).toString() }
    val result: String = 1L.sum(2)
    println(result) // 3
}
```

`sum` 의 함수호출이 특히한것을 알 수 있다.  
`Long` 타입을 `receiver` 삼아 `sum` 함수를 호출한다.  

## java 호환  

kotlin 과 java 호환을 위한 `@JvmOverloads` 어노테이션에 대해 알아보면  

```kotlin
class Person(
    val first: String,
    val middle: String?,
    val last: String
) {
    @JvmOverloads
    fun getDesc(first: String, age: Int = 0, desc: String? = null) =
        "first name $first, desc ${desc ?: "None"}, and age " + NumberFormat.getCurrencyInstance().format(age)
}
```

```kotlin
fun main() {
    val p1 = Person("hello", null, "world")
    p1.getDesc("test");
    p1.getDesc("test", 10);
    p1.getDesc("test", 10, "world");
}   
```

`@JvmOverloads` 어노테이션을 추가하면 컴파일 과정에서 `java` 에서도 `kotlin` 처럼 사용할 수 있도록 함수가 자동 셍성됨  

```java
// java code
public static void main(String[] args) {
    Person p = new Person("hello", null, "world");
    System.out.println(p.getDesc("hello"));
    System.out.println(p.getDesc("hello", 5));
    System.out.println(p.getDesc("hello", 5, "world"));
}
```

### 예외처리  

`kotlin` 의 예외는 모두 unchecked 예외이다.  
`try`, `catch`, `finally` 블록이 있긴하지만 강제하지 않는다.  

```kotlin
fun throwIoError() {
    throw IOException("File or resource not found")
}
```

`java` 의 경우 `IOException` 의 경우 `try`, `catch` 를 요구하지만  
`kotlin` 에선 별도의 처리없이 컴파일 가능하다.  

하지만 `java` 코드에서 `kotlin` 의 함수를 불러올 때 `try`, `catch` 를 사용해 처리하고싶어도 에러가 발생한다.  


```java
// java code
public static void main(String[] args) {
    try {
        useThrowsClause();
    } catch (IOException e) { // 예외 'java.io.IOException'은(는) 해당 try 블록에서 한 번도 던져지지 않습니다
        System.out.println("error invoked");
        e.printStackTrace();
    }
}
```

`java` 코드에 예외가 발생함을 알리는 어노테이션을 추가하여 호환시킬 수 있다.  

```kotlin
@Throws(IOException::class)
fun throwIoError() {
    throw IOException("File or resource not found")
}
```

## 기타기능  


### 버전출력  

버전 출력하기

```kotlin
fun main(args: Array<String>) {
    println("The current Kotlin version is ${KotlinVersion.CURRENT}")
    // The current Kotlin version is 1.3.50
}
```


### repeat 

`kotlin` 내장 `repeat` 함수

```kotlin
fun main(args: Array<String>) {
    var repeatFunction: (Int) -> (Unit) = {
        println("Countung:$it")
    }
    repeat(5, repeatFunction);
    /*
    Countung:0
    Countung:1
    Countung:2
    Countung:3
    Countung:4
    */
}
```

### TODO

원래는 주석을 통해 `TODO` 를 작성했지만 `kotlin` 에선 `TODO` 함수를 지원하기에 강제시킬 수 있다.  

```kotlin
fun myCleverFunction() {
    // TODO: 멋진 구현을 찾는 중
}

fun completeThis() {
    TODO() // throw NotImplementedError
}
```

### Random

```kotlin
fun main() {
    println(Random.nextInt()) //in range
    println(Random.nextInt(100)) //0 ~ 99
    println(Random.nextInt(1, 10)) // 1 ~ 9
}
```

이외에도 여러가지 타입의 Random 함수 제공  

```kotlin
println(Random.nextInt())
println(Random.nextLong())
println(Random.nextBoolean())
println(Random.nextDouble())
println(Random.nextFloat())
```

시드값 전달이 가능하며 반복가능한 난수생성기를 만들 수 있음

```kotlin
val seed: Int = 10
println(Random(seed).nextInt()) // // -129340023
println(Random(10).nextInt()) // -129340023

```


```kotlin
```