---
title:  "Kotlin - start!"

read_time: false
share: false
author_profile: false
toc: true
toc_sticky: true
# classes: wide

categories:
  - kotlin
---

## 함수

`kotlin` 의 기본적인 함수정의는 아래와 같다.  

```kotlin
fun add(a: Int, b: Int): Int {
    return a + b
}

fun add2(a: Int, b: Int) = a + b
```

한줄로 끝날경우 중괄호와 반환타입 모두 생략해도 된다.  

### 람다함수

`java` 에서 람다는 함수형 인터페이스를 구현하는 형식으로 아래의 `lambda` 를 정의한다.  

```java
// java 의 lambda
BiConsumer<Integer, String> labmda = (Integer age, String name) -> {
    System.out.println("my name is " + name + "and my age is " + age);
};
```

`kotlin` 에서는 아래처럼 `입력Type`, `반환Type` 을 미리 작성하여 추론없이 바로 사용하거나  
`arg` 에 `입력Type` 을 정의하고 반환값은 자동으로 추론되도록 한다.  

```kotlin
// kotiln 의 lambda
val funName: (입력Type) -> (반환Type) = {arg -> body}   // 1
val funName = {arg: 입력Type -> body}                   // 2
```

```kotlin
fun main() {
    val square1: (Int) -> (Int) = { number -> number * number } // 1
    val square2 = { number: Int -> number * number } // 2
    println(square1(2)) // 4
    println(square2(2)) // 4
}
```

`square1` 함수는 `입력Type`, `반환Type` 모두 정의  
`square2` 는 `입력Type` 만 정의하고 `반환Type`은 추론되도록 설정

> 개인적으로 2번 방법이 더 깔끔하고 가독성이 좋아보인다.  
> 람다함수는 한줄로 정의되는 경우가 많기에 반환Type 생략이 더 깔끔해 보임  

람다를 파라미터로 받을땐 아래와 같이 작성한다.  

```kotlin
// 람다를 파라미터로 받음
fun callLambda(lambda: (String) -> Int): Int {
    return lambda("hello world")
}

fun main() {
    // 람다 변수 정의
    val lambda = { str: String -> str.length }
    var result1 = callLambda(lambda)
    println(result1) // 11

    // 리터럴 람다, 매개변수가 람다함수 1개일 경우 사용 가능  
    val result2 = callLambda { it.length }
    println(result2) // 11
}
```

일반적으로 람다를 매개변수로 받는 함수들은 추가 매개변수가 없어서  
**리터럴 람다** 형식을 사용할 수 있다.  

### 확장함수

**확장함수**를 정의해서 기존 **클래스 재정의 없이 메서드를 확장할 수 있는 방법**을 소개함.  

```kotlin
fun main() {
    println("helloWorld!".addInteger1(1)) // helloWorld! extends String 1
    println("helloWorld!".addInteger2(2)) // helloWorld! extends String 2
}

// 람다형식 확장함수, 매개변수로 Int, 반환값으로 String 반환
val addInteger1: String.(Int) -> (String) = {
    "${this} extends String ${it}"
}

// 확장함수 정의
fun String.addInteger2(num: Int): String {
    return "${this} extends String ${num}"
}
```

`String` 에 대한 확장함수를 정의한다.  

**람다형식 확장함수** 는 함수 정의가 아닌 **함수 참조 property** 를 추가하는 문법.  
**fun 키워드 확장함수** 는 일반적인 함수를 추가로 정의하는 문법.  

만약 매개변수가 하나가 아닌 여러개라면 **fun 키워드 확장함수**를  사용하길 권장  
람다형식 확장함수 매개변수가 여러개라면 `it` 하나로 모든 매개변수를 표현할 수 없다.   

기존에 `Double` 타입에서만 존재하던 `pow` 함수를 `Int` 타입에서도 사용할 수 있도록 설정  

```kotlin
// 확장함수
fun Int.pow(x: Int) = toDouble().pow(x).toInt()

fun main() {
    var a = 3;
    var b = a.pow(2);
    println(b) // 9
}
```

### infix 키워드 - 연산자 오버로딩(중위표기 함수)

**연산자 오버로딩**과 비슷한 역할  

`infix` 키워드를 사용해 변수간 중위표기 방식을 구현한다.  

`^` 연산자로 누승을 하는 `infix` 함수 정의  

```kotlin
infix fun Int.^(i: Int): Int {
    return toDouble().pow(i).toInt()
}

fun main() {
    var a: Int = 2 ^ 2;
    println(a) // 4
}
```

`Int.'^'`: `Int 타입` 에 `infix` 함수 추가  
`(i: Int): Int`: 피연산자 `Int 타입`, 출력값 `Int 타입`  

`infix` 함수로 일반 문자열을 사용할땐 백탭을 쓰지 않아도 되지만 특수문자를 사용할땐 백탭으로 감싼다.  

아래와 같이 `Point` 클래스를 정의후 `+` 연산자 오버로딩을 통해 덧셈과 비슷한 연산자를 추가 가능하다.  

```kotlin
class Point(val x: Int, val y: Int) {
    override fun toString(): String {
        return "x:${x} y:${y}";
    }
}

infix fun Point.`+`(p: Point): Point {
    return Point(x + p.x, y + p.y);
}

fun main() {
    val p1 = Point(1, 2)
    val p2 = Point(2, 3)
    val p3 = p1 `+` p2
    print(p3) // x:3 y:5
}
```

### inline 키워드 - 고차함수 

> <https://codechacha.com/ko/kotlin-inline-functions/>

**인자값으로 함수를 전달받거나 반환하는 함수를 고차함수라 한다.**  
이 고차함수를 효율적으로 사용하기 위한 키워드가 `inline` 이다.  

고차함수 내부에서 전달받은 람다함수를 구현하는 클래스를 자동생성하게 된다.  
이때 추가적인 메모리 할당 및 함수호출로 `Runtime overhead` 가 발생하는데  

`inline` 키워드로 함수를 정의할 경우 **함수 코드블럭 자체내용을 호출되는 위치에 복사**하여  
고차함수 호출시 발생하는 오버헤드를 방지한다.  

```kotlin
inline fun someMethod(a: Int, func: () -> Unit):Int {
    func()
    return 2 * a
}

fun main(args: Array<String>) {
    var result = someMethod(2, { println("Just some dummy function") })
    println(result)
}
```

위와 같이 고차함수 를 매개변수로 받는 함수에다 `inline` 키워드를 사용하면  

컴파일 처리 과정에서 메인함수의 코드는 아래와 같이 변하게 된다.  

```kotlin
...
@JvmStatic
public static final void main(@NotNull String[] args) {
    int a = 2;
    int var5 = false;
    String var6 = "Just some dummy function";
    System.out.println(var6);
    int result = 2 * a;
    System.out.println(result);
}
...
```

`inline` 함수의 코드부분이 그대로 이동하게 되며 추가적인 클래스 생성을 방지한다.  

하지만, `inline functions` 는 내부적으로 코드를 복사하기 때문에,  
`inline` 함수에서 인자로 전달받은 고차함수를 변수화 해서 다시 다른 함수로 전달하거나 참조시킬 수 없다.  

코드 양이 많은 함수를 `inline` 처리하면 되려 byte code 가 더 많아질 수 있음으로  
`inline keyword`는 1~3줄 정도 길이의 함수에 사용하는 것이 효과적이다.  

### noinline

매개변수로 전달받은 함수인자 앞에 `noinline` 키워드를 붙이면 해당 인자는 `inline` 조건에서 제외된다
`noinline` 키워드가 붙은 함수인자는 다른 함수의 인자로 전달하는 것이 가능해진다.  

```kotlin
inline fun newMethod(a: Int, func: () -> Unit, noinline func2: () -> Unit) {
    func()
    someMethod(10, func2)
}

fun someMethod(a: Int, func: () -> Unit):Int {
    func()
    return 2*a
}
```

### reified

> reified: 구체화 된

`inline` 함수와 `generic type`에서 `reified` 자주 사용함

```kotlin
inline fun <reified T : Any> ReactiveMongoOperations.findById(id: Any, collectionName: String? = null): Mono<T> = ...
```

`generic type` 은 컴파일 시점에 타입을 체크, 함수를 재정의하는 방식  

`inline + reified` 는 확장된 코드를 정의한 함수내에 붙여넣어 재정의 하는 방식이다. 

```kotlin
fun main() {
    printWhatAmI<String>() // i'm String
    printWhatAmI<Int>() // i'm Int
}

inline fun <reified T> printWhatAmI() {
    when (T::class) {
        String::class -> {
            println("i'm String")
        }
        Int::class -> {
            println("i'm Int")
        }
    }
}
```

### Function literals with receiver

일반적으로 `(B) -> C` 형식의 람다함수 타입이 익숙하다.  

`kotlin` 에선 `Function literals with receiver` 를 제공한다.  

`A.(B) -> C` 형식의 **함수 타입**, `receiver` 타입을 가지는 특이한 함수  

`A` 를 `receiver` 라 하며 `.` 앞에 명시, 함수 호출을 위한 사전타입이라 할 수 있다.  
`B` 는 매개변수, `C` 는 반환타입이다.  

```kotlin
fun main() {
    val sum: Long.(Int) -> String = { other -> (this + other).toString() }
    val result: String = 1L.sum(2)
    println(result) // 3
}
```

`sum` 의 함수호출이 특히한것을 알 수 있다.  
`Long` 타입을 `receiver` 삼아 `sum` 함수를 호출한다.  

## java 호환  

kotlin 과 java 호환을 위한 `@JvmOverloads` 어노테이션에 대해 알아보면  

```kotlin
class Person(
    val first: String,
    val middle: String?,
    val last: String
) {
    @JvmOverloads
    fun getDesc(first: String, age: Int = 0, desc: String? = null) =
        "first name $first, desc ${desc ?: "None"}, and age " + NumberFormat.getCurrencyInstance().format(age)
}
```

```kotlin
fun main() {
    val p1 = Person("hello", null, "world")
    p1.getDesc("test");
    p1.getDesc("test", 10);
    p1.getDesc("test", 10, "world");
}   
```

`@JvmOverloads` 어노테이션을 추가하면 컴파일 과정에서 `java` 에서도 `kotlin` 처럼 사용할 수 있도록 함수가 자동 셍성됨  

```java
// java code
public static void main(String[] args) {
    Person p = new Person("hello", null, "world");
    System.out.println(p.getDesc("hello"));
    System.out.println(p.getDesc("hello", 5));
    System.out.println(p.getDesc("hello", 5, "world"));
}
```

### 예외처리  

`kotlin` 의 예외는 모두 `unchecked` 예외이다.  
`try`, `catch`, `finally` 블록이 있긴하지만 강제하지 않는다.  

```kotlin
fun throwIoError() {
    throw IOException("File or resource not found")
}
```

`java` 의 경우 `IOException` 의 경우 `try`, `catch` 를 요구하지만  
`kotlin` 에선 별도의 처리없이 컴파일 가능하다.  

하지만 `java` 코드에서 `kotlin` 의 함수를 불러올 때 `try`, `catch` 를 사용해 처리하고싶어도 에러가 발생한다.  


```java
// java code
public static void main(String[] args) {
    try {
        useThrowsClause();
    } catch (IOException e) { // 예외 'java.io.IOException'은(는) 해당 try 블록에서 한 번도 던져지지 않습니다
        System.out.println("error invoked");
        e.printStackTrace();
    }
}
```

`java` 코드에 예외가 발생함을 알리는 어노테이션을 추가하여 호환시킬 수 있다.  

```kotlin
@Throws(IOException::class)
fun throwIoError() {
    throw IOException("File or resource not found")
}
```
