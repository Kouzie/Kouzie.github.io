---
title:  "Kotlin - start!"

read_time: false
share: false
author_profile: false
toc: true
toc_sticky: true
# classes: wide

categories:
  - kotlin
---


## 개요

> <https://kotlinlang.org/docs/command-line.html#install-the-compiler>

kotlin 설치 후 간단히 hello world 예제 출력

```sh
brew install kotlin
kotlin -version
Kotlin version 1.6.10-release-923 (JRE 11.0.10+8-jvmci-21.0-b06)
```

```sh
vi hello.kr
```

```kotlin
fun main() {
    println("Hello, World!")
}
```

```sh
kotlinc-jvm hello.kt
kotlin HelloKt
Hello, World!
```

`kotlinc-jvm` 대신에 `kotlinc`(Kotlin compiler) 사용 가능  

```sh
kotlinc hello.kt -include-runtime -d hello.jar
java -jar hello.jar

Hello, World!
```

```sh
kotlinc

Welcome to Kotlin version 1.6.10 (JRE 11.0.10+8-jvmci-21.0-b06)
Type :help for help, :quit for quit
>>> println("hello world")
hello world
>>> var name = "test"
>>> println("hello $name")
hello test
>>> :help
Available commands:
:help                   show this help
:quit                   exit the interpreter
:dump bytecode          dump classes to terminal
:load <file>            load script from specified file
>>> :quit
```

### kotlin 스크립트

아래처럼 `main` 이 없는 코드를 나열하고 JVM 상에서 스크립트 형식으로 실행  

```kotlin
import java.time.*

val instant = Instant.now()
val southPole = instant.atZone(ZoneId.of("Antarctica/South_Pole"))
val dst = southPole.zone.rules.isDaylightSavings(instant)
println("It is ${southPole.toLocalTime()} (UTC${southPole.offset}) at the south Pole")
println("The south Pole ${if (dst) "is" else "is not"} on Daylight Savings Time")
```


```sh
kotlinc -script southpole.kts

It is 20:50:43.486781 (UTC+13:00) at the south Pole
The south Pole is on Daylight Savings Time
```

## 연산자

### 동등 연산자(====)

`equals`, `hasCode`, `toString`, `copy`(얕은복사) 가 미리 재정의되는 `data class` 를 사용하여 동등 비교  

```kotlin
data class Product(
    val name: String,
    val price: Double,
    val onSale: Boolean = false
)

fun main() {
    val p1 = Product("product1", 2000.0, true)
    val p2 = p1.copy(price = 2000.0)
    println(p1.equals(p2)) // true
    println(p1 === p2) // false
}
```

`====` 연산자는 참조가 같은지를 확인한다.  

### 삼항연산자

`kotlin` 에는 `?, :` 를 사용한 삼항연산자가 없고 `if, else` 로 구성할 수 있다.  

```kotlin
fun main() {
    val num = 11
    val result1 = if (num > 10) "it's true" else "it's false"
    val result2 = if (num > 10) {
        5 + 5
    } else {
        100 + 100
    }
    println(result1) // it's true
    println(result2) // 10    
}
```

### when  

`switch` 에 해당하는 연산자  

```kotlin
fun checkName(score: Int) {
    when(score) {
        0 -> println("zero")
        1 -> println("one")
        2,3 -> println("two or three")
        else -> println("unknown") // else 생략해도 컴파일 가능
    }
}
```

다른언어의 `swtich` 와 다르게 단순 코드블럭을 실행하는 것이 아닌 **값을 반환할 수 있다**(단 `else` 를 강요)

```kotlin
fun getName(score: Int): String {
    val result: String = when (score) {
        0 -> "zero"
        1 -> "one"
        2, 3 -> "two or three"
        else -> "unknown"
    }
    return result
}
```

`in` 키워드로 범위를 지정할 수 있다.  

```kotlin
fun getName(score: Int): String {
    val result: String = when (score) {
        in 0..10 -> "zero"
        in 10..90 -> "one"
        in 90..100 -> "two or three"
        else -> "unknown"
    }
    return result
}
```

위 `if, else` 삼항연산 대신 확장해서 사용가능하다.  

### for  

```kotlin
val list = listOf("a", "b", "c", "d")
for ((index, name) in list.withIndex()) {
    println("${index}:${name}")
    // 0:a
    // 1:b
    // 2:c
    // 3:d
}

val array = arrayOf(1, 2, 3)
for (i in array) {
    print(i) // 123
}
for (i in 1..10 step 2) {
    println(i) // 13579
}
for (i in 10 downTo 1) {
    println(i) // 10987654321
}
for (i in 1 until 10) { // 10 은 포함하지 않음
    println(i) // 123456789
}
```

### val, var 변수선언

`val`은 **변경할 수 없는 속성(immutable)**   
할당된 이후 값을 변경하게 되면 컴파일 에러가 발생, 변수를 생성시 반드시 **타입을 명시** 해줘야 한다.  

> `java` 에서는 `final`과 같다  

```kotlin
val num1 = 42
val num2: Int = 45
val num3: Int
// val num4 에러 발생, 타입 지정 필수
// num1 = 1; 재정의 에러 발생
```


`var`은 **변경할 수 있는 속성(mutable)**  
초기화 후 값을 변경이 가능하다(일반적인 변수선언 방식)  

### nullable(?), 안전호출(?.) 연산자

코틀린은 기본적으로 필드에 `null` 사용이 불가능한데 `nullable(?)` 키워드를 사용하면 필드에 `null` 값 지정이 가능하다.  

> `java` 의 `Optional` 과 유사

```kotlin
class Person(
    val first: String,
    val middle: String?,
    val last: String
)
```

`String?` 과 `String` 은 `null` 허용 여부만 결정하는 것 처럼 보이지만  
컴파일시 아예 다른 기능의 변수처럼 동작한다.  

```java
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
...

public final class Person {
    @NotNull
    private final String first;
    @Nullable
    private final String middle;
    @NotNull
    private final String last;

    public Person(@NotNull String first, @Nullable String middle, @NotNull String last) {
        ...
    }
    ...
}
```

`nullable` 키워드를 사용하면 아래와 같이 내부 필드나 함수를 호출할 때 안전호출연산자(`?.`) 를 체인형식으로 사용해야한다.  

```kotlin
class Person(
    val first: String,
    val middle: String?,
    val last: String
) {
    fun printMiddleNameLength() {
        val len: Int? = middle?.length
        println(len) // 안전호출 연산자
    }
}

fun main() {
    val p1 = Person("ko", null, "e")
    p1.printMiddleNameLength(); // null
}
```

컴파일 단계에서 **null point 발생 가능한 경우를 원천 차단**한다.  

### smart cast

`smart cast` 는 **컴파일 단계에서 null point 이슈가 해결되었다면 더이상 컴파일 에러를 발생시키지 않는다.**  
예를 들어 아래와 같이 `if` 문을 통해 해당 변수가 `null` 이 아님을 확인한다면 `if` 블럭 내부에선 `?` 가 없이 사용 가능하다.  


```kotlin
class Person(
    val first: String,
    val middle: String?,
    val last: String
) {
    fun printMiddleNameLength() {
        if (middle != null) {
            // smart cast
            val temp: String = middle
            println(middle.length) // null 출력
        }
    }
}

fun main() {
    val p1 = Person("ko", null, "e")
    p1.printMiddleNameLength();
}
```


`p1.middle` 이 `null` 이 아님을 확신할수 있기에 `String?` 이 아닌 `String` 타입으로 인식한다.  

하지만 `val` 이 아닌 `var` 로 선언할경우 이런 `smart cast` 가 동작하지 않는다.  
언제든 `null` 로 다시 재정의될 수 있다고 생각하기에 `smart cast` 가 동작하지 않는다.  

### 단언 연산자(!!)

아래와 같이 `var` 로 정의된이상 `smart cast` 가 동작하지 않으며 `String?` 타입에서 벗어날 수 없다.  

```kotlin
class Person(
    var first: String,
    var middle: String?,
    var last: String
)
```

하지만 단언연산자(`!!`) 를 사용하면 강제로 `String` 타입으로 변경가능하다.  

하지만 `NullPointException` 이 발생할 수 있다.  

```kotlin
class Person(
    var first: String,
    var middle: String?,
    var last: String
) {
    fun printMiddleNameLength() {
        println(middle!!.length) // KotlinNullPointerException 예외 발생
    }
}

fun main() {
    val p1 = Person("ko", null, "e")
    p1.printMiddleNameLength();
}
```

단연연산자 사용을 권장하지 않는다.  

처음부터 `val` 로 변수로 정의하거나 `var` 로 정의하고 안전호출 연산자(`?.`) 를 통해 값을 겨저오는 것을 권장한다.  

### 엘비스 연산자(`?:`)

엘비스 연산자(`?:`) 역시 `nullable` 변수를 다루기 위한 연산자.  

> null 체크하는 삼항연산자와 같은 기능  

```kotlin
class Person(
    var first: String,
    var middle: String?,
    var last: String
) {
    fun printMiddleNameLength() {
        println(middle?.length ?: 0) // null 이라면 0 반환
    }
}

fun main() {
    val p1 = Person("ko", null, "e")
    p1.printMiddleNameLength();
}
```

`middle?.length` 은 `Int?` 를 반환하고 `null` 이 아니라면 정상적으로 `length` 를 반환

`null` 로 반환되었다면 엘비스 연산자(`?:`)를 통해 최종적으로 `0`을 반환한다.  

### 안전타입 변환연산자(`as?`)

마찬가지로 `nullable` 변수를 다루기 위한 연산자.  

```kotlin
val p1: Nothing? = null
val p2: Person? = p1 as? Person
```

변수 `p1` 의 타입을 `Person` 으로 변환  
안전타입 변환연산자(`as?`) 를 통해 `Person?` 으로 변환된다.  

> Nothing 은 클래스 part 에서 설명  

### ?.let

**`not null` 인 경우동작하는 코드블럭를 정의**한다 보면 된다.  

```kotlin
val email : String? ="test@test.com"
email?.let {
    println(it) // test@test.com
}
```

`?.let` 키워드로 `null` 이 아닐경우만 `let` 블록을 실행할 수 있도록 설정  
내부에선 `it` 키워드를 사용함  

### 타입변환  

`java` 와 다르게 `Int -> Long` 자동승격하지 않는다  
`toLong`, `toInt` 함수를 사용해야 한다.  

```kotlin
fun main() {
    val i: Int = 3
    // val l: Long = i // error 발생
    val l: Long = i.toLong();
}
```

아래와 같은 타입변환 함수 지원  

- `toByte`  
- `toChar`  
- `toShort`  
- `toInt`  
- `toLong`  
- `toFloat`  
- `toDouble`  


### 비트연산  

`Byte`, `Short`, `Int`, `Long` 에 한하여 진법출력 함수 `toString(radix: Int)` 가 있음  

```kotlin
fun main() {
    val i: Int = 10
    println(i.toString(2)) // 1010 
}
```

`and`, `or`, `xor`, `inv(not)` 비트 연산자를 제공한다.  

```kotlin
fun main() {
    var b1: Int = 0b0001_1111
    var b2: Int = 0b0001_0000
    println(b1 and b2)  // 16 
    println(b1 or b2)   // 31
    println(b1 xor b2)  // 15 
    println(b2.inv())   // -17
}
```

시프트연산으로 아래 3가지 제공  

- `shl`: `signed left shift`
- `shr`: `signed right shift`
- `ushr`: `unsigned left shift`

## 기타기능  


### 버전출력  

버전 출력하기

```kotlin
fun main(args: Array<String>) {
    println("The current Kotlin version is ${KotlinVersion.CURRENT}")
    // The current Kotlin version is 1.3.50
}
```


### repeat 

`kotlin` 내장 `repeat` 함수

```kotlin
fun main(args: Array<String>) {
    var repeatFunction: (Int) -> (Unit) = {
        println("Countung:$it")
    }
    repeat(5, repeatFunction);
    /*
    Countung:0
    Countung:1
    Countung:2
    Countung:3
    Countung:4
    */
}
```

### TODO

원래는 주석을 통해 `TODO` 를 작성했지만 `kotlin` 에선 `TODO` 함수를 지원하기에 강제시킬 수 있다.  

```kotlin
fun myCleverFunction() {
    // TODO: 멋진 구현을 찾는 중
}

fun completeThis() {
    TODO() // throw NotImplementedError
}
```

### Random

```kotlin
fun main() {
    println(Random.nextInt()) //in range
    println(Random.nextInt(100)) //0 ~ 99
    println(Random.nextInt(1, 10)) // 1 ~ 9
}
```

이외에도 여러가지 타입의 Random 함수 제공  

```kotlin
println(Random.nextInt())
println(Random.nextLong())
println(Random.nextBoolean())
println(Random.nextDouble())
println(Random.nextFloat())
```

시드값 전달이 가능하며 반복가능한 난수생성기를 만들 수 있음

```kotlin
val seed: Int = 10
println(Random(seed).nextInt()) // // -129340023
println(Random(10).nextInt()) // -129340023

```


```kotlin
```