---
title:  "마이크로 서비스!"

read_time: false
share: false
author_profile: false
toc: true
toc_sticky: true
# # classes: wide

categories:
  - 기타
---

# 개요  

이번 포스팅에선 마이크로 서비스에서 사용하는 주요 용어나 방법론을 설명하려 한다.  


**CBD/SOA (Component Based Development/Service Oriented Architecture)**
기능별 모듈화를 통해 컴포넌트를 생성, 컴포넌트들을 보다 의미있는 서비스 지향 아키텍처 로 발전시키는 방식을 **CBD/SOA** 라 한다.  

MSA 과 개발 이념은 같으며 클라우드 플랫폼에서 해당 이념을 구축하고 성공사례로 공유한 것이 MSA 이다.   

물리적인 인프라 차이도 약간 있으며 CBD/SOA 는 물리적으로 DB 분리하지 않으나 MSA 의 경우 DB 까지 나눌 수 있다.  
API 호출을 통해서만 다른 Service 의 데이터에 접근할 수 있도록 결합도를 낮추고 모듈화를 강화시켰다.  

**소프트웨어 생명주기의 변화**
소프트웨어를 기능의 집합으로 보는 것이 아닌 비지니스 제공을 위한 제품(Product) 로 인식,  
점진적 수정되는 제품 중심의 애자일(agile) 개발방식을 사용  

모든 프로그램을 개발후 통합, 배포 후 유지보수 하는 것이 아닌
테스트 product 개발부터 배포까지 단계별로 진행 후 업데이트, 유지보수를 진행한다.  

애자일 개발환경을 지원하기 위해 강력한 Devops 는 필수  

**데이터 분권화**
과거 DB 모델링시 중복없는 정규화 과정을 꼭 거쳤지만  
스토리지와 네트워크 대역폭 상승으로 많이 완화되었다.  
폴리글랏 환경에서 일부 데이터의 중복과 복제는 허용한다.   
어느정도 일관성 처리를 하기는 한다. two phast commit, 비동기 이벤트 처리 등\
two phast commit 경우 서비스간 결합도가 상승하기에 주로 비동기 이벤트 처리를 사용함  

위와 같은 방식을 사용하면 특징 시점에 데이터 일관성이 일그러지는 상황이 한번이상 분명히 오지만 
카프카와 같은 강력한 메세지 큐 시스템을 통해 MSA 환경에선 어느정도 허용하는 편  

**리액티브**  
> Reactive: 반응적인

백, 프론트, 앱, IoT 등 현대 어플리케이션이 가춰야할 필수 요소가 Reactive 이며 
아래 4요소를 가진다.  

**응답성(Responsive)** - 신뢰성있는 응답  
**탄력성(Resilient)** - 장애전파 x, 빠르게 복구  
**유연성(Elastic)** - 사용량 변화에 맞춰 자원 확장  
**메세지기반(Message Driven)** - 비동기 기반, 느슨한 결합  

**IaaS, PaaS, SaaS**

`Infrastructure as a Service` - 인프라를 가상으로 제공  
`Platform as a Service` - 인프라 + 개발환경(platform) 까지 가상으로 제공  
`Software as a Service` - 인프라 + 개발환경 + 어플리케이션(software) 까지 가상으로 제공  

베어메달(물리적 서버)에 직접 PaaS 혹은 Saas 를 구축해도 되지만 리액티브의 유연성 요소를 포기하게 된다.  

# 패턴 

**서비스 메시 패턴**  
초창기 넷플릭스 OSS 기반의 Gateway, Config, Service Registry 등 운영서비스가 별도의 서버로 분리되어 있었고 플랫폼 의존적인 요소또한 있었는데  
이런 기능을 서비스 메시 패턴을 통해 해결할 수 있다.  
대표적인 프로젝트가 구글의 Istio  
쿠버네티스에 기본 탑재되어 있으며 배포되는 컨테이너의 라우팅, 디스커버리, 로드밸런싱, 모니터링, 보안, 트레이싱 기능을제공  

(사이드카 패턴)서비스 컨테이너 서비스 내부에 특정 설정이 들어가지 않고 외부에 별도의 컨테이너가 추가 배포, 네트워크 프락시를 통해 운영되는 환경이다.  
그렇기 때문에 넷플릿 OSS 환경에서 벗어나 진정한 폴리글랏 구조의 백앤드를 구축가능하다.  

**SAGA 패턴**
choreography saga 패턴과 orchestation saga 패턴 두 종유가 있으며
choreography saga 패턴의 경우 이벤트 교환, 동기화를 참가자에 맡기고 
orchestation saga 패턴의 경우 이벤트 교환, 동기화를 중앙화해서 처리한다.  
SAGA는 MSA 에서 분산 트랜잭션 처리를 지원하기 위한 패턴으로 
여러 API요청 혹은 메세지 이벤트를 활용해 트랜잭션을 처리한다.  


**CQRS 패턴**
Command Query Responsibility Segregation 약자로 읽기와 쓰기 분리하는 패턴  
CRUD 중에 Read 가 압도적으로 많이 사용되며 불리적으로 두 저장소를 분리, 부하를 줄이고 반환시간을 앞당길 수 있다.  
이벤트만을 사용해 읽기전용 서비스의 데이터를 수정하고 사용자는 API 를 사용해 데이터를 읽어들인다. 


**이벤트 소싱 패턴**
데이터의 일관성을 모델로 관리하는 것이 아닌 차곡차곡 쌓이는 이벤트 형식으로 관리하는 패턴  
CRUD 에서 UD 가 사라지고 CR 만들 사용해 데이터의 일관성을 유지한다.  

# 구조

## 레이어드 아키텍쳐

layered architacture 는 내부의 논리척은 계층 분할을 의미한다.  
스프링 MVC 패턴처럼 프레젠테이션, 비지니스로직, 데이터 엑세스 3 개 구조로 나누는 방식이다.  

프레젠테이션: 화면표현 및 전환처리
비지니스로직: 비지니스 개념, 규칙, 흐름제어
데이터 엑세스: 데이터 처리

MVC 패턴과 유사하게 단방향으로 흐르며 하위 계층은 상위계층 로직에 영향을 주면안되며
계층간의 호출은 인터페이스 함수를 기반으로 이루어 진다.  



## 헥사고날 아키텍쳐

Hexagonal Architecture (6각 구조) 는 단순 3계층인 레이어드 아키텍쳐로는 제대로된 비지니스 처리가 불가능하여 나온 구조이다.  


![ddd1](/assets/2021/ddd1.png)  

내부에선 고수준의 비지니스 로직을 수행하고  
위부에선 외부에서 들어오는 요청을 처리하는 인바운드 어뎁터, 외부와 연계를 위한 아웃바운드 어뎁터로 구성된다.  

![ddd1](/assets/2021/ddd3.png)  

인풋바운드, 아웃바운드는 여러개의 포트와 어뎁터로 구성되는데  

여기서 포트는 각 어뎁터를 사용하기 위해 표출된 API 라 생각하면 되고  
어뎁터는 각 포트를 사용해 외부로 부터 들어온 데이터를 처리해서 넘겨주거나
내부에서 생긴 데이터를 외부로 내보내는 역할을 한다.  

인바운드어뎁터로 MVC 컨트롤러, 메세지 핸들러 등이 있고  
아웃바운드어뎁터로 DB로 데이터를 내보내는 DAO, 이벤트 메세지 발행 클래스, 외부 서비스 호출 프락시 클래스 등이 있다.  



## 클린 아키텍처


헥사고날 아키텍쳐와 매우 유사한 구조로  
아래 그림처럼 여러겹으로 둘러싸인 원형태로 나타낸다.  

![ddd1](/assets/2021/ddd2.png)  

Entity: 데이터와 데이터를 다루는 핵심 규칙
Use Cases: 엔티티 내부의 핵심 규칙을 호출해 시스템을 사용하는 흐름

## 내부영역

헥사고날 아키텍처나 클린 아키텍처나 내부에서 비지니스 로직을 처리하는 내부영역이 존재한다.  

- 서비스 인터페이스/구현체  
- 도메인  
- 도메인 이벤트 인터페이스  
- 리포지토리 인터페이스  
- API 프락시 인터페이스  

서비스 인터페이스는 외부의 어뎁터가 내부 사정을 깊게 알수 없도록, **정보은닉** 원칙에 따라 개발하고

리포지토리, API 프락시는 역으로 내부영역이 고수준이고 외부어뎁터가 저수준으로, 저수준인 외부어뎁터가 이를 구현하는 **의존관계역전**원칙에 따라 개발을 한다.  

### 트랜잭션 스크립트 패턴

일반적인 절차식 프로그래밍 방식으로 
도메인은 비지니스 개념을 표현하기 위한 데이터, 
서비스는 도메인을 사용해 여러 행위를 하는 방식으로 운영하는 패턴

비지니스가 커질수록 서비스가 커지고 도메인은 단순 DTO 역할만 하게 된다.  

### 도메인 모델 패턴

도메인 객체가 단순 DTO 역할을 하는것이 아닌 비지니스 행위까지 가지며  
서비스는 단순 도메인의 행위를 호출만 하는 패턴이다.  
이런 특성때문에 도메인의 데이터는 행위에 의해 은닉된다. (Setter, Getter 사용 금지)

데이터와 행위를 도메인에 적절한 책임을 분배해야 함으로 객체지향 지식이 필요  

잘 정의된 모메인 모델은 중복코드를 줄이고 서비스 코드를 간결히한다.  

### 도메일 주도 설계 + Aggregate(통합) 패턴  

객체관의 관계는 1:1, 1:N, N:M 등으로 나타날 수 있는데 
N에 해당하는 데이터가 수정되거나 1에 해당하는 데이터가 수정될 경우
관계되는 데이터간의 수정사항이 발생하는 모델에서 애그리거트 패턴이 유용하게 사용된다.  

서비스는 최상위 도메인만 접근해서 행위를 하위 도메인은 상위 도메인에 의해 수정되도록
처리를 위임하는 패턴이다.  

## 외부영역

외부영역은 내부영역에 접근하기 위한,
내부영역에서 외부로 나가기 위한 영역이다.  

내부영역과 위부영역을 연결짖기 위해 인터페이스와 어댑터들로 구성되며  
어댑터는 플러그인처럼 교체, 확장 가능해야 한다.  

**API 퍼블리싱 어댑터**  
서비스의 비지니스로직은 REST 형식의 API 로 발행하는 어댑터
주고 받는 데이터를 위한 DTO 를 별도 생성하는 것을 권장  

**API 프락시 어댑터**
다른 서비스의 API 를 호출하는 아웃바운드 어댑터, REST API, SOAP 프로토콜, TCP 소켓 등 여러 인터페이스종류를 가진다.  

**저장소 처리 어뎁터**  
OR 매핑 혹은 SQL 매핑방식이 있으며 도메인 모델 패턴 사용시 OR 패빙방식인 JPA(Spring Data) 를 주로 사용한다.  

**도메인 이벤트 발행 어댑터**  
메세지 발행/구독 을 통해 서비스간 비동기 구조를 구축할 때 사용하는 어뎁터, 
인터페이스로 제작된 발행 어댑터를 통해 메세지가 내부영역으로부터 외부로 발행된다.  

**도메인 이벤트 핸들러**  
발행 어뎁터와 반대로 구독을 위한 어댑터로 외부에서 내부로 이벤트 메세지를 전달하는 역할을 수행한다.  

# MSA + DDD

MSA 설계와 개발을 위해 가장 적합한 모델이 DDD 이고 
현재도 이를 가이드삼아 개발되고 있다.  

애자일 프로세스와 연계하여 설계/개발 하는 경우가 많다.  

## 스크럼 생명주기  

> Scrum: 양 팀의 선수들이 럭비공을 가운데 두고 대치해 있는 대형
> Sprint: 단거리 전력 질주 

스프린트: 작은 기능 하나에 대한 [계획, 개발, 테스트, 기능 완료] 주기를 일컫는 말.
보통 1주 ~ 4주 사이의 기간 동안 스프린트를 진행한다. 

스크럼 팀: 스프린트가 진행되는 팀, 마스터와 멤버로 구성

프론트, 백, 설계자, 테스터, BM 전문가, 디자이너가 하나의 **스크럼 팀**을 이루며 **스크럼 미팅**을 통해 각자의 업무를 공유하고 아래와 같은 규칙에 따라 소프트웨어를 개발하는 것을 스크럼이라 한다.  

- 매일 정해진 시간에 15분정도 각자의 상황공유(스크럼 미팅)
- 1주에서 4주 사이의 **스프린트** 기간동안 각자의 임무 수행
- 스프린트가 끝나면 스프린트 리뷰와 회고 진행  

모든 업무는 백로그에 기록하며 스프린트 계획수립을 통해 스프린트 단위로 나뉘고(스프린트 백로그) 각 팀에게 배분되어 스프린트가 진행된다.   

매 스프린트마다 동작하는 소프트웨어를 시연하고 피드백을 얻고 스프린트는 다시 반복된다.  

설계보단 일단 개발이라는 모토를 가지기에 이런 과정을 위해선 이전에 설명했던 아키텍처가 굉장히 중요하다

백앤드 개발자는 인터페이스만 정의하고 세부구조는 나중에 개발한다.  
프론트 개발자는 API 설계만 진행하고 나머지 활동은 각각 내부적으로 진행하게 된다.  

물론 개발 이전에 정해야 하는 설계가 있긴하다.  
도메인 종류, API 설계 등 
간단히 화이트보드 + 포스트잇을 사용해 설계를 마치고 도메인 모델을 공유하고 코드로 통신한다.  

과거의 UML 등을 활용한 Object Oriented Analysis Design 방식도 요즘에는 사용하지 않는다.
(Model Driven Development 라 한다.)  


# 이벤트 스토밍

> 출처: https://www.youtube.com/watch?v=QUMERCN3rZs&t=3364s 

DDD 에서 서비스간 비동기 메세지 전송, 이벤트 호출을 이벤트 스토밍을 통해 설계하면 효율적이다.  

개발자, 관리자, 설계자 모두 모여 서로가 가지고 있는 관점을 논의한다.  
퍼셀리레이터 - 이벤트 스토밍 진행자 또한 있으면 좋음  
매일 혹은 격일로 3시간 미만의 워크숍을 가지고 진행하는 것을 권장

벽, A0 용지, 마커, 스티커, 포스트잇, 선을 그릴수 있는 라인 테이브, 스카치 테이프  

![ddd1](/assets/2021/ddd4.png)  

유형 | 색깔 | 설명
|---|---|---|
도메인 이벤트 | 주황 | 발생사건, 과거시제동사로 표현  
커맨드 | 파랑 | 명령 (도메인 이벤트 트리거)  
외부시스템 | 핑크 | 관계 있는레거시 또는 외부 시스템(도메인 이벤트가 호출)  
애그리거트 | 노랑 | 도메인 이벤트와 커맨드가 처리하는 데이터  
정책 | 라일락 | 이벤트 조건에 따라 진행되는 결정  
읽기모델 | 초록 | 도메인 이벤트 액터에게 제공되는 데이터  
핫스폿 | 자주 | 의문, 질문, 미결정  
사용자 인터페이스 | 흰색 | 화면 레이아웃  
액터 | 약노랑 | 커맨드를 실행하는 자  



![ddd1](/assets/2021/ddd5.png)  

이벤트(주황) - 외부시스템(핑크) - 파랑(커맨드) - 약노랑(액터) - 생노랑(애그리거트)

하나의 애그리거트 하나의 서비스라 생각하면 되고(가끔 2개이상일 수 있음)  
애그리거트 단위로 스티커를 분류하고 줄을 긋는다(바운디드 컨텍스트)  

![ddd1](/assets/2021/ddd6.png)  

나누어진 서비스 단위로 동기요청, 비동기 요청 매핑한다.  
어그리거트, 외부시스템 포스트잇만 따로 붙여 매핑 스티커를 통해 줄을 긋는다.

![ddd1](/assets/2021/ddd7.png)  
> 빨강:비동기, 파랑:동기

보리스 다이어그램
![ddd1](/assets/2021/ddd9.png)  

SNAP-E - 서비스별 상세 설명
![ddd1](/assets/2021/ddd8.png)  

## 분산 트랜잭션  

두개 이상의 시스템에 저장된 데이터를 업데이트 하는 트랜잭션  

분산 트랜잭션을 적용하려면 모노리스 서비스에서 사용하는 2단계 커밋을 적용해야 하는데 마이크로 서비스에서 적용하기 힘들다  

> 2단계 커밋(Two-Phase Commit): DB 트랜잭션을 조율하는 조정자(`Coordinator`) 가 존재하며 2개 이상의 데이터 베이스에게 `준비->확인 -> 커밋->확인` 형식으로 일관성을 유지한다. 실패하면 2개 데이터베이스에게 `Rollback` 명령을 전달한다.  

또한 분산트랜잭션을 사용하면 서비스별 결합도가 상승하고 
확장이 불가능하며 대역폭이 제한된다.  

마이크로 서비스 환경에선 어울리지 않는 방법이다.  


> https://cla9.tistory.com/2?category=814447

## 이벤트 기반 아키텍처  

데이터를 변경하고 동일한 트랜잭션을 처리하는 다른 서비스에게 **메시지 브로커**를 통해 전송한다.  

메세지를 받은 다른 서비스는 이에 따른 데이터 변경 처리를 진행한다.  

브로커를 중간자로 처리하기에 서비스별 결합도가 줄어들지만  
브로커의 의존성이 높아지고 오류 복원력이 낮아진다(두번째 서비스에 장애가 발생하더라도 첫번째 서비스는 계속 유지됨)  
트랜잭션에 참여하는 서비스가 많아질 수록 서비스 확장이 힘들어진다.  

서비스간 의존성이 높다면 서비스 병합을 고려해야 한다.  


### 궁극적 일관성(Eventual Consistency)

그럼에도 불구하고 서비스간 일관성을 유지하는 트랜잭션이 필요하다면 **궁극적 일관성**을 트랜잭션에 도입해야 한다.  

일종의 불확실성 상태를 비지니스 워크플로 일부로 인정해 불확실한 상황까지 트랜잭션에 포함시키는 것이다.  

예를들어 물건을 주문하면 주문데이터가 발생할 것인데 **결제정보 확인 중** 이라는 불확실성 요소를 집어 넣어  
더 이상의 주문데이터 일관성을 해칠 수 없도록 방지해야 한다.  

결제서버로부터 결제 확인 메시지가 올 때 까지 불확실성 요소를 유지하여 일관성을 유지한다.   

## SAGA 패턴

마이크로 서비스에서 가장 많이 사용하는 트랜잭션 모델은 SAGA패턴이다  

SAGA 는 각 서비스별 트랜잭션들로 구성되며 특정 트랜잭션에서 실패할 경우 이전 트랜잭션에 대한 보상이 기동된다.  

### Events-based choreography

### Orchestration via a coordinator service

## 이벤트 소싱 패턴  

> https://www.youtube.com/watch?v=TDhknOIYvw4&feature=youtu.be


각 데이터 상태변화 순서를 저장하는 시스템.  
여기서 상태변화를 이벤트라 할 수 있다.  

일반적으로 데이터의 상태 자체를 저장하는 것이 일반적인 DB의 역할이지만  
이벤트 소싱은 상태변화(이벤트)가 일어날 때 마다 데이터를 DB 에 저장한다.  

이벤트는 절대 수정/삭제 되지 않고 추가되기만 한다.  

은행 입/출금, git 의 버전제어 등이 이벤트 소싱패턴으로 개발되었다 할 수 있다.  



## CQRS (Command and Query Responsibility 명령 및 쿼리책임 분리)  

이벤트 소싱 패턴과 함께 사용되며 

## CRDT (Conflict-free Replicated Data Types 충돌없는 복제 데이터 타입)

마이크로 서비스라 할지라도 기능이 추가되면 다뤄야하는 데이터도 추가된다.  
트랜잭션의 일관성을 유지하기 힘들어지면서 확장성이 나빠진다.  


