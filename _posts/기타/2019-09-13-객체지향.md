---
title:  "객체지향!"

read_time: false
share: false
author_profile: false
toc: true
toc_sticky: true
# classes: wide

categories:
  - 기타
---

## 상속(inheritance)

객체지향에서 상속은 매우 자주 나오는 용어로 코드 재사용을 위해 흔히 사용되는 개념이다.  
상속이란 언어 때문에 아래처럼 상속관계를 오해하기 쉽다.  

![image02](/assets/기타/object1.jpg)  

위 사진은 has-a 상속관계와는 잘 어울리지 않는 모델이다.  

우리가 java에서 상속이라 표현하는 모델은 아래 사진과 더 유사하다.  

![image02](/assets/기타/object2.jpg)  

즉 상속은 **확장, 포함, 분류**의 개념이라 할 수 있다.  

java에서 `inheritance`키워드 대신 `extends`키워드를 사용하는 것이 이때문이다.  

> 흔히 상속을 `is-a` 관계라 표현하는데 좀더 명확한 표현은 `is a kind of`관계라 할 수 있다.  - Three Amigos

## 인터페이스  

다중상속을 통해 좀더 효율적으로 코드 재사용을 하기 위해 나온것이 인터페이스  

인터페이스와 이를 구현하는 클래스와의 관계는 `is a kind of`아닌 `is able to`관계이다.  

**즉 무엇을 할 수 있는 지**에 대한 명세가 인터페이스라 할 수 있다.  

> `Serializable`, `Cloneable`, `Comparable`, `Runnable` 등 java 기존의 여러 인터페이스 뒤에 `able`이란 스펠이 붙는 이유도 위와 같다.  
> 캡슐화, 추상화, 다형성에 대한 내용은 생략

## 결합도와 응집도

좋은 소프트웨어는 **낮은 결합도, 높은 응집도**를 요구한다.  

결합도는 객체간 의존정도를 나타내고 결합도를 낮추면 의존성도 줄어들고 객체의 재사용, 수정, 유지보수가 용이해진다.  

**SOLID**를 통해 어떻게 낮을 결합도, 높은 응집도를 구현하는지 알아보자.  

### SOLID - 객체지향 설계 5원칙

> 위키: 컴퓨터 프로그래밍에서 SOLID란 로버트 마틴이 명명한 객체지향의 다섯 가지 기본 원칙을 **마이클 페더스**가 두문자어로 소개한 것이다.

- SRP  
- OCP  
- LSP  
- ISP  
- DIP  

### SRP - (단일책임 원칙: Single Responsibility Principle)

**어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다** - 로버트 마틴

우리는 모두 책임을 가지고 생활한다.  
학생의 책임은 공부, 군인의 책임은 방호, 개발자의 책임은 개발이다.  

개발자 종류도 여러가지가 있다,  
`웹개발`, `시스템개발`, `모바일개발`, `임베디드개발` 등등...

만약 `개발자` 란 클래스를 만들 때 클래스 설계를 위의 **모든 개발을 할수 있도록 설계**할 것인가?  
아니면 각종 `종류별 개발자`클래스를 **각각 설계**할 것인가?  

당연히 후자가 좋다.  

`웹`, `시스템`, `모바일` 개발 함수를 모두 `한 개발자 클래스`안에 때려넣으면 각 함수에 문제가 생길때 마다 매번 `한 개발자 클래스`에 접근해야 한다.  

**클래스 변경 이유가 여러개가 되는것이다!**  

역할과 책임에 따라 `개발자` 클래스를 `웹개발자`, `시스템개발자`, `모바일개발자`, `임베디드개발자` 등으로 나누었다.  
SRP원칙은 지킬수 있겠지만 클래스가 4개로 쪼개지는 바람에 중복코드도 많이 발생하게 된다.  

개발자란 직업이 공통으로 가지는 기능, 예를 들어 `출근하기()`, `잠자기()` 같은 기본적인 기능들!  
클래스마다 별도로 선언해야 하는가?

만약 `시스템 개발자` 중에서도 `리눅스 시스템 개발자`, `윈도우 시스템 개발자` 같은 또 다른 별도의 클래스를 설계해야 한다면?  

시스템 개발자는 대부분 `c/c++`을 사용할 것이고 공통적으로 가지는 기능들이 매우 많을텐데 다시 그대로 정의해야 하는가?

만약 개발을 오래한 사람이라면 `윈도우 시스템 개발`도 하면서 `안드로이드 모바일 개발`도 할 수 있는 개발자가 있을 것이다.  
그렇다면 `윈도우 안드로이드 개발자` 클래스도 새로 정의해야 하는가?  

객체지향의 어려운점이 이것이다.  
어디까지 추상화하고 어디서부터 구현해야 하는가이다.  

위의 각종 `개발자` 클래스는 **클래스로 설계하기 보단 인터페이스로 설계**하는 것이 옳다.  

> 앞으로 `interface`, `abstract class`, `class` 상관 없이 최소한의 책임을 가지는 엔티티로 설계하자.  

즉 객체지향 개발을 하려면 어느정도까지 추상화를 통해 인터페이스로 구현할 것인지,  
어디서 부턴 인터페이스들을 구현한 클래스를 설계할 것인지 효율적인 결정이 필요하다.  

인터페이스로 구현하게된다면 메서드 삭제/추가 등의 변화가 일어나게 되면 하위클래스를 모두 변경해야 하기에 구현클래스들 `개발자`, `웹개발자`, `시스템개발자` 등은 변경이 힘들어진다.

따라서 기초가 거의 변하지 않는 클래스는 인터페이스와 상속  
그외는 **의존객체** 를 통해 코드 중복을 피한는 것을 추천한다.  

### OCP - (개방폐쇄 원칙: Open Close Principle)

**소프트웨어 엔티티는 확장에 대해 열려있어야 하지만 변경에 대해서는 닫혀있어야 한다** - 로버트 마틴

OCP를 가장 잘 구현한 예는 `JDBC`이다.  

`Oracle`, `Mysql`, `MS-sql` 등 어떤 DB 이던간 Connection 부분만 별도의 라이브러리로 설정하고 연결하면  
그 뒤의 **sql문을 실행하고 결과값을 가져오는 과정**은 모두 똑같다.  

즉 OCP를 잘 구현하려면 **모든 엔티티가 기본적으로 가지고 있는 행위를 인터페이스로 구현**하는 것이 중요하다.  
인터페이스로 정의된 기본적 행위는 거의 변경되지 않는다, 즉 메서드 사용법이 변하지 않는다.  
또한 각종 운영체제에서 사용할 수 있도록 확장기능을 제공한다.  

물론 JVM 위에서 동작하다 보니 OS별 JDBC 코드 차이는 크지 않겠지만 세세한 부분에서 차별점을 요구할것이다.
평범한 개발자는 JDBC를 확장개발해놓은 코드를 사용해 OS구속없이 똑같은 사용법으로 DB connect가 가능하다.  


### LSP - (리스코브 치환의 원칙: The Liskov Substitution Principle)

**서브타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다** - 로버트 마틴

`리스코브는 바바라 리스코프`란 사람이 만들었기 때문에 붙은 스펠이다.  

위에서 **상속과 인터페이스**는 `is a kind of`, `is able to`관계를 가져야 한다 말했는데  
위의 두 관계대로 프로그램 개발을 했다면 이미 LSP를 잘 구현한 것이다.  

자바에서의 다운 캐스팅, 업 캐스팅은 LSP를 기반으로 이루어진다.   

상위(부모) 클래스는 하위(자식)클래스인척 할 수 있다.  
하위(자식) 클래스는 상위(부모)클래스의 메서드를 호출할 수 있고 논리적으로 이상하지 않고 하위클래스에서 기능이 추가되지 삭제되진 않는다.  


### ISP - (인터페이스 분리 원칙: Interface Segregation Principle)

**클라이언트 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다** - 로버트 마틴

ISP는 **인터페이스를 최소한의 기능을 가지도록 설계**하는 것을 뜻한다.  

객체지향에선 **상위(자식) 클래스**는 기능이 풍성할 수록 좋고, **인터페이스**는 작을 수록 좋다.  

먼저 클래스의 기능이 풍성해야 하는 이유를 알아보자.

```java
class 훈련병 {
  ...
  잠자기() {...}
  말하기() {...}
}
class 병사 extends 훈련병 {
  ...
  먹기() {...} //신규
  훈련하기() {...} //신규
}
``` 

위와 같은 클래스가 정의되어 있을때 `훈련병 홍길동 = new 병사();` 으로 **훈련병 인스턴스**를 생성하자.  

`홍길동` 객체를 통해서 호출할 수 있는건 `훈련병` 인터페이스에 정의된 추상메서드 `잠자기()` 뿐이다.  
만약 `먹기()`를 억지로 사용하려 한다면 억지로 형변환 과정이 필요하다. `((병사)홍길동).먹기();`  

사실 `먹기()`는 `훈련병` 클래스 정의되는게 맞다. 즉 클래스 정의할땐 의 책임안에서 최대한(풍성한)의 기능을 제공해야한다.  

이번엔 인터페이스의 기능을 최소화 해야 하는 이유를 알아보자.  

```java
interface 훈련병 {
  ...
  잠자기();
  먹기();
  말하기();
}
class 병사 implements 훈련병 {
  ...
  잠자기() {...} //구현
  먹기() {...} //구현
  말하기() {...} //구현
  훈련하기() {...} //신규
}
```

조금 억지이지만 `훈련병`은 꼭 사람만 될 수 있는가? 개도 될 수 있다 생각해보자.  
개는 말할 수 있는가? 항상 `is able to` 기준으로 인터페이스를 생성하고 역할에 충실한 최소한의 기능만 구현하자.

```java
interface 훈련병 {
  ...
  잠자기();
  먹기();
}
class 군견 implements 훈련병 {
  ...
  잠자기() {...} //구현
  먹기() {...} //구현
  짖기() {...} //신규
  훈련하기() {...} //신규
}
```

SRP에선 **클래스의 단일 책임**을,  
ISP에선 **인터페이스의 단일 책임**을 요구한다.  

만약 최소한의 기능이지만 많은 기능이 들어갈 수 밖에 없다면 인터페이스 보단 SRP를 따라 클래스로 만드는 것이 좋다.

즉 하나의 엔티티를 여러개의 엔티티로 쪼갤 수 있다면 ISP를  
하나의 엔티티를 쪼갤 수 없고, 쪼갠다 하더라도 많은 기능이 포함된다면 SRP이다.  

어디까지는 인터페이스로 설계하고 어디까지는 클래스로 설계하는 지에 대한 경계를 정할 수 있다!
(대부분이 SRP 로 진행된다.)

### DIP - (의존역전 원칙: Dependency Inversion Principle)

**자신보다 변하기 쉬운것에 의존하지 마라** - 로버트 마틴

객체가 의존관계를 가질때 최대한 **상위클래스, 추상클래스, 인터페이스와 같은 불변할 가능성이 높은 객체를 의존**하도록 하는 법칙  
바로 하위클래스를 의존할 경우 **하위클래스가 변함에 따라 서로 의존하는 관계가 될 수 있다**  

어렵게 설명하지만 사실 상위클래스와 하위클래스 사이에 **완화 역할을 해줄 인터페이스를 추가**해주는 것이다.  

대표적인 예가 java 의 JDBC

![image02](/assets/기타/object3.png)  

`프로그램 → DriverManager → JDBC인터페이스 → JDBC드라이버 → DB`  

바로 `프로그램 -> JDBC드라이버` 의존구조를 가질경우

DB가 업데이트 되면서 기존의 `JDBC드라이버`의 메서드들 또한 업데이트 되면 기존 `JDBC드라이버` 접근 코드를 모두 수정해야 한다. 

나의 프로그램이 `JDBC드라이버` 를 의존하면서 발생한 불상사이다.

하지만 `JDBC인터페이스`를 통해 `JDBC드라이버`를 사용중이라면 오라클사가 개발한 `JDBC드라이버`만 새로운 버전으로 업데이트 하면 된다.  

> 오라클사가 `JDBC인터페이스`를 기반으로 개발하는 가정하에  
> `JDBC인터페이스` 는 모든 DB 밴더사가 불변한단 가정하에 개발해주기 때문에 신뢰하며 사용할 수 있는 객체이다.   

즉 의존관계가 필요할 경우 **최대한 불변할 것 같은 객체를 의존관계로 두고 자주 업데이트 되는 하위객체를 해당 인터페이스에 의존토록 하는것이 DIP**.  

인식을 아래 첫번째 그림에서 두번째 그림으로 변경해야 한다.  

![image02](/assets/기타/object5.png)  

## DDD(Domain Driven Design: 도메인 주도 설계)

단순 CRUD 방식의 코드스타일을 사용하면  
복잡한 비지니스 로직 구성시 여러 오류와 즉면할 수 있음으로 DDD 패턴을 사용하자

**DDD 대원칙**은 아래와 같다.  

- 도메인 클레스는 엔티티와 벨류타입으로 구성  
- 도메인 클레스에 기본생성자 protected 로 정의  
- 도메인 클레스에 `setter` 사용 X, 도메인 관점으로 할당이 필요시 구현  
- 도메인 클레스에 비지니스 함수 구성  

**도메인의 구성요소**는 아래와 같다.  

1. 엔티티  
2. 밸류  
3. 애그리거트  
4. 리포지토리  
5. 도메인서비스  

**도메인 아키텍처**는 아래 4가지 계층 구분  

1. **표현**: DTO 기반 HTTP 연결점  
2. **응용**: 비지니스 로직  
3. **도메인**: 도메인 관리를 위한 각종 함수구현부  
4. **인프라스트럭처**: 외부서비스(DB, Broker, SMTP 등) 구현부  

![image02](/assets/기타/object4.png)  

순차적으로 의존하는 구조가 정석, **하위계층이 상위계층을 의존하는 방식을 절대 피해야함**  
단 편리성을 우해 상위계층은 두단계 아래의 하위계층을 의존하기도함  

**패키지 구성**은 아래와 같이 진행  

- 도메인 구성요소별로 패키지 모듈을 구성
- 도메인 아키텍처별로 패키지 모듈을 구성

정답은 없으며 (취향+편리성)을 토대로 구성하면 된다.  

> 개인적으로는 도메인 아키텍처별로 구성을 자주함

### 엔티티

엔티티의 가장 큰 특징은 식별자
두 엔티티 객체의 식별자가 같으면 두 엔티티는 같다고 판단할 수 있다.


### 밸류타입

밸류 타입은 개념적으로 완전한 하나를 표현하는 클래스타입  
값자체를 표현하는 클래스이기에 불변으로 정의할 것을 권장

아래와 같은 타입을 밸류타입이라 함  

```java
public class Address {
  private String address1; 
  private String address2; 
  private String zipcode;
}

public class Receiver {
  private String name; 
  private String phoneNumber;
}

public class Money {
  private int value;
}
```

불변 벨류타입의 경우 setter 금지  

### 애그리거트

연관된 엔티티와 밸류타입를 개념적으로 하나로 묶은 것, **사실상 [도메인 = 애그리거트] 라 할 수 있다**  

애그리거트는 계층+군집화 구조를 통해 도메인 모델을 관리한다.  

![image02](/assets/기타/object6.png)  

규모가 커질수록 많은 엔티티와 벨류가 추가되면서 애그리거트는 복잡해진다.  

그중 루트에 해당하는 엔티티를 **애그리커트의 본체**라 할 수 있으며 도메인 구현의 전체적인 그림을 가지고 있다.  

> `주문 애그리거트` 의 경우 `Root Entity` 엔티티는 `Order Class` 

**애그리거트는 다른 애그리거트를 변경하지 않도록 구성**해야 한다.  
독자적인 라이프 사이클을 갖는다면 별도의 애그리거트일 가능성이 높다.  

해당 규칙을 가지고 애그리거트(도메인)을 나누고 사이즈를 줄인다.  

`주문 애그리거트` 와 관련있는 객체들을 애그리거트 단위로 묶어 표현하면 아래 그림과 같다.   

![image02](/assets/기타/object7.png)  

또한 에그리거트에 속하는 엔티티, 벨류 값을 외부에서 변경하면 안되고
루트에서만 수정할 수 있도록 구성해야 한다.  

```java
@Entity
@Table(name = "purchase_order")
@Access(AccessType.FIELD)
public class Order {
    private OrderNo number;
    private List<OrderLine> orderLines;
    protected Order() {
    }

    public Order(OrderNo number, List<OrderLine> orderLines) {
        setNumber(number);
        setOrderLines(orderLines);
    }

    private void setNumber(OrderNo number) {
        if (number == null) throw new IllegalArgumentException("no number");
        this.number = number;
    }

    private void setOrderLines(List<OrderLine> orderLines) {
        verifyAtLeastOneOrMoreOrderLines(orderLines);
        this.orderLines = orderLines;
        calculateTotalAmounts();
    }

    private void verifyAtLeastOneOrMoreOrderLines(List<OrderLine> orderLines) {
        if (orderLines == null || orderLines.isEmpty()) {
            throw new IllegalArgumentException("no OrderLine");
        }
    }
}
```

`setter` 가 외부로 노출되는일이 없도록 `private` 으로 구성  

위 그림처럼 애그리거트간 연관성이 있어 매핑을 해야 하는 경우  
직접 참조 보다는 ID 필드를 삽입하여 사용하는 것을 권장한다.  

`N:M` 관계에 대해서도 ID 만 가지고 별도의 연관 조인테이블 생성을 권장한다.  

```java
public class Product {

  @ElementCollection 
  @CollectionTable(name = “product_category”, joinColumns = 
    @JoinColumn(name = “product_id”))
  private Set<CategoryId> categoryIds;
  ...
}
```

### 리포지토리  

`Spring Data JPA` 를 기반으로 설명  

한 트랜잭션에서는 한 개의 애그리거트만 수정해야한다.  

트랜잭션 성능이슈 뿐만 아니라 두개 이상 애그리거트 수정이 필요하다는 것은 애그리거트 간 결합도가 높다는 것.  

물론 한번의 사용자 요청으로 두개이상의 애그리거트 수정이 필요할 수 있는데  
각 애그리거트 루트객체를 기반으로 수정하는것을 권장한다.  

또한 JPA ORM 으로 도메인객체 정의시 아래 어노테이션 사용을 권장한다.  

- 루트엔티티는 `@Entity`  
- 벨류객체는 `@Embeddable`  

구현상 밸류객체도 DB테이블로 저장해야할 상황일 경우 아래와 같이 하나의 트랜잭션에 모든 도메인 객체들이 같이 저장, 삭제될 수 있도록 구성해야 한다.  

- `@ElementCollection`  
- `@OneToMany(cascade = {CascadeType.PERSIST, CascadeType.REMOVE}, orphanRemoval = true)`

> 단 벨류객체를 위한 테이블을 생성하고 지연로딩을 사용하지 않을경우 항상 `N+1`, `Catasian Product` 이슈를 조심해야함  

### 도메인 서비스  

애그리거트의 영역의 경계가 모호해지는 지점이 있다.  

물건을 주문하고 결제까지 진행할 때 아래와 같은 도메인들이 필요하다.  

- 상품 에그리거트  
- 주문 에그리거트  
- 할인 에그리거트  
- 회원 에그리거트  

비지니스 로직을 구성할 때 억지로 도메인 클래스안에 함수를 구현하는것 보다  

여러 도메인 기능을 합진 별도의 **도메인서비스** 를 구현하는것을 권장한다.  

```java
public class DiscountCalculationService {
  public Money calculateDiscountAmounts(List<OrderLine> orderLines, List<Coupon> coupons, MemberGrade grade) {
    ...
  }
  private Money calculateDiscount(Coupon coupon) {
    ...
  }

  private Money calculateDiscount(MemberGrade grade) {
    ...
  }
}
```

트랜잭션 처리를 담당하는 응용서비스가 주로 도메인서비스를 호출한다.  

> 같은 `DB`의 애그리거트가 아닌 외부시스템의 도메인과도 엮일 수 있다.  
> 그래서 `interface` 로도 자주 구현함  

### 바운디드 컨텍스트

> Bounded Context: 경계를 갖는 컨텍스트

도메인은 상하관계를 가지며 모든 도메인들은 서로 연결되어 있다.  

![image02](/assets/기타/object8.png)  

`회원도메인`은 각 도메인 에서 여러명칭으로 불릴 수 있다.  

`주문도메인`에선 `주문자`  
`배송도메인`에선 `배송인`  

이렇게 한 도메인을 가지고 다른 명칭으로 구분짖는 경계가 있는데 **이 경계를 바운디드 컨텍스트**라 부른다.  
도메인마다 하위 도메인을 부르는 명칭도 다르고 관계도 다르다(`1:N` or `1:1`)  

이 경계를 잘 정의해야 복잡한 시스템에서 수월한 유지보수가 가능해진다.  

도메인에서 중복적으로 사용하는 하위 모델을 모든 도메인에서 참조하는 것 보다 각자 별도로 구성해서 사용하는것을 권장한다.  
하나의 모델을 서로 참조해서 엉키는 것보다 결합도와 응집도를 높힐 수 있는 방법이다.  

바운디드 컨텍스트는 단순 도메인 클래스만 포함하지 않고 표현, 응용, 인프라스트럭쳐도 같이 포함되며  
따라서 각 바운디드 컨텍스트는 반드시 하나의 서버에 있을 필요 없고 각 다른 기술로 다른 서버에 구현하여도 상관없다.  

만약 바운디드 컨텍스트에 직접 접근시에는 REST 방식, 간접 접근시에는 MQ 방식을 추천한다.  

> 이런 특성때문에 바운디드 컨텍스트간 결합시에 중간에 `interface` 를 하나 껴서 **DIP 형태**로 구성하는 것을 추천한다. 바운디드 컨텍스트간 침범을 막아주는 **안티코럽션 계층(Anticorruption Layer)** 이라고도 한다.  
> 안티코럽션 계층은 바운디드 컨텍스트간 공유될 수 있으며 **공유커널(Shared Kernel)** 이라 부를 수 있다.(공유시 발생하는 단점 장점이 있음으로 할지 말지는 개발자 자유)  
> **통합하는 방식인 독립방식(Sperate Way)** 도 존재한다. 수동 혹은 배치와 같은 방식으로 각바운디드 컨텍스트에서 성장한 모델을 통합(동기화) 시켜준다.  

바운디드 컨텍스트는 상류, 하류 컴포넌트로 나눌 수 있다.  

- API 를 호출하는 쪽이 **하류컴포넌트**  
- API 에 반환하는 쪽이 **상류컴포넌트**  

상류컴포넌트는 하류컴포넌트들이 사용할 수 있도록 API 를 정의하고 공개하는데  
**상류컴포넌트**를 **공개 호스트 서비스(OHS: Open Host Service)** 라고도 한다.  

지금까지 배운 개념을 가지고 전체적인 그림 **컨텍스트 맵** 을 그리는 것도  
핵심 도메인 파악에 도움을 준다.  

![image02](/assets/기타/object9.png)  

그림과 같이 **안티코럽션 계층과 공개 호스트 서비스**를 가지고 바운디드 컨텍스트 맵을 표기  

### 컨텍스트 이벤트  

컨텍스트 간 강결합 해소를 위해 이벤트 구조를 사용할 수 있다.  

여러개의 바운디드 텍스트가 굳이 하나의 트랜잭션 내에서 처리될 필요 없다면  
트랜잭션 에러를 피하기 위해서라도 이벤트 방식 사용이 권장된다.  

- ApplicationEventPublisher  
- DB Event Store  
- MQ Broker  

비동기 이벤트 방식은 항상 아래와 같은 상황에 대해 고려해야 한다.  

- 이벤트 전송실패  
- 이벤트 장애  
- 이벤트 중복처리  
- 이벤트 순서  

사실 위 장애들에 대한 완벽한 정답은 없다.  
